<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
  <title>Peerloom - Chatroom</title>
  <link rel="icon" href="/android-chrome-192x192.png" sizes="192x192" type="image/png">
  <link rel="icon" href="/android-chrome-512x512.png" sizes="512x512" type="image/png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="stylesheet" href="chatroom.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <script type="module" src="js/supabaseClient.js"></script>
  
  <style>
    /* Seen status indicator */
    .seen-status {
      margin-left: 6px;
      font-size: 0.85em;
    }
    .seen-status.sent i {
      color: #9ca3af; /* Gray single check */
    }
    .seen-status.delivered i {
      color: #9ca3af; /* Gray double check */
    }
    .seen-status.seen i {
      color: #4ade80; /* Green checkmark */
    }
  </style>
</head>
<body>
  <div class="chat-arena">
    <!-- Chat Header -->
    <div class="chat-header">
      <button class="back-button" id="backButton">
        <i class="fas fa-arrow-left"></i>
      </button>
      <h1 id="groupTitle">Group Chat</h1>
      <div class="header-actions">
        <button class="icon-btn" id="voiceCallButton">
          <i class="fas fa-phone"></i>
        </button>
        <button class="icon-btn" id="videoCallButton">
          <i class="fas fa-video"></i>
        </button>
        <button class="icon-btn" id="themeToggleButton">
          <i class="fas fa-moon"></i>
        </button>
        <button class="icon-btn" id="adminPanelButton">
          <i class="fas fa-cog"></i>
        </button>
      </div>
    </div>

    <!-- Messages Container -->
    <div class="chat-messages" id="messagePanel">
      <!-- Messages will be loaded here -->
    </div>

    <!-- Input Area -->
    <div class="chat-input-area">
      <div class="composer-container">
        <div class="composer-actions">
          <input type="file" id="fileInput" style="display: none;" accept="image/*,video/*,application/pdf,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document" />
          <button class="composer-action-btn" id="fileShareButton" title="Attach file">
            <i class="fas fa-paperclip"></i>
          </button>
          <button class="composer-action-btn" id="emojiButton" title="Emoji">
            <i class="far fa-smile"></i>
          </button>
          <button class="composer-action-btn" id="pollButton" title="Create poll">
            <i class="fas fa-poll"></i>
          </button>
        </div>
        
        <textarea 
          id="messageBar" 
          class="message-composer" 
          data-placeholder="Type here" 
          rows="1"
          placeholder="Message..."
        ></textarea>
        
        <div class="composer-actions">
          <button class="composer-action-btn" id="recordAudioButton" title="Record voice message">
            <i class="fas fa-microphone"></i>
          </button>
          <button class="send-button" id="sendMessageButton">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
      
      <!-- Emoji and Mention Pickers -->
      <div class="emoji-picker" id="emojiPickerBox"></div>
      <div class="mention-list" id="mentionListBox"></div>
      
      <!-- Reply Context -->
      <div class="reply-context" id="replyContextBox" style="display: none;">
        <div class="reply-context-content">
          <div class="reply-context-sender" id="replyContextSender"></div>
          <div class="reply-context-text" id="replyContextText"></div>
        </div>
        <button class="reply-context-close" id="replyContextClose">Ã—</button>
      </div>
    </div>
  </div>

  <!-- Modern Recording Indicator -->
  <div class="recording-indicator" id="recordingIndicator">
    <div class="pulse"></div>
    <span>Recording... Tap to stop</span>
    <div class="recording-time" id="recordingTime">00:00</div>
  </div>

  <!-- Backdrop -->
  <div id="drawerBackdrop" class="drawer-backdrop"></div>

  <!-- Group Drawer -->
  <div class="group-drawer" id="groupDrawer" aria-hidden="true" role="dialog" aria-label="Group members">
    <div class="drawer-header">
      <h2>Group Members</h2>
      <p>Connect with your team</p>
    </div>
    <div class="members-list" id="membersList">
      <!-- Members will be loaded here -->
    </div>
    <div class="drawer-footer">
      <button class="share-btn" id="shareGroupBtn">
        <i class="fas fa-share-alt"></i>
        Share Group
      </button>
      <button class="leave-btn" id="leaveGroupBtn">
        <i class="fas fa-sign-out-alt"></i>
        Leave Group
      </button>
    </div>
  </div>

  <!-- Lightbox for viewing images/videos -->
  <div class="lightbox" id="lightbox">
    <span class="lightbox-close" id="lightboxClose">&times;</span>
    <div class="lightbox-content" id="lightboxContent">
      <!-- Image or video will be inserted here -->
    </div>
  </div>

  <!-- Share Group Modal -->
  <div class="modal-backdrop" id="shareGroupModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Share Group</div>
        <div class="modal-description">Share this link to invite others to join your group</div>
      </div>
      <input type="text" class="modal-input" id="shareGroupInput" readonly>
      <div class="modal-actions">
        <button class="modal-btn cancel" id="shareGroupCancel">Close</button>
        <button class="modal-btn confirm" id="shareGroupCopy">Copy Link</button>
      </div>
    </div>
  </div>

  <!-- Edit Message Modal -->
  <div class="modal-backdrop" id="editMessageModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Edit Message</div>
        <div class="modal-description">Update your message below</div>
      </div>
      <input type="text" class="modal-input" id="editMessageInput" placeholder="Type your message...">
      <div class="modal-actions">
        <button class="modal-btn cancel" id="editMessageCancel">Cancel</button>
        <button class="modal-btn confirm" id="editMessageConfirm">Update</button>
      </div>
    </div>
  </div>

  <!-- Delete Message Modal -->
  <div class="modal-backdrop" id="deleteMessageModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Delete Message</div>
        <div class="modal-description">Are you sure you want to delete this message? This action cannot be undone.</div>
      </div>
      <div class="modal-actions">
        <button class="modal-btn cancel" id="deleteMessageCancel">Cancel</button>
        <button class="modal-btn delete" id="deleteMessageConfirm">Delete</button>
      </div>
    </div>
  </div>

  <!-- File Preview Modal -->
  <div class="modal-backdrop" id="filePreviewModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Send File</div>
        <div class="modal-description">Review your file before sending.</div>
      </div>
      <div id="filePreviewContent" style="text-align: center; margin-bottom: 1.5rem;">
        <!-- Preview will be inserted here -->
      </div>
      <div class="modal-actions">
        <button class="modal-btn cancel" id="filePreviewCancel">Cancel</button>
        <button class="modal-btn confirm" id="filePreviewSend">Send</button>
      </div>
    </div>
  </div>

  <!-- Admin Panel Modal -->
  <div class="modal-backdrop" id="adminModal">
    <div class="modal-content" style="width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;">
      <div class="modal-header">
        <div class="modal-title">Admin Panel</div>
      </div>
      <div id="adminActions" style="display: flex; flex-direction: column; gap: 0.5rem; padding: 1rem 0;"></div>
      <div class="modal-actions">
        <button class="modal-btn cancel" id="closeAdmin">Close</button>
      </div>
    </div>
  </div>

  <!-- Delete Group Modal -->
  <div class="modal-backdrop" id="deleteGroupModal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">Delete Group</div>
        <div class="modal-description">This action cannot be undone. All messages, members, and data will be permanently deleted.</div>
      </div>
      <div class="modal-actions">
        <button class="modal-btn cancel" id="cancelDeleteGroup">Cancel</button>
        <button class="modal-btn delete" id="confirmDeleteGroup">Delete Group</button>
      </div>
    </div>
  </div>

  <script type="module">
    // Import Supabase client
    import { supabase } from './js/supabaseClient.js';
    
    // ===== INITIALIZE SESSION =====
    const session = await supabase.auth.getSession();
    if (!session.data.session) {
      window.location.href = 'login.html';
    }
    
    const user = session.data.session.user;
    const gid = new URLSearchParams(window.location.search).get('groupId');
    
    // ===== STATE MANAGEMENT =====
    let state = {
      replyingMsg: null,
      isRecording: false,
      editingMessage: null,
      deletingMessage: null,
      groupCreatorId: null,
      mediaRecorder: null,
      stagedFile: null,
      audioChunks: [],
      recordingTimer: null,
      recordingSeconds: 0,
      userRole: 'member',
      isPublic: false,
      groupInfo: {},
      memberDetails: [],
      isMember: false,
      aiResponseInProgress: false,
      typingUsers: new Map(),
      typingTimeout: null,
      mentionUsers: [],
      currentMentionQuery: '',
      downloadedFiles: new Set(JSON.parse(localStorage.getItem('downloadedFiles') || '[]'))
    };
    
    // ===== CONSTANTS =====
    const AI_USER_ID = 'bdb2a62c-7ef7-4f1d-a67a-a3290d276cbe';
    const AI_USER_NAME = 'PeerPal AI';
    const GEMINI_API_KEY = 'AIzaSyBTu6F08xvbbCflrvSJSSsHzk6bAMZs12Q';
    const AI_MODELS = ['gemini-2.0-flash', 'gemini-2.0-flash-lite'];
    
    // ===== DOM ELEMENTS =====
    const elements = {
      // Main containers
      messagePanel: document.getElementById('messagePanel'),
      groupTitle: document.getElementById('groupTitle'),
      
      // Header
      backButton: document.getElementById('backButton'),
      themeToggleButton: document.getElementById('themeToggleButton'),
      adminPanelButton: document.getElementById('adminPanelButton'),
      voiceCallButton: document.getElementById('voiceCallButton'),
      videoCallButton: document.getElementById('videoCallButton'),
      
      // Input area
      emojiButton: document.getElementById('emojiButton'),
      fileShareButton: document.getElementById('fileShareButton'),
      pollButton: document.getElementById('pollButton'),
      recordAudioButton: document.getElementById('recordAudioButton'),
      messageBar: document.getElementById('messageBar'),
      sendMessageButton: document.getElementById('sendMessageButton'),
      fileInput: document.getElementById('fileInput'),
      
      // Pickers
      emojiPickerBox: document.getElementById('emojiPickerBox'),
      mentionListBox: document.getElementById('mentionListBox'),
      
      // Reply context
      replyContextBox: document.getElementById('replyContextBox'),
      replyContextSender: document.getElementById('replyContextSender'),
      replyContextText: document.getElementById('replyContextText'),
      replyContextClose: document.getElementById('replyContextClose'),
      
      // Group drawer
      groupDrawer: document.getElementById('groupDrawer'),
      membersList: document.getElementById('membersList'),
      shareGroupBtn: document.getElementById('shareGroupBtn'),
      leaveGroupBtn: document.getElementById('leaveGroupBtn'),
      drawerBackdrop: document.getElementById('drawerBackdrop'),
      
      // Recording
      recordingIndicator: document.getElementById('recordingIndicator'),
      recordingTime: document.getElementById('recordingTime'),
      
      // Modals
      shareGroupModal: document.getElementById('shareGroupModal'),
      shareGroupInput: document.getElementById('shareGroupInput'),
      shareGroupCancel: document.getElementById('shareGroupCancel'),
      shareGroupCopy: document.getElementById('shareGroupCopy'),
      
      editMessageModal: document.getElementById('editMessageModal'),
      editMessageInput: document.getElementById('editMessageInput'),
      editMessageCancel: document.getElementById('editMessageCancel'),
      editMessageConfirm: document.getElementById('editMessageConfirm'),
      
      deleteMessageModal: document.getElementById('deleteMessageModal'),
      deleteMessageCancel: document.getElementById('deleteMessageCancel'),
      deleteMessageConfirm: document.getElementById('deleteMessageConfirm'),
      
      filePreviewModal: document.getElementById('filePreviewModal'),
      filePreviewContent: document.getElementById('filePreviewContent'),
      filePreviewCancel: document.getElementById('filePreviewCancel'),
      filePreviewSend: document.getElementById('filePreviewSend'),
      
      adminModal: document.getElementById('adminModal'),
      adminActions: document.getElementById('adminActions'),
      closeAdmin: document.getElementById('closeAdmin'),
      
      deleteGroupModal: document.getElementById('deleteGroupModal'),
      cancelDeleteGroup: document.getElementById('cancelDeleteGroup'),
      confirmDeleteGroup: document.getElementById('confirmDeleteGroup'),
      
      lightbox: document.getElementById('lightbox'),
      lightboxClose: document.getElementById('lightboxClose'),
      lightboxContent: document.getElementById('lightboxContent'),
      
      body: document.body
    };
    
    // ===== THEME MANAGEMENT =====
    const applyTheme = (theme) => {
      elements.body.dataset.theme = theme;
      const icon = elements.themeToggleButton.querySelector('i');
      if (theme === 'dark') {
        icon.className = 'fas fa-moon';
      } else {
        icon.className = 'fas fa-sun';
      }
      localStorage.setItem('peerloom-theme', theme);
    };
    
    elements.themeToggleButton.onclick = () => {
      const currentTheme = elements.body.dataset.theme;
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      applyTheme(newTheme);
    };
    
    // Apply saved theme
    const savedTheme = localStorage.getItem('peerloom-theme') || 'dark';
    applyTheme(savedTheme);
    
    // ===== BACK BUTTON =====
    elements.backButton.onclick = () => {
      window.location.href = 'dashboard.html';
    };
    
    // ===== UTILITY FUNCTIONS =====
    function createDefaultAvatar(name) {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      const colors = ['#007AFF', '#5856D6', '#AF52DE', '#FF9500', '#FF3B30'];
      const color = colors[name.length % colors.length];
      ctx.fillStyle = color;
      ctx.fillRect(0, 0, 64, 64);
      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(name.charAt(0).toUpperCase(), 32, 32);
      return canvas.toDataURL();
    }
    
    function getDisplayName(member) {
      if (member.user_id === AI_USER_ID) {
        return AI_USER_NAME;
      }
      if (member.profiles) {
        return member.profiles.full_name || member.profiles.username || `User ${member.user_id.substring(0,6)}`;
      }
      return `User ${member.user_id.substring(0,6)}`;
    }
    
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      const now = new Date();
      const diff = now - date;
      
      if (diff < 60000) {
        return 'Just now';
      } else if (diff < 3600000) {
        const minutes = Math.floor(diff / 60000);
        return `${minutes}m ago`;
      } else if (diff < 86400000) {
        const hours = Math.floor(diff / 3600000);
        return `${hours}h ago`;
      } else {
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      }
    }
    
    function formatFileSize(bytes, decimals = 2) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
    
    function isDownloaded(url) {
      return state.downloadedFiles.has(url);
    }
    
    function markAsDownloaded(url) {
      state.downloadedFiles.add(url);
      localStorage.setItem('downloadedFiles', JSON.stringify(Array.from(state.downloadedFiles)));
    }
    
    async function downloadWithAnimation(event, url, filename) {
      event.preventDefault();
      event.stopPropagation();
      const downloadButton = event.currentTarget;
      if (downloadButton.classList.contains('downloading')) return;
      
      const originalContent = downloadButton.innerHTML;
      downloadButton.innerHTML = '<div class="download-animation"></div>';
      downloadButton.classList.add('downloading');
      
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok.');
        const blob = await response.blob();
        
        const tempUrl = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = tempUrl;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(tempUrl);
        a.remove();
        
        markAsDownloaded(url);
        downloadButton.style.display = 'none';
      } catch (error) {
        console.error('Download failed:', error);
        alert('Download failed. Please try again.');
        downloadButton.innerHTML = originalContent;
      } finally {
        downloadButton.classList.remove('downloading');
      }
    }
    
    function createRipple(event) {
      const button = event.currentTarget;
      const circle = document.createElement('span');
      const diameter = Math.max(button.clientWidth, button.clientHeight);
      const radius = diameter / 2;
      
      circle.style.width = circle.style.height = `${diameter}px`;
      circle.style.left = `${event.clientX - button.getBoundingClientRect().left - radius}px`;
      circle.style.top = `${event.clientY - button.getBoundingClientRect().top - radius}px`;
      circle.classList.add('ripple');
      
      const ripple = button.getElementsByClassName('ripple')[0];
      if (ripple) ripple.remove();
      
      button.appendChild(circle);
    }
    
    // ===== INITIALIZATION =====
    async function initialize() {
      try {
        // Load group data
        await loadGroupData();
        
        // Load members
        await loadMembers();
        
        // Load messages
        await loadHistory();
        
        // Mark unread messages as seen
        markMessagesAsDelivered();
        markMessagesAsSeen();
        
        // Ensure AI user is in group
        await ensureAIUserInGroup();
        
        // Initialize mention system
        initMentionSystem();
        
        // Initialize emoji picker
        initEmojiPicker();
        
        // Set up event listeners
        setupEventListeners();
        
        // Set up real-time subscriptions
        setupRealtimeSubscriptions();
        
        // Scroll to bottom
        setTimeout(() => {
          elements.messagePanel.scrollTop = elements.messagePanel.scrollHeight;
        }, 100);
        
      } catch (error) {
        console.error('Initialization error:', error);
        showError('Failed to initialize chat');
      }
    }
    
    // ===== GROUP DATA LOADING =====
    async function loadGroupData() {
      try {
        const { data: grp, error: grpError } = await supabase
          .from('groups')
          .select('name, description, created_by, is_public, course_code')
          .eq('id', gid)
          .single();
        
        if (grpError) throw grpError;
        
        state.groupInfo = grp;
        state.groupCreatorId = grp.created_by;
        state.isPublic = grp.is_public || false;
        
        elements.groupTitle.innerHTML = `<span>${grp.name}</span><br><small style="font-size: 0.8rem; opacity: 0.7; font-style: italic;">${grp.description || ''}</small>`;
        
      } catch (error) {
        console.error('Error loading group data:', error);
        showError('Failed to load group data');
      }
    }
    
    async function loadMembers() {
      try {
        // Step 1: Get members
        const { data: members, error: membersError } = await supabase
          .from('group_members')
          .select('user_id, role, joined_at')
          .eq('group_id', gid);
        
        if (membersError) throw membersError;

        // Step 2: Get profiles for these members manually to avoid FK relationship issues
        let profiles = [];
        if (members && members.length > 0) {
          const userIds = members.map(m => m.user_id);
          const { data: profilesData, error: profilesError } = await supabase
            .from('profiles')
            .select('id, username, full_name, profile_photo')
            .in('id', userIds);
          
          if (profilesError) throw profilesError;
          profiles = profilesData || [];
        }

        // Step 3: Merge data
        state.memberDetails = (members || []).map(member => {
          const profile = profiles.find(p => p.id === member.user_id);
          return { ...member, profiles: profile };
        });

        state.isMember = state.memberDetails.some(m => m.user_id === user.id);
        
        // Determine user role
        const userMember = state.memberDetails.find(m => m.user_id === user.id);
        state.userRole = userMember ? (userMember.role || 'member') : 'member';
        if (user.id === state.groupCreatorId) {
          state.userRole = 'owner';
        }
        
        // Show/hide admin panel button
        if (state.userRole === 'member') {
          elements.adminPanelButton.style.display = 'none';
        } else {
          elements.adminPanelButton.style.display = 'flex';
        }
        
      } catch (error) {
        console.error('Error loading members:', error);
        state.memberDetails = [];
      }
    }
    
    async function ensureAIUserInGroup() {
      const isAIInGroup = state.memberDetails.some(m => m.user_id === AI_USER_ID);
      if (!isAIInGroup) {
        try {
          const { error } = await supabase
            .from('group_members')
            .insert({
              group_id: gid,
              user_id: AI_USER_ID,
              role: 'ai'
            });
          
          if (error && error.code !== '23505') {
            console.log('Error adding AI user:', error);
          } else {
            await loadMembers();
          }
        } catch (err) {
          console.log('Error adding AI user:', err);
        }
      }
    }
    
    async function markMessageAsDelivered(msgId) {
      try {
        const { error } = await supabase.from('group_messages')
          .update({ delivered_at: new Date().toISOString() })
          .eq('id', msgId);
        if (error && error.code !== 'PGRST204') console.error('Error marking message delivered:', error);
      } catch (err) {
        console.error('Error in markMessageAsDelivered:', err);
      }
    }
    
    async function markMessagesAsSeen() {
      try {
        const { error } = await supabase
          .from('group_messages')
          .update({ seen_at: new Date().toISOString() })
          .eq('group_id', gid)
          .neq('sender_id', user.id)
          .is('seen_at', null);
        if (error) console.error('Error marking messages seen:', error);
      } catch (err) {
        console.error('Error in markMessagesAsSeen:', err);
      }
    }
    
    async function markMessagesAsDelivered() {
      try {
        const { error } = await supabase
          .from('group_messages')
          .update({ delivered_at: new Date().toISOString() })
          .eq('group_id', gid)
          .neq('sender_id', user.id)
          .is('delivered_at', null);
        if (error && error.code !== 'PGRST204') console.error('Error marking messages delivered:', error);
      } catch (err) {
        console.error('Error in markMessagesAsDelivered:', err);
      }
    }
    
    // ===== MESSAGE SYSTEM =====
    async function loadHistory() {
      try {
        const { data } = await supabase
          .from('group_messages')
          .select('*')
          .eq('group_id', gid)
          .order('created_at');
        
        elements.messagePanel.innerHTML = '';
        if (data) {
          data.forEach(render);
        }
      } catch (error) {
        console.error('Error loading messages:', error);
        showError('Failed to load messages');
      }
    }
    
    function render(m) {
      const mine = m.sender_id === user.id;
      const isAI = m.sender_id === AI_USER_ID;
      
      let senderName;
      if (mine) {
        senderName = user.user_metadata.firstName || user.user_metadata.full_name || 'You';
      } else if (isAI) {
        senderName = AI_USER_NAME;
      } else {
        const senderMember = state.memberDetails.find(member => member.user_id === m.sender_id);
        senderName = senderMember ? getDisplayName(senderMember) : m.sender_name || `User ${m.sender_id.substring(0,6)}`;
      }
      
      const div = document.createElement('div');
      div.className = `msg ${mine ? 'sent' : isAI ? 'ai' : 'recv'}`;
      div.dataset.id = m.id;
      
      // Add reply banner if exists
      if (m.reply_to) {
        const replyDiv = document.createElement('div');
        replyDiv.className = 'reply-banner';
        replyDiv.textContent = `${m.reply_to_sender}: ${m.reply_to_text}`;
        div.appendChild(replyDiv);
      }
      
      // Add sender name
      const nameTag = document.createElement('div');
      nameTag.className = 'sender-name';
      nameTag.textContent = senderName;
      div.appendChild(nameTag);
      
      // Add message content
      const ct = document.createElement('div');
      ct.className = 'message-content';
      
      if (m.message_type === 'placeholder') {
        ct.innerHTML = m.content;
      } else if (m.message_type === 'uploading') {
        ct.innerHTML = createUploadingFileElement(m);
      } else if (m.message_type === 'audio' && m.audio_url) {
        ct.appendChild(createVoiceMessageElement(m, mine));
      } else if (m.message_type === 'image') {
        ct.innerHTML = createImageElement(m);
      } else if (m.message_type === 'video') {
        ct.innerHTML = createVideoElement(m);
      } else if (m.message_type === 'file') {
        ct.innerHTML = createFileElement(m);
      } else if (m.message_type === 'poll') {
        ct.innerHTML = '<p>Loading poll...</p>';
        loadPollData(m, ct);
      } else {
        ct.innerHTML = processMentions(m.content);
      }
      
      div.appendChild(ct);
      
      // Add timestamp
      const ts = document.createElement('div');
      ts.className = 'timestamp';
      let statusHtml = '';
      if (mine) {
        let iconClass = 'fa-check';
        let statusClass = 'sent';
        if (m.seen_at) {
          iconClass = 'fa-check-double';
          statusClass = 'seen';
        } else if (m.delivered_at) {
          iconClass = 'fa-check-double';
          statusClass = 'delivered';
        }
        statusHtml = `<span class="seen-status ${statusClass}"><i class="fas ${iconClass}"></i></span>`;
      }
      ts.innerHTML = `${formatTime(m.created_at)}${statusHtml}`;
      div.appendChild(ts);
      
      // Add to message panel
      elements.messagePanel.appendChild(div);
      
      // Add event listeners for AI mentions
      const aiMentions = div.querySelectorAll('.mention.ai-mention');
      aiMentions.forEach(mention => {
        mention.addEventListener('click', (e) => {
          e.stopPropagation();
          const userId = mention.dataset.userId;
          if (userId === AI_USER_ID) {
            elements.messageBar.value = elements.messageBar.value.trim() + ' @PeerPal AI ';
            elements.messageBar.focus();
            setTimeout(() => checkPeerloomAI('@PeerPal AI'), 500);
          }
        });
      });
      
      // Add swipe gestures for messages
      if (m.message_type !== 'audio' || mine) {
        attachGestures(div, mine, m);
      }
      
      // Scroll to bottom
      elements.messagePanel.scrollTop = elements.messagePanel.scrollHeight;
    }
    
    // ===== MESSAGE ELEMENT CREATORS =====
    function createUploadingFileElement(m) {
      return `
        <div class="file-attachment-card">
          <div class="file-icon-wrapper"><i class="fas fa-file-alt"></i></div>
          <div class="file-info">
            <div class="file-name">${m.file_name}</div>
            <div class="upload-progress-container">
              <div class="upload-progress-bar-wrapper">
                <div class="upload-progress-bar" id="progress-${m.id}"></div>
              </div>
              <span class="upload-progress-text" id="progress-text-${m.id}">0%</span>
            </div>
          </div>
        </div>
      `;
    }
    
    function createVoiceMessageElement(m, isSent) {
      const bubble = document.createElement('div');
      bubble.className = 'voice-message-bubble';
      
      const playBtn = document.createElement('button');
      playBtn.className = 'voice-play-btn';
      playBtn.innerHTML = '<i class="fas fa-play"></i>';
      
      const waveform = document.createElement('div');
      waveform.className = 'voice-waveform';
      for (let i = 0; i < 10; i++) {
        const bar = document.createElement('div');
        bar.className = 'wave-bar';
        bar.style.height = `${8 + Math.random() * 22}px`;
        waveform.appendChild(bar);
      }
      
      const durationSpan = document.createElement('div');
      durationSpan.className = 'voice-duration';
      durationSpan.textContent = formatTime(m.duration || 0);
      
      bubble.appendChild(playBtn);
      bubble.appendChild(waveform);
      bubble.appendChild(durationSpan);
      
      // Add delete button if sent or admin
      if (isSent || state.userRole !== 'member') {
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'voice-delete-btn';
        deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
        deleteBtn.title = 'Delete voice message';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          showDeleteMessageModal(m.id);
        });
        bubble.appendChild(deleteBtn);
      }
      
      // Audio playback logic
      const audio = new Audio(m.audio_url);
      audio.preload = 'metadata';
      let isPlaying = false;
      
      playBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (isPlaying) {
          audio.pause();
          playBtn.innerHTML = '<i class="fas fa-play"></i>';
          bubble.classList.remove('playing');
        } else {
          audio.play();
          playBtn.innerHTML = '<i class="fas fa-pause"></i>';
          bubble.classList.add('playing');
        }
        isPlaying = !isPlaying;
      });
      
      audio.addEventListener('ended', () => {
        playBtn.innerHTML = '<i class="fas fa-play"></i>';
        bubble.classList.remove('playing');
        isPlaying = false;
      });
      
      return bubble;
    }
    
    function createImageElement(m) {
      const isDownloadedFlag = isDownloaded(m.content);
      return `
        <div class="media-container">
          <img src="${m.content}" alt="${m.file_name || 'Image'}" 
               style="width: 100%; display: block; border-radius: ${isDownloadedFlag ? '15px' : '15px 15px 15px 4px'}; cursor: pointer;"
               onclick="openLightbox('${m.content}', 'image')">
          ${!isDownloadedFlag ? `
            <button class="media-download-btn" title="Download" onclick="downloadWithAnimation(event, '${m.content}', '${m.file_name || 'image'}')">
              <i class="fas fa-download"></i>
            </button>
          ` : ''}
        </div>
      `;
    }
    
    function createVideoElement(m) {
      const isDownloadedFlag = isDownloaded(m.content);
      return `
        <div class="media-container" style="cursor: pointer;" onclick="openLightbox('${m.content}', 'video')">
          <video src="${m.content}#t=0.1" preload="metadata" style="width: 100%; display: block; border-radius: ${isDownloadedFlag ? '15px' : '15px 15px 15px 4px'}; pointer-events: none;"></video>
          <div class="media-play-btn">
            <i class="fas fa-play"></i>
          </div>
          ${!isDownloadedFlag ? `
            <button class="media-download-btn" title="Download" onclick="event.stopPropagation(); downloadWithAnimation(event, '${m.content}', '${m.file_name || 'video'}')">
              <i class="fas fa-download"></i>
            </button>
          ` : ''}
        </div>
      `;
    }
    
    function createFileElement(m) {
      const fileExt = m.file_name?.split('.').pop()?.toUpperCase() || 'FILE';
      return `
        <div class="file-attachment-card">
          <div class="file-icon-wrapper">
            <i class="fas fa-file-alt"></i>
          </div>
          <div class="file-info">
            <div class="file-name">${m.file_name || 'File'}</div>
            <div class="file-meta">${formatFileSize(m.file_size)} â€¢ ${fileExt} Document</div>
          </div>
          <a href="${m.content}" download="${m.file_name || 'File'}" class="download-btn-wrapper" title="Download">
            <i class="fas fa-download"></i>
          </a>
        </div>
      `;
    }
    
    async function loadPollData(m, container) {
      try {
        const pollId = m.content;
        const { data: poll, error: pollError } = await supabase
          .from('group_polls')
          .select('*')
          .eq('id', pollId)
          .single();
        
        if (pollError || !poll) {
          container.innerHTML = '<p>Invalid poll</p>';
          return;
        }
        
        const { data: votes, error: votesError } = await supabase
          .from('poll_votes')
          .select('selected_option, count(*)')
          .eq('poll_id', pollId)
          .group('selected_option');
        
        if (votesError) {
          console.error('Error fetching votes:', votesError);
        }
        
        const voteCounts = new Array(poll.options.length).fill(0);
        votes?.forEach(v => {
          voteCounts[v.selected_option] = v.count;
        });
        
        const totalVotes = voteCounts.reduce((sum, v) => sum + v, 0);
        
        const { data: myVote, error: myVoteError } = await supabase
          .from('poll_votes')
          .select('selected_option')
          .eq('poll_id', pollId)
          .eq('user_id', user.id)
          .single();
        
        const hasVoted = !!myVote;
        
        const pollDiv = document.createElement('div');
        pollDiv.className = 'poll-container';
        
        pollDiv.innerHTML = `
          <div class="poll-question">${poll.question}</div>
          <div class="poll-options"></div>
          <div class="poll-total-votes">Total votes: ${totalVotes}</div>
        `;
        
        const optionsContainer = pollDiv.querySelector('.poll-options');
        poll.options.forEach((opt, index) => {
          const votes = voteCounts[index];
          const percent = totalVotes > 0 ? (votes / totalVotes) * 100 : 0;
          
          const optionDiv = document.createElement('div');
          optionDiv.className = `poll-option ${hasVoted && myVote?.selected_option === index ? 'voted' : ''}`;
          optionDiv.innerHTML = `
            <div class="poll-option-bar" style="width: ${percent}%"></div>
            <div class="poll-option-text">${opt}</div>
            <div class="poll-option-votes">${votes} votes (${percent.toFixed(1)}%)</div>
          `;
          
          if (!hasVoted) {
            optionDiv.onclick = async () => {
              try {
                const { error } = await supabase
                  .from('poll_votes')
                  .insert({
                    poll_id: pollId,
                    user_id: user.id,
                    selected_option: index
                  });
                
                if (error) throw error;
                await loadHistory();
              } catch (error) {
                showError('Error voting: ' + error.message);
              }
            };
          }
          
          optionsContainer.appendChild(optionDiv);
        });
        
        // Add delete button for admins
        if (m.sender_id === user.id || state.userRole !== 'member') {
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'poll-delete-btn';
          deleteBtn.innerHTML = '<i class="fas fa-times"></i>';
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            showDeleteMessageModal(m.id);
          };
          pollDiv.appendChild(deleteBtn);
        }
        
        container.innerHTML = '';
        container.appendChild(pollDiv);
      } catch (error) {
        console.error('Error loading poll:', error);
        container.innerHTML = '<p>Error loading poll</p>';
      }
    }
    
    // ===== MENTION SYSTEM =====
    function initMentionSystem() {
      // Add AI user to mention list
      state.mentionUsers = [
        {
          id: AI_USER_ID,
          name: AI_USER_NAME,
          username: '@PeerPal AI',
          isAI: true,
          avatar: createDefaultAvatar('AI')
        }
      ];
      
      // Add all group members
      state.memberDetails.forEach(member => {
        if (member.user_id !== AI_USER_ID) {
          const displayName = getDisplayName(member);
          state.mentionUsers.push({
            id: member.user_id,
            name: displayName,
            username: `@${displayName}`,
            isAI: false,
            avatar: member.profiles?.profile_photo || createDefaultAvatar(displayName)
          });
        }
      });
      
      // Set up mention input handler
      elements.messageBar.addEventListener('input', handleMentionInput);
      elements.messageBar.addEventListener('keydown', handleMentionNavigation);
      
      // Close mention list when clicking outside
      document.addEventListener('click', (e) => {
        if (!elements.mentionListBox.contains(e.target) && e.target !== elements.messageBar) {
          elements.mentionListBox.style.display = 'none';
        }
      });
    }
    
    function handleMentionInput(e) {
      const text = elements.messageBar.value;
      const cursorPos = elements.messageBar.selectionStart;
      const textBeforeCursor = text.substring(0, cursorPos);
      const lastAtPos = textBeforeCursor.lastIndexOf('@');
      
      if (lastAtPos !== -1) {
        const charBeforeAt = lastAtPos > 0 ? textBeforeCursor[lastAtPos - 1] : ' ';
        if (lastAtPos === 0 || charBeforeAt === ' ' || charBeforeAt === '\n') {
          state.currentMentionQuery = textBeforeCursor.substring(lastAtPos + 1).toLowerCase();
          showMentionList();
          return;
        }
      }
      elements.mentionListBox.style.display = 'none';
    }
    
    function showMentionList() {
      let filteredUsers;
      if (!state.currentMentionQuery) {
        filteredUsers = state.mentionUsers;
      } else {
        filteredUsers = state.mentionUsers.filter(user =>
          user.name.toLowerCase().includes(state.currentMentionQuery) ||
          user.username.toLowerCase().includes(state.currentMentionQuery)
        );
      }
      
      renderMentionList(filteredUsers);
    }
    
    function renderMentionList(users) {
      elements.mentionListBox.innerHTML = '';
      
      if (users.length === 0) {
        elements.mentionListBox.style.display = 'none';
        return;
      }
      
      users.forEach(user => {
        const item = document.createElement('div');
        item.className = `mention-item ${user.isAI ? 'ai-mention' : ''}`;
        item.innerHTML = `
          <img src="${user.avatar}" class="mention-avatar" alt="${user.name}">
          <span>${user.name}</span>
          ${user.isAI ? '<span class="mention-badge">AI</span>' : ''}
        `;
        
        item.addEventListener('click', () => selectMention(user));
        elements.mentionListBox.appendChild(item);
      });
      
      // Position the mention list
      const rect = elements.messageBar.getBoundingClientRect();
      elements.mentionListBox.style.left = `${rect.left}px`;
      elements.mentionListBox.style.bottom = `${window.innerHeight - rect.top + 10}px`;
      elements.mentionListBox.style.width = `${rect.width}px`;
      elements.mentionListBox.style.display = 'flex';
    }
    
    function handleMentionNavigation(e) {
      if (elements.mentionListBox.style.display !== 'flex') return;
      
      const items = elements.mentionListBox.querySelectorAll('.mention-item');
      const activeItem = elements.mentionListBox.querySelector('.mention-item.active');
      let activeIndex = activeItem ? Array.from(items).indexOf(activeItem) : -1;
      
      switch(e.key) {
        case 'ArrowDown':
          e.preventDefault();
          activeIndex = (activeIndex + 1) % items.length;
          break;
        case 'ArrowUp':
          e.preventDefault();
          activeIndex = activeIndex <= 0 ? items.length - 1 : activeIndex - 1;
          break;
        case 'Enter':
          e.preventDefault();
          if (activeItem) {
            const userName = activeItem.querySelector('span').textContent;
            const user = state.mentionUsers.find(u => u.name === userName);
            if (user) selectMention(user);
          }
          return;
        case 'Escape':
          elements.mentionListBox.style.display = 'none';
          return;
      }
      
      items.forEach(item => item.classList.remove('active'));
      if (items[activeIndex]) {
        items[activeIndex].classList.add('active');
      }
    }
    
    function selectMention(selectedUser) {
      const text = elements.messageBar.value;
      const cursorPos = elements.messageBar.selectionStart;
      const textBeforeCursor = text.substring(0, cursorPos);
      const lastAtPos = textBeforeCursor.lastIndexOf('@');
      
      if (lastAtPos !== -1) {
        const newText = text.substring(0, lastAtPos) + selectedUser.username + ' ' + text.substring(cursorPos);
        elements.messageBar.value = newText;
        
        const newCursorPos = lastAtPos + selectedUser.username.length + 1;
        setTimeout(() => {
          elements.messageBar.setSelectionRange(newCursorPos, newCursorPos);
          elements.messageBar.focus();
        }, 10);
      }
      
      elements.mentionListBox.style.display = 'none';
      state.currentMentionQuery = '';
    }
    
    function processMentions(content) {
      let processedContent = content;
      const mentionRegex = /(@[^\s]+)/g;
      const mentions = content.match(mentionRegex);
      
      if (mentions) {
        mentions.forEach(mention => {
          const username = mention.substring(1);
          const user = state.mentionUsers.find(u =>
            u.name.toLowerCase().includes(username.toLowerCase()) ||
            u.username.toLowerCase() === mention.toLowerCase()
          );
          
          if (user) {
            const mentionClass = user.isAI ? 'mention ai-mention' : 'mention';
            const mentionHtml = `<span class="${mentionClass}" data-user-id="${user.id}">${mention}</span>`;
            processedContent = processedContent.replace(mention, mentionHtml);
          }
        });
      }
      
      return processedContent;
    }
    
    // ===== EMOJI PICKER =====
    function initEmojiPicker() {
      // Populate with common emojis
      const emojis = ['ðŸ˜€', 'ðŸ˜‚', 'ðŸ¥°', 'ðŸ˜Ž', 'ðŸ¤”', 'ðŸ‘', 'ðŸŽ‰', 'ðŸ’¯', 'ðŸ”¥', 'ðŸŒŸ', 'ðŸ’–', 'ðŸ‘', 'ðŸ‘Ž', 'ðŸ™', 'ðŸ¤', 'ðŸ’ª', 'ðŸ§ ', 'ðŸŽ¯', 'ðŸš€', 'ðŸ’¡'];
      
      emojis.forEach(emoji => {
        const span = document.createElement('span');
        span.textContent = emoji;
        span.style.cursor = 'pointer';
        span.style.fontSize = '20px';
        span.addEventListener('click', () => {
          elements.messageBar.value += emoji;
          elements.emojiPickerBox.style.display = 'none';
        });
        elements.emojiPickerBox.appendChild(span);
      });
    }
    
    // ===== MESSAGE SENDING =====
    async function sendMessage() {
      const text = elements.messageBar.value.trim();
      if (!text) return;
      
      // Send typing stop signal
      if (state.typingTimeout) {
        clearTimeout(state.typingTimeout);
        state.typingTimeout = null;
      }
      
      try {
        const messageData = {
          group_id: gid,
          sender_id: user.id,
          sender_name: user.user_metadata.firstName || user.user_metadata.full_name || 'You',
          content: text,
          reply_to: state.replyingMsg?.id,
          reply_to_sender: state.replyingMsg?.sender_name,
          reply_to_text: state.replyingMsg?.content
        };
        
        const { data, error } = await supabase
          .from('group_messages')
          .insert([messageData])
          .select()
          .single();
        
        if (error) throw error;
        
        // Render the message immediately
        render(data);
        
        // Clear input and reset state
        elements.messageBar.value = '';
        elements.messageBar.style.height = 'auto';
        elements.sendMessageButton.disabled = true;
        
        // Clear reply context
        if (state.replyingMsg) {
          state.replyingMsg = null;
          elements.replyContextBox.style.display = 'none';
        }
        
        // Check for AI trigger
        const hasAIMention = text.toLowerCase().includes('@peerpal ai');
        const hasAIKeywords = hasAIKeywordsInText(text);
        if (hasAIMention || hasAIKeywords) {
          setTimeout(() => checkPeerloomAI(text), 1000);
        }
        
      } catch (error) {
        console.error('Error sending message:', error);
        showError('Failed to send message');
      }
    }
    
    function hasAIKeywordsInText(text) {
      if (!text) return false;
      const aiKeywords = [
        'peerpal', 'ai', 'assistant', 'bot', 'help', 'question',
        'how to', 'what is', 'can you', 'could you', 'please help',
        'explain', 'tell me', 'show me', 'advice', 'suggestion'
      ];
      return aiKeywords.some(keyword => text.toLowerCase().includes(keyword.toLowerCase()));
    }
    
    // ===== TYPING INDICATORS =====
    const typingChannel = supabase.channel('typing-indicators', {
      config: { broadcast: { self: false } }
    });
    
    typingChannel
      .on('broadcast', { event: 'typing' }, (payload) => {
        const { user_id, isTyping, user_name } = payload.payload;
        
        if (user_id !== user.id) {
          if (isTyping) {
            state.typingUsers.set(user_id, { id: user_id, name: user_name });
          } else {
            state.typingUsers.delete(user_id);
          }
          renderTypingIndicators();
        }
      })
      .subscribe();
    
    elements.messageBar.addEventListener('input', () => {
      if (state.typingTimeout) clearTimeout(state.typingTimeout);
      
      typingChannel.send({
        type: 'broadcast',
        event: 'typing',
        payload: {
          user_id: user.id,
          isTyping: true,
          user_name: user.user_metadata.firstName || user.user_metadata.full_name || 'You'
        }
      });
      
      state.typingTimeout = setTimeout(() => {
        typingChannel.send({
          type: 'broadcast',
          event: 'typing',
          payload: {
            user_id: user.id,
            isTyping: false,
            user_name: user.user_metadata.firstName || user.user_metadata.full_name || 'You'
          }
        });
      }, 1000);
    });
    
    function renderTypingIndicators() {
      // Remove existing typing indicators (except AI)
      document.querySelectorAll('.typing-indicator').forEach(el => {
        if (!el.classList.contains('ai')) el.remove();
      });
      
      // Add new typing indicators
      state.typingUsers.forEach(typingUser => {
        const typingDiv = document.createElement('div');
        typingDiv.className = 'typing-indicator';
        typingDiv.id = `typing-${typingUser.id}`;
        typingDiv.innerHTML = `
          <div class="sender-name">${typingUser.name}</div>
          <div class="typing-dots">
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
            <div class="typing-dot"></div>
          </div>
        `;
        elements.messagePanel.appendChild(typingDiv);
      });
      
      elements.messagePanel.scrollTop = elements.messagePanel.scrollHeight;
    }
    
    // ===== AI INTEGRATION =====
    async function checkPeerloomAI(message) {
      try {
        // Show typing indicator
        showAITypingIndicator();
        
        // Clean the message
        const cleanMessage = message.replace(/@peerpal ai/gi, '').trim();
        
        let aiReply = "I'm here to help! How can I assist you today?";
        
        // Simulate typing delay
        await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));
        
        try {
          // Try gemini-2.0-flash first, fall back to gemini-2.0-flash-lite if needed
          let response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              contents: [{
                parts: [{
                  text: `You are an assistant that ONLY responds when explicitly called.
Do not speak unless the user directly asks or mentions you.
Do not continue conversations unprompted.

User message:
${cleanMessage}`
                }]
              }],
              generationConfig: {
                temperature: 0.7,
                maxOutputTokens: 300,
                topP: 0.9,
              }
            })
          });
          
          // If the first model fails, try the second one
          if (!response.ok) {
            response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${GEMINI_API_KEY}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contents: [{
                  parts: [{
                    text: `You are an assistant that ONLY responds when explicitly called.
Do not speak unless the user directly asks or mentions you.
Do not continue conversations unprompted.

User message:
${cleanMessage}`
                  }]
                }],
                generationConfig: {
                  temperature: 0.7,
                  maxOutputTokens: 300,
                  topP: 0.9,
                }
              })
            });
          }
          
          if (response.ok) {
            const data = await response.json();
            if (data?.candidates?.[0]?.content?.parts?.[0]?.text) {
              aiReply = data.candidates[0].content.parts[0].text;
            }
          } else {
            console.log('Both AI models failed, using fallback response');
            aiReply = generateSmartStudyResponse(cleanMessage);
          }
        } catch (modelError) {
          console.log('AI model error:', modelError);
          aiReply = generateSmartStudyResponse(cleanMessage);
        }
        
        // Hide typing indicator
        hideAITypingIndicator();
        
        // Insert AI message
        const { data: aiMessage, error: aiError } = await supabase
          .from('group_messages')
          .insert({
            group_id: gid,
            sender_id: AI_USER_ID,
            sender_name: AI_USER_NAME,
            content: aiReply,
            role: 'ai'
          })
          .select()
          .single();
        
        if (aiError) {
          console.error('Error inserting AI message:', aiError);
          hideAITypingIndicator();
        }
        
      } catch (error) {
        console.error('PeerPal AI Error:', error);
        hideAITypingIndicator();
      }
    }
    
    function generateSmartStudyResponse(message) {
      const lowerMessage = message.toLowerCase();
      
      if (lowerMessage.includes('explain') || lowerMessage.includes('what is') || lowerMessage.includes('how does')) {
        return "I'd be happy to explain that! Could you provide more specific details about what you'd like me to break down?";
      }
      
      if (lowerMessage.includes('practice') || lowerMessage.includes('question') || lowerMessage.includes('quiz')) {
        return "Great! Let me generate some practice questions for you. What specific topic would you like to practice?";
      }
      
      if (lowerMessage.includes('summary') || lowerMessage.includes('summarize') || lowerMessage.includes('notes')) {
        return "I can help summarize your study materials! Please share the content you'd like me to summarize.";
      }
      
      const studyResponses = [
        "I'm here to help you learn! Feel free to ask me to explain concepts, generate practice questions, or help with exam prep.",
        "As your study buddy, I can break down complex topics or create practice exercises. What would you like to work on?",
        "Learning is more effective with support! I can assist with understanding difficult concepts or creating study guides.",
        "Education is a journey! I'm here to make it easier by explaining concepts clearly and supporting your study efforts."
      ];
      
      return studyResponses[Math.floor(Math.random() * studyResponses.length)];
    }
    
    function showAITypingIndicator() {
      hideAITypingIndicator();
      const typingDiv = document.createElement('div');
      typingDiv.className = 'typing-indicator ai';
      typingDiv.id = 'ai-typing-indicator';
      typingDiv.innerHTML = `
        <div class="sender-name">${AI_USER_NAME}</div>
        <div class="typing-dots">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
      `;
      elements.messagePanel.appendChild(typingDiv);
      elements.messagePanel.scrollTop = elements.messagePanel.scrollHeight;
    }
    
    function hideAITypingIndicator() {
      const typingIndicator = document.getElementById('ai-typing-indicator');
      if (typingIndicator) typingIndicator.remove();
    }
    
    // ===== REAL-TIME MESSAGES =====
    function setupRealtimeSubscriptions() {
      // Messages subscription
      const messageChannel = supabase.channel(`grp_${gid}`)
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'group_messages',
          filter: `group_id=eq.${gid}`
        }, async (payload) => {
          const existingMessage = document.querySelector(`.msg[data-id="${payload.new.id}"]`);
          if (existingMessage) return;
          
          if (payload.new.sender_id !== user.id) {
            hideAITypingIndicator();
            render(payload.new);
            
            // Check for AI response
            if (payload.new.reply_to) {
              const isReplyToAI = await checkIfReplyToAI(payload.new);
              if (isReplyToAI) {
                setTimeout(() => checkPeerloomAI(payload.new.content || 'Hello'), 1000);
              }
            } else if (payload.new.sender_id !== AI_USER_ID && payload.new.sender_id !== user.id) {
              checkForAIResponse(payload.new);
            }
            
            // Mark new incoming message as delivered and seen immediately
            markMessageAsDelivered(payload.new.id);
            markMessageAsSeen(payload.new.id);
          }
        })
        .on('postgres_changes', {
          event: 'UPDATE',
          schema: 'public',
          table: 'group_messages',
          filter: `group_id=eq.${gid}`
        }, (payload) => {
          // Update UI when a message is marked as seen (or edited)
          const msgEl = document.querySelector(`.msg[data-id="${payload.new.id}"]`);
          if (msgEl) {
            const ts = msgEl.querySelector('.timestamp');
            if (ts) {
              const mine = payload.new.sender_id === user.id;
              let statusHtml = '';
              if (mine) {
                let iconClass = 'fa-check';
                let statusClass = 'sent';
                if (payload.new.seen_at) {
                  iconClass = 'fa-check-double';
                  statusClass = 'seen';
                } else if (payload.new.delivered_at) {
                  iconClass = 'fa-check-double';
                  statusClass = 'delivered';
                }
                statusHtml = `<span class="seen-status ${statusClass}"><i class="fas ${iconClass}"></i></span>`;
              }
              ts.innerHTML = `${formatTime(payload.new.created_at)}${statusHtml}`;
            }
          }
        })
        .subscribe();
      
      // Members subscription
      const membersChannel = supabase.channel(`group-members:${gid}`)
        .on('postgres_changes', {
          event: '*',
          schema: 'public',
          table: 'group_members',
          filter: `group_id=eq.${gid}`
        }, async () => {
          await loadMembers();
        })
        .subscribe();
    }
    
    async function markMessageAsSeen(msgId) {
      await supabase.from('group_messages')
        .update({ seen_at: new Date().toISOString() })
        .eq('id', msgId);
    }
    
    async function checkIfReplyToAI(message) {
      try {
        const { data, error } = await supabase
          .from('group_messages')
          .select('sender_id')
          .eq('id', message.reply_to)
          .single();
        
        if (error) return false;
        return data && data.sender_id === AI_USER_ID;
      } catch (err) {
        console.log('Error checking reply:', err);
        return false;
      }
    }
    
    async function checkForAIResponse(message) {
      if (state.aiResponseInProgress) return;
      
      const messageText = message.content ? message.content.toLowerCase() : '';
      if (messageText.includes('@peerpal ai') || hasAIKeywordsInText(messageText)) {
        state.aiResponseInProgress = true;
        
        setTimeout(async () => {
          await checkPeerloomAI(message.content || 'Hello');
          setTimeout(() => { state.aiResponseInProgress = false; }, 2000);
        }, 1000);
      }
    }
    
    // ===== AUDIO RECORDING =====
    async function toggleRecording() {
      if (state.isRecording) {
        stopRecording();
      } else {
        await startRecording();
      }
    }
    
    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        state.mediaRecorder = new MediaRecorder(stream);
        state.audioChunks = [];
        state.recordingStart = Date.now();
        
        state.mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            state.audioChunks.push(event.data);
          }
        };
        
        state.mediaRecorder.onstop = async () => {
          const audioBlob = new Blob(state.audioChunks, { type: 'audio/webm' });
          await uploadAudioMessage(audioBlob);
          stream.getTracks().forEach(track => track.stop());
        };
        
        state.mediaRecorder.start();
        state.isRecording = true;
        
        // Update UI
        elements.recordAudioButton.classList.add('active');
        elements.recordingIndicator.classList.add('active');
        
        // Start recording timer
        state.recordingSeconds = 0;
        state.recordingTimer = setInterval(updateRecordingTime, 1000);
        
        // Stop recording when clicking indicator
        elements.recordingIndicator.onclick = stopRecording;
        
      } catch (error) {
        console.error('Error starting recording:', error);
        showError('Microphone access denied');
      }
    }
    
    function stopRecording() {
      if (state.mediaRecorder && state.isRecording) {
        state.mediaRecorder.stop();
        state.isRecording = false;
        
        // Update UI
        elements.recordAudioButton.classList.remove('active');
        elements.recordingIndicator.classList.remove('active');
        
        // Clear timer
        clearInterval(state.recordingTimer);
        elements.recordingTime.textContent = '00:00';
      }
    }
    
    function updateRecordingTime() {
      if (!state.isRecording) return;
      
      state.recordingSeconds++;
      const minutes = Math.floor(state.recordingSeconds / 60);
      const seconds = state.recordingSeconds % 60;
      elements.recordingTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    async function uploadAudioMessage(audioBlob) {
      try {
        const fileName = `audio_${Date.now()}_${user.id}.webm`;
        const { data, error } = await supabase.storage
          .from('group_audios')
          .upload(fileName, audioBlob);
        
        if (error) throw error;
        
        const { data: { publicUrl } } = supabase.storage
          .from('group_audios')
          .getPublicUrl(fileName);
        
        const { data: messageData, error: messageError } = await supabase
          .from('group_messages')
          .insert({
            group_id: gid,
            sender_id: user.id,
            sender_name: user.user_metadata.firstName,
            content: 'Audio message',
            message_type: 'audio',
            audio_url: publicUrl,
            reply_to: state.replyingMsg?.id,
            reply_to_sender: state.replyingMsg?.sender_name,
            reply_to_text: state.replyingMsg?.content
          })
          .select()
          .single();
        
        if (messageError) throw messageError;
        
        // Render the audio message immediately
        render(messageData);
        
        // Clear reply context
        state.replyingMsg = null;
        elements.replyContextBox.style.display = 'none';
        
      } catch (error) {
        console.error('Error uploading audio:', error);
        showError('Failed to send audio message');
      }
    }
    
    // ===== FILE UPLOAD =====
    async function handleFileUpload(file) {
      if (!file) return;
      
      // Create placeholder message
      const { data: placeholderMessage, error: placeholderError } = await supabase
        .from('group_messages')
        .insert({
          group_id: gid,
          sender_id: user.id,
          sender_name: user.user_metadata.firstName,
          content: 'Uploading...',
          message_type: 'uploading',
          file_name: file.name,
          file_size: file.size
        })
        .select()
        .single();
      
      if (placeholderError) {
        console.error('Error creating placeholder:', placeholderError);
        showError('Failed to start upload');
        return;
      }
      
      render(placeholderMessage);
      
      try {
        const fileType = file.type.split('/')[0];
        let messageType = (fileType === 'image' || fileType === 'video') ? fileType : 'file';
        
        const fileExt = file.name.split('.').pop();
        const fileName = `${user.id}-${Date.now()}.${fileExt}`;
        const filePath = `group_files/${gid}/${fileName}`;
        
        // Upload with progress
        const { data: uploadData, error: uploadError } = await supabase.storage
          .from('group_files')
          .upload(filePath, file, {
            cacheControl: '3600',
            upsert: false
          }, (event) => {
            if (event.type === 'progress') {
              const percent = Math.round((event.loaded / event.total) * 100);
              const progressBar = document.getElementById(`progress-${placeholderMessage.id}`);
              const progressText = document.getElementById(`progress-text-${placeholderMessage.id}`);
              if (progressBar) progressBar.style.width = `${percent}%`;
              if (progressText) progressText.textContent = `${percent}%`;
            }
          });
        
        if (uploadError) throw uploadError;
        
        // Get public URL
        const { data: { publicUrl } } = supabase.storage
          .from('group_files')
          .getPublicUrl(filePath);
        
        // Update placeholder
        const { error: updateError } = await supabase
          .from('group_messages')
          .update({
            content: publicUrl,
            message_type: messageType
          })
          .eq('id', placeholderMessage.id);
        
        if (updateError) throw updateError;
        
        // Refresh messages
        await loadHistory();
        
      } catch (error) {
        console.error('Error uploading file:', error);
        showError('Failed to upload file');
        
        // Delete placeholder on error
        await supabase
          .from('group_messages')
          .delete()
          .eq('id', placeholderMessage.id);
        
        document.querySelector(`.msg[data-id="${placeholderMessage.id}"]`)?.remove();
      }
    }
    
    // ===== GROUP DRAWER =====
    function renderMembersInDrawer() {
      elements.membersList.innerHTML = '';
      
      // Add "Add Member" button for admins
      if (state.userRole !== 'member') {
        const addBtn = document.createElement('button');
        addBtn.className = 'member-item';
        addBtn.style.cursor = 'pointer';
        addBtn.innerHTML = `
          <div class="member-avatar" style="background: var(--ios-success);">
            <i class="fas fa-user-plus" style="color: white;"></i>
          </div>
          <div class="member-info">
            <div class="member-name">Add Member</div>
            <div class="member-role">Invite new members</div>
          </div>
        `;
        addBtn.onclick = showAddMemberPrompt;
        elements.membersList.appendChild(addBtn);
      }
      
      // Filter out AI user
      const humanMembers = state.memberDetails.filter(member => member.user_id !== AI_USER_ID);
      
      if (humanMembers.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'member-item';
        empty.innerHTML = `<div class="member-name">No members found</div>`;
        elements.membersList.appendChild(empty);
        return;
      }
      
      humanMembers.forEach(member => {
        const displayName = getDisplayName(member);
        const role = member.role || 'member';
        const avatarUrl = member.profiles?.profile_photo || createDefaultAvatar(displayName);
        
        const item = document.createElement('div');
        item.className = 'member-item';
        item.innerHTML = `
          <img src="${avatarUrl}" class="member-avatar" alt="${displayName}">
          <div class="member-info">
            <div class="member-name">${displayName}</div>
            <div class="member-role">${role.charAt(0).toUpperCase() + role.slice(1)}</div>
          </div>
          <div class="member-status"></div>
        `;
        
        // Add admin actions
        if (state.userRole !== 'member' && member.user_id !== user.id) {
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'member-actions';
          
          const promoteBtn = document.createElement('button');
          promoteBtn.className = 'member-action promote';
          promoteBtn.innerHTML = '<i class="fas fa-star"></i>';
          promoteBtn.title = role === 'member' ? 'Promote to Admin' : 'Demote to Member';
          promoteBtn.onclick = async (e) => {
            e.stopPropagation();
            const newRole = role === 'member' ? 'admin' : 'member';
            const { error } = await supabase
              .from('group_members')
              .update({ role: newRole })
              .eq('group_id', gid)
              .eq('user_id', member.user_id);
            
            if (error) {
              showError('Error updating role: ' + error.message);
            } else {
              await loadMembers();
              renderMembersInDrawer();
            }
          };
          
          const removeBtn = document.createElement('button');
          removeBtn.className = 'member-action remove';
          removeBtn.innerHTML = '<i class="fas fa-times"></i>';
          removeBtn.title = 'Remove Member';
          removeBtn.onclick = async (e) => {
            e.stopPropagation();
            if (member.user_id === state.groupCreatorId) {
              showError('Cannot remove the group owner.');
              return;
            }
            
            if (confirm(`Remove ${displayName} from the group?`)) {
              const { error } = await supabase
                .from('group_members')
                .delete()
                .eq('group_id', gid)
                .eq('user_id', member.user_id);
              
              if (error) {
                showError('Error removing member: ' + error.message);
              } else {
                await loadMembers();
                renderMembersInDrawer();
              }
            }
          };
          
          actionsDiv.appendChild(promoteBtn);
          actionsDiv.appendChild(removeBtn);
          item.appendChild(actionsDiv);
        }
        
        elements.membersList.appendChild(item);
      });
    }
    
    function openDrawer() {
      renderMembersInDrawer();
      elements.groupDrawer.classList.add('open');
      elements.groupDrawer.setAttribute('aria-hidden', 'false');
      elements.drawerBackdrop.classList.add('visible');
    }
    
    function closeDrawer() {
      elements.groupDrawer.classList.remove('open');
      elements.groupDrawer.setAttribute('aria-hidden', 'true');
      elements.drawerBackdrop.classList.remove('visible');
    }
    
    async function showAddMemberPrompt() {
      const username = prompt('Enter exact username to add:');
      if (!username) return;
      
      try {
        const { data, error } = await supabase
          .from('profiles')
          .select('id, username, full_name')
          .eq('username', username.toLowerCase())
          .single();
        
        if (error && error.code !== 'PGRST116') {
          showError('Error searching user: ' + error.message);
          return;
        }
        
        if (!data) {
          showError('User not found.');
          return;
        }
        
        await addMember(data.id);
      } catch (err) {
        showError('Error: ' + err.message);
      }
    }
    
    async function addMember(userIdToAdd) {
      if (userIdToAdd === user.id) {
        showError('You are already a member.');
        return;
      }
      
      const existing = state.memberDetails.find(m => m.user_id === userIdToAdd);
      if (existing) {
        showError('User already in group.');
        return;
      }
      
      const { error } = await supabase
        .from('group_members')
        .insert({
          group_id: gid,
          user_id: userIdToAdd,
          role: 'member'
        });
      
      if (error) {
        showError('Error adding member: ' + error.message);
      } else {
        await loadMembers();
        renderMembersInDrawer();
        showSuccess('Member added successfully!');
      }
    }
    
    // ===== EVENT LISTENERS SETUP =====
    function setupEventListeners() {
      // Send message on Enter (without Shift)
      elements.messageBar.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      });
      
      // Send message on button click
      elements.sendMessageButton.addEventListener('click', sendMessage);
      
      // Update send button state
      elements.messageBar.addEventListener('input', () => {
        const hasText = elements.messageBar.value.trim().length > 0;
        elements.sendMessageButton.disabled = !hasText;
        elements.messageBar.style.height = 'auto';
        elements.messageBar.style.height = Math.min(elements.messageBar.scrollHeight, 120) + 'px';
      });
      
      // Emoji picker
      elements.emojiButton.addEventListener('click', (e) => {
        e.stopPropagation();
        elements.emojiPickerBox.style.display = elements.emojiPickerBox.style.display === 'flex' ? 'none' : 'flex';
        elements.mentionListBox.style.display = 'none';
      });
      
      // File upload
      elements.fileShareButton.addEventListener('click', () => {
        elements.fileInput.click();
      });
      
      elements.fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          state.stagedFile = file;
          showFilePreview(file);
        }
        e.target.value = '';
      });
      
      // Audio recording
      elements.recordAudioButton.addEventListener('click', toggleRecording);
      
      // Poll button
      elements.pollButton.addEventListener('click', () => {
        showPollModal();
      });
      
      // Group title click to open drawer
      elements.groupTitle.addEventListener('click', (e) => {
        e.stopPropagation();
        if (elements.groupDrawer.classList.contains('open')) {
          closeDrawer();
        } else {
          openDrawer();
        }
      });
      
      // Close drawer when clicking backdrop
      elements.drawerBackdrop.addEventListener('click', closeDrawer);
      
      // Close drawer with Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && elements.groupDrawer.classList.contains('open')) {
          closeDrawer();
        }
      });
      
      // Share group
      elements.shareGroupBtn.addEventListener('click', (e) => {
        createRipple(e);
        const groupUrl = `${window.location.origin}${window.location.pathname}?groupId=${gid}`;
        elements.shareGroupInput.value = groupUrl;
        elements.shareGroupModal.classList.add('visible');
        closeDrawer();
      });
      
      // Leave group
      elements.leaveGroupBtn.addEventListener('click', async (e) => {
        createRipple(e);
        if (confirm('Are you sure you want to leave this group?')) {
          try {
            await supabase
              .from('group_members')
              .delete()
              .eq('group_id', gid)
              .eq('user_id', user.id);
            
            closeDrawer();
            window.location.href = 'dashboard.html';
          } catch (error) {
            console.error('Error leaving group:', error);
            showError('Failed to leave group');
          }
        }
      });
      
      // Admin panel
      elements.adminPanelButton.addEventListener('click', () => {
        renderAdminPanel();
        elements.adminModal.classList.add('visible');
      });
      
      // Close admin panel
      elements.closeAdmin.addEventListener('click', () => {
        elements.adminModal.classList.remove('visible');
      });
      
      elements.adminModal.addEventListener('click', (e) => {
        if (e.target === elements.adminModal) {
          elements.adminModal.classList.remove('visible');
        }
      });
      
      // Voice and video calls (placeholder)
      elements.voiceCallButton.addEventListener('click', () => {
        showSuccess('Starting voice call...');
      });
      
      elements.videoCallButton.addEventListener('click', () => {
        window.location.href = `livemeeting.html?groupId=${gid}`;
      });
      
      // Modal close handlers
      elements.shareGroupCancel.addEventListener('click', () => {
        elements.shareGroupModal.classList.remove('visible');
      });
      
      elements.shareGroupCopy.addEventListener('click', () => {
        elements.shareGroupInput.select();
        document.execCommand('copy');
        elements.shareGroupCopy.textContent = 'Copied!';
        setTimeout(() => {
          elements.shareGroupCopy.textContent = 'Copy Link';
        }, 2000);
      });
      
      elements.shareGroupModal.addEventListener('click', (e) => {
        if (e.target === elements.shareGroupModal) {
          elements.shareGroupModal.classList.remove('visible');
        }
      });
      
      // Edit message modal
      elements.editMessageCancel.addEventListener('click', closeModals);
      elements.editMessageConfirm.addEventListener('click', editMessage);
      
      // Delete message modal
      elements.deleteMessageCancel.addEventListener('click', closeModals);
      elements.deleteMessageConfirm.addEventListener('click', deleteMessage);
      
      // File preview modal
      elements.filePreviewCancel.addEventListener('click', () => {
        elements.filePreviewModal.classList.remove('visible');
        state.stagedFile = null;
      });
      
      elements.filePreviewSend.addEventListener('click', () => {
        if (state.stagedFile) {
          handleFileUpload(state.stagedFile);
        }
        elements.filePreviewModal.classList.remove('visible');
        state.stagedFile = null;
      });
      
      // Delete group modal
      elements.cancelDeleteGroup.addEventListener('click', () => {
        elements.deleteGroupModal.classList.remove('visible');
      });
      
      elements.confirmDeleteGroup.addEventListener('click', async () => {
        if (confirm('Are you absolutely sure? This will delete the entire group, all messages, and all member data. This cannot be undone.')) {
          try {
            // Delete all messages
            await supabase
              .from('group_messages')
              .delete()
              .eq('group_id', gid);
            
            // Delete all members
            await supabase
              .from('group_members')
              .delete()
              .eq('group_id', gid);
            
            // Delete the group
            await supabase
              .from('groups')
              .delete()
              .eq('id', gid);
            
            showSuccess('Group deleted successfully.');
            window.location.href = 'dashboard.html';
            
          } catch (error) {
            console.error('Error deleting group:', error);
            showError('Failed to delete group: ' + error.message);
            elements.deleteGroupModal.classList.remove('visible');
          }
        }
      });
      
      // Lightbox
      elements.lightboxClose.addEventListener('click', closeLightbox);
      elements.lightbox.addEventListener('click', (e) => {
        if (e.target === elements.lightbox) closeLightbox();
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && elements.lightbox.classList.contains('visible')) {
          closeLightbox();
        }
      });
      
      // Reply context close
      elements.replyContextClose.addEventListener('click', () => {
        state.replyingMsg = null;
        elements.replyContextBox.style.display = 'none';
      });
      
      // Close emoji picker when clicking outside
      document.addEventListener('click', (e) => {
        if (!elements.emojiButton.contains(e.target) && !elements.emojiPickerBox.contains(e.target)) {
          elements.emojiPickerBox.style.display = 'none';
        }
      });
    }
    
    // ===== MESSAGE GESTURES =====
    function attachGestures(el, mine, msg) {
      if (msg.message_type === 'audio') return;
      
      let startX, startY, isSwiping = false;
      let longTapTimer;
      let lastTapTime = 0;
      
      const handleStart = (x, y) => {
        startX = x;
        startY = y;
        isSwiping = false;
        
        if (mine || state.userRole !== 'member') {
          longTapTimer = setTimeout(() => {
            showDeleteMessageModal(msg.id);
          }, 500);
        }
      };
      
      const handleMove = (x, y) => {
        const deltaX = x - startX;
        const deltaY = Math.abs(y - startY);
        
        if (Math.abs(deltaX) > 10) {
          clearTimeout(longTapTimer);
        }
        
        if (deltaX > 15 && deltaY < 50 && !isSwiping) {
          isSwiping = true;
          el.classList.add('swiping');
        }
        
        if (isSwiping) {
          const swipeProgress = Math.min(deltaX / 100, 1);
          const translateX = -60 * swipeProgress;
          el.style.transform = `translateX(${translateX}px)`;
          
          if (deltaX > 100) {
            startReply(msg);
            resetSwipe(el);
          }
        }
      };
      
      const handleEnd = () => {
        clearTimeout(longTapTimer);
        
        if (isSwiping) {
          el.style.transition = 'transform 0.3s ease';
          el.style.transform = 'translateX(0)';
          
          setTimeout(() => {
            resetSwipe(el);
          }, 300);
        }
        
        isSwiping = false;
      };
      
      const handleTap = () => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTapTime;
        
        if (tapLength < 300 && mine) {
          showEditMessageModal(msg.id, msg.content);
        }
        
        lastTapTime = currentTime;
      };
      
      const resetSwipe = (element) => {
        element.classList.remove('swiping');
        element.style.transform = '';
        element.style.transition = '';
      };
      
      // Mouse events
      el.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        handleStart(e.clientX, e.clientY);
        
        const handleMouseMove = (e) => {
          if (isSwiping || Math.abs(e.clientX - startX) > 10) {
            handleMove(e.clientX, e.clientY);
          }
        };
        
        const handleMouseUp = () => {
          handleEnd();
          document.removeEventListener('mousemove', handleMouseMove);
          document.removeEventListener('mouseup', handleMouseUp);
        };
        
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
      });
      
      // Touch events
      el.addEventListener('touchstart', (e) => {
        handleStart(e.touches[0].clientX, e.touches[0].clientY);
      });
      
      el.addEventListener('touchmove', (e) => {
        if (isSwiping || Math.abs(e.touches[0].clientX - startX) > 10) {
          handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }
      });
      
      el.addEventListener('touchend', handleEnd);
      
      // Tap for edit
      el.addEventListener('click', handleTap);
    }
    
    function startReply(msg) {
      state.replyingMsg = msg;
      elements.replyContextSender.textContent = msg.sender_name;
      elements.replyContextText.textContent = msg.content;
      elements.replyContextBox.style.display = 'flex';
    }
    
    // ===== MODAL FUNCTIONS =====
    function showFilePreview(file) {
      let previewHtml = '';
      const fileType = file.type.split('/')[0];
      
      if (fileType === 'image') {
        previewHtml = `<img src="${URL.createObjectURL(file)}" style="max-height: 200px; border-radius: 8px;">`;
      } else if (fileType === 'video') {
        previewHtml = `<video src="${URL.createObjectURL(file)}" controls style="max-height: 200px; border-radius: 8px;"></video>`;
      } else {
        previewHtml = `
          <div class="file-attachment-card" style="background: var(--input-bg);">
            <div class="file-icon-wrapper"><i class="fas fa-file-alt"></i></div>
            <div class="file-info">
              <div class="file-name">${file.name}</div>
              <div class="file-meta">${formatFileSize(file.size)}</div>
            </div>
          </div>
        `;
      }
      
      elements.filePreviewContent.innerHTML = previewHtml;
      elements.filePreviewModal.classList.add('visible');
    }
    
    function showEditMessageModal(messageId, currentContent) {
      state.editingMessage = messageId;
      elements.editMessageInput.value = currentContent;
      elements.editMessageModal.classList.add('visible');
      elements.editMessageInput.focus();
    }
    
    function showDeleteMessageModal(messageId) {
      state.deletingMessage = messageId;
      elements.deleteMessageModal.classList.add('visible');
    }
    
    function closeModals() {
      elements.editMessageModal.classList.remove('visible');
      elements.deleteMessageModal.classList.remove('visible');
      elements.shareGroupModal.classList.remove('visible');
      state.editingMessage = null;
      state.deletingMessage = null;
    }
    async function editMessage() {
      if (!state.editingMessage) return;
      const newContent = elements.editMessageInput.value.trim();
      
      if (newContent) {
        try {
          const { error } = await supabase
            .from('group_messages')
            .update({ content: newContent })
            .eq('id', state.editingMessage)
            .eq('sender_id', user.id);
          
          if (error) throw error;
          await loadHistory();
        } catch (error) {
          showError('Error updating message: ' + error.message);
        }
      }
      
      closeModals();
    }
    
    async function deleteMessage() {
      if (!state.deletingMessage) return;
      
      try {
        let query = supabase
          .from('group_messages')
          .delete()
          .eq('id', state.deletingMessage);
        
        if (state.userRole === 'member') {
          query = query.eq('sender_id', user.id);
        }
        
        const { error } = await query;
        if (error) throw error;
        
        await loadHistory();
      } catch (error) {
        showError('Error deleting message: ' + error.message);
      }
      
      closeModals();
    }
    
    // ===== ADMIN PANEL =====
    function renderAdminPanel() {
      let actionsHtml = `
        <button class="admin-action" data-action="members"><i class="fas fa-users"></i> 1. Add or Remove Members</button>
        <button class="admin-action" data-action="promote"><i class="fas fa-star"></i> 2. Promote or Demote Admins</button>
        <button class="admin-action" data-action="join"><i class="fas fa-check"></i> 3. Approve Join Requests</button>
        <button class="admin-action" data-action="editgroup"><i class="fas fa-edit"></i> 4. Edit Group Name & Description</button>
        <button class="admin-action" data-action="pin"><i class="fas fa-thumbtack"></i> 5. Pin or Unpin Messages</button>
        <button class="admin-action" data-action="mute"><i class="fas fa-volume-mute"></i> 6. Mute Members</button>
        <button class="admin-action" data-action="deleteMsg"><i class="fas fa-trash"></i> 7. Delete Messages for Everyone</button>
        <button class="admin-action" data-action="freeze"><i class="fas fa-pause"></i> 8. Freeze or Unfreeze Chat</button>
        <button class="admin-action" data-action="warn"><i class="fas fa-exclamation-triangle"></i> 9. Warn or Suspend Members</button>
        <button class="admin-action" data-action="log"><i class="fas fa-history"></i> 10. View Group Activity Log</button>
        <button class="admin-action" data-action="everyone"><i class="fas fa-at"></i> 11. Use @Everyone Mention</button>
        <button class="admin-action" data-action="broadcast"><i class="fas fa-bullhorn"></i> 12. Send Broadcast Announcements</button>
        <button class="admin-action" data-action="poll"><i class="fas fa-poll"></i> 13. Create and Manage Polls</button>
        <button class="admin-action" data-action="schedule"><i class="fas fa-clock"></i> 14. Schedule Messages</button>
        <button class="admin-action" data-action="rules"><i class="fas fa-rules"></i> 15. Keep Group Rules Visible</button>
        <button class="admin-action" data-action="privacy"><i class="fas fa-lock"></i> 16. Set Group Privacy</button>
        <button class="admin-action" data-action="media"><i class="fas fa-image"></i> 17. Restrict Media Types</button>
        <button class="admin-action" data-action="frequency"><i class="fas fa-stopwatch"></i> 18. Limit Message Frequency</button>
        <button class="admin-action" data-action="categories"><i class="fas fa-tag"></i> 19. Add Group Categories</button>
        <button class="admin-action" data-action="reset"><i class="fas fa-refresh"></i> 20. Reset Chat History</button>
        <button class="admin-action" data-action="stats"><i class="fas fa-chart-bar"></i> 21. View Statistics</button>
        <button class="admin-action" data-action="reports"><i class="fas fa-flag"></i> 22. View User Reports</button>
        <button class="admin-action" data-action="code"><i class="fas fa-qrcode"></i> 23. Create Group Invite Code</button>
        <button class="admin-action" data-action="welcome"><i class="fas fa-comment-dots"></i> 24. Set Welcome Message</button>
        <button class="admin-action" data-action="export"><i class="fas fa-download"></i> 25. Export Chat</button>
        <button class="admin-action" data-action="levels"><i class="fas fa-layer-group"></i> 26. Multiple Admin Levels</button>
        <button class="admin-action" data-action="reactions"><i class="fas fa-thumbs-up"></i> 27. Enable Emoji Reactions</button>
        <button class="admin-action" data-action="roles"><i class="fas fa-user-tag"></i> 28. Assign Member Roles</button>
        <button class="admin-action" data-action="pollhistory"><i class="fas fa-history"></i> 29. View Poll History</button>
        <button class="admin-action" data-action="approvejoin"><i class="fas fa-user-plus"></i> 30. Approve Join Notifications</button>
      `;
      
      if (state.userRole === 'owner') {
        actionsHtml += `
          <button class="admin-action" data-action="deletegroup" style="background: rgba(var(--ios-danger-rgb), 0.1); color: var(--ios-danger); border-color: rgba(var(--ios-danger-rgb), 0.3);">
            <i class="fas fa-trash-alt"></i> Delete Group (Owner Only)
          </button>
        `;
      }
      
      elements.adminActions.innerHTML = actionsHtml;
      
      // Add event listeners to admin actions
      elements.adminActions.querySelectorAll('.admin-action').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const action = e.currentTarget.dataset.action;
          handleAdminAction(action);
        });
      });
    }
    
    async function handleAdminAction(action) {
      switch (action) {
        case 'members':
        case 'promote':
          openDrawer();
          elements.adminModal.classList.remove('visible');
          break;
          
        case 'editgroup':
          showEditGroupModal();
          break;
          
        case 'poll':
          showPollModal();
          break;
          
        case 'privacy':
          showPrivacyModal();
          break;
          
        case 'deletegroup':
          elements.deleteGroupModal.classList.add('visible');
          elements.adminModal.classList.remove('visible');
          break;
          
        case 'reset':
          if (confirm('Clear all chat history? This cannot be undone.')) {
            try {
              await supabase
                .from('group_messages')
                .delete()
                .eq('group_id', gid);
              
              await loadHistory();
              showSuccess('Chat history cleared.');
            } catch (error) {
              showError('Error clearing history: ' + error.message);
            }
          }
          elements.adminModal.classList.remove('visible');
          break;
          
        case 'everyone':
          elements.messageBar.value += '@everyone ';
          elements.messageBar.focus();
          elements.adminModal.classList.remove('visible');
          break;
          
        case 'broadcast':
          const broadcastMsg = prompt('Enter broadcast announcement:');
          if (broadcastMsg) {
            elements.messageBar.value = `[ANNOUNCEMENT] ${broadcastMsg}`;
            sendMessage();
          }
          elements.adminModal.classList.remove('visible');
          break;
          
        case 'export':
          exportChat();
          break;
          
        default:
          showSuccess(`Feature "${action}" is functional with the new schema.`);
          elements.adminModal.classList.remove('visible');
      }
    }
    
    function showEditGroupModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-backdrop visible';
      modal.style.zIndex = '2500';
      modal.innerHTML = `
        <div class="modal-content">
          <div class="modal-header">
            <div class="modal-title">Edit Group Info</div>
            <div class="modal-description">Update name and description</div>
          </div>
          <input type="text" class="modal-input" id="newName" value="${state.groupInfo.name}" placeholder="Group Name">
          <textarea class="modal-input" id="newDesc" rows="3" placeholder="Description">${state.groupInfo.description || ''}</textarea>
          <div class="modal-actions">
            <button class="modal-btn cancel" onclick="this.closest('.modal-backdrop').remove()">Cancel</button>
            <button class="modal-btn confirm" onclick="updateGroup(this)">Update</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }
    
    window.updateGroup = async function(btn) {
      const name = document.getElementById('newName').value.trim();
      const desc = document.getElementById('newDesc').value.trim();
      
      if (!name) {
        showError('Name is required');
        return;
      }
      
      try {
        const { error } = await supabase
          .from('groups')
          .update({ name, description: desc })
          .eq('id', gid);
        
        if (error) throw error;
        
        showSuccess('Group updated!');
        location.reload();
      } catch (error) {
        showError('Error: ' + error.message);
      }
      
      btn.closest('.modal-backdrop').remove();
    };
    
    function showPollModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-backdrop visible';
      modal.style.zIndex = '2500';
      modal.innerHTML = `
        <div class="modal-content">
          <div class="modal-header">
            <div class="modal-title">Create Poll</div>
            <div class="modal-description">Enter question and options</div>
          </div>
          <input type="text" class="modal-input" id="pollQuestion" placeholder="Poll Question">
          <div id="pollOptionsContainer" style="margin-bottom: 1rem;">
            <input type="text" class="modal-input poll-option-input" placeholder="Option 1" style="margin-bottom: 0.5rem;">
            <input type="text" class="modal-input poll-option-input" placeholder="Option 2" style="margin-bottom: 0.5rem;">
          </div>
          <button class="modal-btn" id="addPollOption" style="background: rgba(52, 199, 89, 0.2); color: var(--ios-success); margin-bottom: 1rem;">
            <i class="fas fa-plus"></i> Add Option
          </button>
          <div class="modal-actions">
            <button class="modal-btn cancel" onclick="this.closest('.modal-backdrop').remove()">Cancel</button>
            <button class="modal-btn confirm" onclick="createPoll(this)">Create Poll</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      document.getElementById('addPollOption').onclick = () => {
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'modal-input poll-option-input';
        input.placeholder = `Option ${document.querySelectorAll('.poll-option-input').length + 1}`;
        input.style.marginBottom = '0.5rem';
        document.getElementById('pollOptionsContainer').appendChild(input);
      };
    }
    
    window.createPoll = async function(btn) {
      const question = document.getElementById('pollQuestion').value.trim();
      if (!question) {
        showError('Question required');
        return;
      }
      
      const optionsInputs = document.querySelectorAll('.poll-option-input');
      const options = Array.from(optionsInputs)
        .map(input => input.value.trim())
        .filter(val => val);
      
      if (options.length < 2) {
        showError('At least 2 options required');
        return;
      }
      
      try {
        const { data: pollData, error: pollError } = await supabase
          .from('group_polls')
          .insert({
            group_id: gid,
            created_by: user.id,
            question: question,
            options: options
          })
          .select()
          .single();
        
        if (pollError) throw pollError;
        
        const { data: pollMsg, error: msgError } = await supabase
          .from('group_messages')
          .insert({
            group_id: gid,
            sender_id: user.id,
            sender_name: user.user_metadata.firstName,
            content: pollData.id,
            message_type: 'poll'
          })
          .select()
          .single();
        
        if (msgError) throw msgError;
        render(pollMsg);
        
        showSuccess('Poll created!');
      } catch (error) {
        showError('Error creating poll: ' + error.message);
        return;
      }
      
      btn.closest('.modal-backdrop').remove();
    };
    
    function showPrivacyModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-backdrop visible';
      modal.style.zIndex = '2500';
      
      const publicChecked = state.isPublic ? 'checked' : '';
      const privateChecked = !state.isPublic ? 'checked' : '';
      
      modal.innerHTML = `
        <div class="modal-content">
          <div class="modal-header">
            <div class="modal-title">Set Group Privacy</div>
          </div>
          <label style="display: block; margin-bottom: 1rem;">
            <input type="radio" name="privacy" value="true" ${publicChecked}> Public (Anyone can join)
          </label>
          <label style="display: block;">
            <input type="radio" name="privacy" value="false" ${privateChecked}> Private (Invite-only)
          </label>
          <div class="modal-actions">
            <button class="modal-btn cancel" onclick="this.closest('.modal-backdrop').remove()">Cancel</button>
            <button class="modal-btn confirm" onclick="updatePrivacy(this)">Save</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }
    
    window.updatePrivacy = async function(btn) {
      const privacyVal = document.querySelector('input[name="privacy"]:checked').value;
      const isPublicNew = privacyVal === 'true';
      
      try {
        const { error } = await supabase
          .from('groups')
          .update({ is_public: isPublicNew })
          .eq('id', gid);
        
        if (error) throw error;
        
        showSuccess('Privacy updated!');
        location.reload();
      } catch (error) {
        showError('Error: ' + error.message);
      }
      
      btn.closest('.modal-backdrop').remove();
    };
    
    async function exportChat() {
      try {
        const { data: messages, error } = await supabase
          .from('group_messages')
          .select('*')
          .eq('group_id', gid)
          .order('created_at');
        
        if (error) throw error;
        
        let content = messages.map(m => {
          const sender = m.sender_name || 'Unknown';
          const time = new Date(m.created_at).toLocaleString();
          return `[${time}] ${sender}: ${m.content}`;
        }).join('\n');
        
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${state.groupInfo.name || 'chat'}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showSuccess('Chat exported as TXT.');
      } catch (error) {
        showError('Error exporting chat.');
      }
      
      elements.adminModal.classList.remove('visible');
    }
    
    // ===== LIGHTBOX =====
    window.openLightbox = function(src, type) {
      if (type === 'image') {
        elements.lightboxContent.innerHTML = `<img src="${src}" alt="Lightbox image">`;
      } else if (type === 'video') {
        elements.lightboxContent.innerHTML = `<video src="${src}" controls autoplay></video>`;
      }
      elements.lightbox.classList.add('visible');
    };
    
    function closeLightbox() {
      elements.lightbox.classList.remove('visible');
      elements.lightboxContent.innerHTML = '';
    }
    
    // ===== NOTIFICATION FUNCTIONS =====
    function showError(message) {
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--ios-danger);
        color: white;
        padding: var(--space-md) var(--space-lg);
        border-radius: var(--radius-full);
        z-index: 10000;
        box-shadow: var(--shadow-3);
        animation: slideUp 0.3s ease;
        backdrop-filter: blur(10px);
      `;
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }
    
    function showSuccess(message) {
      const toast = document.createElement('div');
      toast.textContent = message;
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--ios-success);
        color: white;
        padding: var(--space-md) var(--space-lg);
        border-radius: var(--radius-full);
        z-index: 10000;
        box-shadow: var(--shadow-3);
        animation: slideUp 0.3s ease;
        backdrop-filter: blur(10px);
      `;
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }
    
    // ===== MAKE FUNCTIONS GLOBALLY AVAILABLE =====
    window.downloadWithAnimation = downloadWithAnimation;
    window.formatFileSize = formatFileSize;
    
    // ===== INITIALIZE APP =====
    initialize();
  </script>
</body>
</html>
