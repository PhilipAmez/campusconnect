<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skrolz - Video Feed</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="feed.css">
</head>
<body>
    <!-- Static Top Bar Container -->
    <div class="top-bar" id="staticTopBar">
        <!-- Top bar content will be rendered here by JavaScript -->
    </div>
    <div class="feed-container" id="feed">
        <!-- Pull to Refresh Indicator -->
        <div class="pull-to-refresh" id="pullToRefresh">
            <svg width="50" height="120" viewbox="0 0 50 120">
                <path class="liquid-path" id="liquidPath" d="M 25, 20 C 25, 20 25, 20 25, 20 Z"></path>
            </svg>
            <div class="liquid-container" id="liquidContainer">
                <div class="pull-to-refresh-icon" id="pullToRefreshIcon">
                    <i class="fas fa-arrow-down"></i>
                </div>
                <div class="pull-to-refresh-spinner liquid-spinner" id="pullToRefreshSpinner" style="display: none;">
                    <!-- Spinner is now a div for custom styling -->
                </div>
            </div>
        </div>
        <!-- Videos will be dynamically inserted here -->
    </div>
    <!-- Toast Notification -->
    <div class="toast" id="toast"></div>
    <!-- Search Overlay -->
    <div class="search-overlay" id="searchOverlay">
        <div class="search-header">
            <input type="text" class="search-input" id="searchInput" placeholder="Search...">
            <button class="close-search" id="closeSearch">√ó</button>
        </div>
        <div class="search-options" id="searchSortOptions">
            <span class="sort-option active" data-sort="relevance">Relevance</span>
            <span class="sort-option" data-sort="likes">Most Liked</span>
            <span class="sort-option" data-sort="recent">Most Recent</span>
        </div>
        <div class="search-results" id="searchResults">
            <!-- Search results will be populated here -->
        </div>
    </div>
    <!-- Upload Modal - Redesigned -->
    <div class="upload-modal" id="uploadModal">
        <div class="upload-content">
            <button class="close-modal-btn" onclick="hideUploadForm()">&times;</button>
            <h2 class="upload-title">Create New Post</h2>
            <div class="upload-options" id="uploadOptions">
                <div class="upload-option" onclick="showUploadForm('camera')">
                    <div class="upload-option-icon">üì∑</div>
                    <div>Record Video</div>
                </div>
                <div class="upload-option" onclick="showUploadForm('upload')">
                    <div class="upload-option-icon">üìÅ</div>
                    <div>Upload Video</div>
                </div>
            </div>
            <div class="upload-form" id="uploadForm">
                <div class="form-group">
                    <label class="form-label" for="postTitle">Title *</label>
                    <input type="text" class="form-input" id="postTitle" placeholder="Enter post title">
                </div>
                <div class="form-group">
                    <label class="form-label" for="postCaption">Caption</label>
                    <textarea class="form-textarea" id="postCaption" placeholder="Enter post caption (optional)"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label" for="postHashtags">Hashtags</label>
                    <input type="text" class="form-input" id="postHashtags" placeholder="#example #tags">
                </div>
              
                <!-- Upload Gallery Button - Redesigned -->
                <div class="form-group" id="uploadGallerySection" style="display: none;">
                    <label class="form-label">Video</label>
                    <div class="upload-gallery-btn" id="uploadGalleryBtn">
                        <span class="upload-icon">üìÅ</span>
                        <span>Upload from Gallery</span>
                        <input type="file" class="file-input" id="videoFile" accept="video/mp4,video/webm,video/ogg,video/quicktime">
                    </div>
                </div>
              
                <!-- Camera Recording Section -->
                <div class="camera-container" id="cameraContainer">
                    <video class="camera-preview" id="cameraPreview" autoplay muted playsinline></video>
                </div>
                <div class="recording-controls" id="recordingControls">
                    <button class="record-btn" id="recordBtn">‚óè</button>
                </div>
              
                <!-- Video Preview - Redesigned -->
                <div class="video-preview-container" id="videoPreviewContainer">
                    <button class="video-preview-close-btn" id="videoPreviewCloseBtn" title="Remove video">√ó</button>
                    <video class="video-preview" id="videoPreview" controls playsinline></video>
                    <div class="video-info-preview">
                        <div class="video-filename">
                            <span class="checkmark">‚úì</span>
                            <span id="videoFilename">Video Selected</span>
                        </div>
                        <div class="video-duration" id="videoDuration">0:00</div>
                    </div>
                </div>
              
                <div class="upload-actions">
                    <button class="upload-btn secondary" onclick="hideUploadForm()">Cancel</button>
                    <button class="upload-btn primary" id="uploadSubmitBtn" disabled>Upload Post</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Upload Progress Bar -->
    <div class="upload-progress" id="uploadProgress">
        <div class="progress-title">Uploading Video</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-status" id="progressStatus">Processing your video...</div>
    </div>
    <!-- Login Redirect Overlay -->
    <div class="login-redirect" id="loginRedirect">
        <div class="login-redirect-content">
            <h2 class="login-redirect-title">Sign up or log in to engage with students worldwide on Skrolz.</h2>
            <div class="login-redirect-buttons">
                <button class="login-redirect-button" id="signUpButton">Sign Up</button>
                <button class="login-redirect-button" id="logInButton">Log In</button>
            </div>
        </div>
    </div>
    <!-- Logout Confirmation Modal -->
    <!-- Settings Drawer -->
    <div class="settings-drawer" id="settingsDrawer">
        <div class="drawer-header">
            <h2 class="drawer-title">Settings</h2>
            <button class="close-drawer" id="closeDrawer">√ó</button>
        </div>
        <div class="drawer-content">
            <div class="settings-item" onclick="toggleTheme()">
                <span>Dark Mode</span>
                <i class="fas fa-moon"></i>
            </div>
            <a href="profile.html" id="editProfileLink" class="settings-item">
                <span>Edit Profile</span>
                <i class="fas fa-user-edit"></i>
            </a>
            <a href="changepassword.html" class="settings-item">
                <span>Change Password</span>
                <i class="fas fa-key"></i>
            </a>
             <div class="settings-item" onclick="logout()">
                <span style="color: var(--danger-color, #ff6b6b);">Log Out</span>
                <i class="fas fa-sign-out-alt" style="color: var(--danger-color, #ff6b6b);"></i>
            </div>
        </div>
    </div>
    <!-- Overlay -->
    <div class="overlay" id="overlay"></div>
    <div id="logoutModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeLogoutModal">&times;</span>
            <p>Are you sure you want to log out?</p>
            <div class="modal-buttons">
                <button class="btn-confirm" id="confirmLogout">Yes, Log Out</button>
                <button class="btn-cancel" id="cancelLogout">Cancel</button>
            </div>
        </div>
    </div>
    <!-- Mobile Bottom Navigation -->
    <div class="mobile-bottom-nav">
        <a href="dashboard.html">
            <i class="fas fa-home"></i>
            <span>Home</span>
        </a>
        <a href="feed.html" class="active">
            <i class="fas fa-scroll"></i>
            <span>Skrolz</span>
        </a>
        <button id="mobileAddPostBtn">
            <svg class="long-press-ring" viewBox="0 0 45 45">
                <circle class="long-press-circle" cx="22.5" cy="22.5" r="20"></circle>
            </svg>
            <i class="fas fa-plus-square"></i>
            <span>Post</span>
        </button>
        <a href="notifications.html" class="nav-icon">
            <i class="fas fa-bell"></i>
            <span class="notification-badge"></span>
            <span>Activity</span>
        </a>
        <a href="profile.html">
            <i class="fas fa-user"></i>
            <span>Profile</span>
        </a>
    </div>

    <!-- NEW: "Who Reacted" Modal -->
    <div id="whoReactedModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeWhoReactedModal">&times;</span>
            <h3 id="whoReactedModalTitle">Reactions</h3>
            <div class="reactions-list" id="whoReactedList">
                <!-- User reaction items will be populated here -->
            </div>
        </div>
    </div>
    <!-- Logout Confirmation Modal (from settings.html) -->
    <div id="logoutModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeLogoutModal">&times;</span>
            <p>Are you sure you want to log out?</p>
            <div class="modal-buttons">
                <button class="btn-confirm" id="confirmLogout">Yes, Log Out</button>
                <button class="btn-cancel" id="cancelLogout">Cancel</button>
            </div>
        </div>
    </div>

    <script src="./js/feed.js"></script>
    <script type="module">
        
        // Import supabase client
        import { supabase } from './js/supabaseClient.js';
        
        // App state
        let currentTheme = 'dark';
        let currentVideoId = null;
        let savedPosts = [];
        let isLoggedIn = false; // Changed to false to test guest mode
        let replyingToCommentId = null;
        let selectedVideoFile = null;
        let selectedVideoDuration = null;
        let mediaStream = null;
        let isAddingComment = false; // Flag to prevent double submission
        let mediaRecorder = null;
        let recordedChunks = [];
        let currentFeedType = 'for-you'; // 'for-you' or 'saved'
        // 'for-you', 'following', or 'saved'
        let isRecording = false;
        let isCommentDrawerOpen = false; // Track if comment drawer is open

        let currentUserProfile = null; // To store the logged-in user's profile
        let trendingHashtagsSubscription = null; // To hold our realtime subscription
        let currentSearchSort = 'relevance'; // Add state for search sorting
        let touchStartY = 0;
        let isRefreshing = false;
        const pullThreshold = 70; // Pixels to pull before refresh triggers

        

        // In-memory storage for videos
        let posts = [
            {
                id: '1',
                content: 'Welcome to Skrolz!',
                media_url: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerJoyrides.mp4',
                hashtags: '#welcome #skrolz',
                username: 'skrolz_admin',
                likes_count: 42,
                comments_count: 5,
                created_at: new Date().toISOString()
            },
            {
                id: '2',
                content: 'Amazing nature views',
                media_url: 'https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerEscapes.mp4',
                hashtags: '#nature #views',
                username: 'nature_lover',
                likes_count: 128,
                comments_count: 12,
                created_at: new Date(Date.now() - 86400000).toISOString()
            }
        ];
        // SIMPLE GUEST MODE CHECK - Add this function
        function checkGuestMode() {
            if (!isLoggedIn) {
                document.body.classList.add('guest-mode');
                // Store current URL for redirect after login
                sessionStorage.setItem('redirectUrl', window.location.href);
            }
        }
        // SIMPLE GUEST ACTION HANDLER - Add this function
        function handleGuestAction(callback) {
            if (!isLoggedIn) {
                document.getElementById('loginRedirect').classList.add('active');
                return;
            }
            callback();
        }
        // SIMPLE GUEST LOGIN MODAL - Add this function
        function showGuestLoginModal() {
            document.getElementById('loginRedirect').classList.add('active');
        }
      
        // Helper function to validate file before creating object URL
        function validateFileForObjectURL(file) {
            if (!file) {
                return { valid: false, error: 'No file provided' };
            }
          
            if (!(file instanceof File) && !(file instanceof Blob)) {
                return { valid: false, error: 'Invalid file type' };
            }
          
            if (file.size === 0) {
                return { valid: false, error: 'File is empty' };
            }
          
            // Check for common video MIME types
            const videoMimeTypes = [
                'video/mp4', 'video/webm', 'video/ogg', 'video/quicktime',
                'video/x-msvideo', 'video/3gpp', 'video/3gpp2'
            ];
          
            if (file.type && !videoMimeTypes.some(mime => file.type.startsWith('video/'))) {
                return { valid: false, error: 'Invalid video format' };
            }
          
            return { valid: true };
        }
        // Initialize the app
        // Function to show skeleton loader
        function showSkeletonLoader() {
            const feed = document.getElementById('feed');
            feed.innerHTML = `
            <div class="video-container skeleton-container">
                <!-- Full-screen shimmering background -->
                <div class="skeleton-video" style="width: 100%; height: 100%;"></div>

                <!-- Info Area (positioned absolutely) -->
                <div style="position: absolute; bottom: calc(1.5rem + env(safe-area-inset-bottom, 0)); left: var(--spacing-md); right: 80px; z-index: 1;">
                    <div class="skeleton-line" style="width: 150px; height: 1.1rem; margin-bottom: 0.5rem;"></div>
                    <div class="skeleton-line" style="width: 80%; height: 1rem; margin-bottom: 0.25rem;"></div>
                    <div class="skeleton-line" style="width: 60%; height: 1rem;"></div>
                </div>

                <!-- Sidebar Actions (positioned absolutely) -->
                <div style="position: absolute; right: var(--spacing-sm); bottom: calc(3.5rem + env(safe-area-inset-bottom, 0)); display: flex; flex-direction: column; gap: 1.25rem; z-index: 1;">
                    <div class="skeleton-avatar" style="width: 2.8rem; height: 2.8rem;"></div>
                    <div class="skeleton-avatar" style="width: 2.8rem; height: 2.8rem;"></div>
                    <div class="skeleton-avatar" style="width: 2.8rem; height: 2.8rem;"></div>
                </div>
            </div>
            `;
        }
        document.addEventListener('DOMContentLoaded', function() {
            initializePage();
        });

        // ===== NOTIFICATION HELPERS =====

        function showDesktopNotification(title, options = {}) {
            if ('Notification' in window) {
                if (Notification.permission === 'granted') {
                    new Notification(title, {
                        icon: '/android-chrome-192x192.png',
                        badge: '/android-chrome-192x192.png',
                        ...options
                    });
                } else if (Notification.permission === 'default') {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            new Notification(title, {
                                icon: '/android-chrome-192x192.png',
                                badge: '/android-chrome-192x192.png',
                                ...options
                            });
                        }
                    });
                }
            }
        }

        // Pull to refresh functionality
        function setupPullToRefresh() {
            const feedContainer = document.getElementById('feed');
            const pullToRefresh = document.getElementById('pullToRefresh');
            const pullToRefreshIcon = document.getElementById('pullToRefreshIcon');
            const pullToRefreshSpinner = document.getElementById('pullToRefreshSpinner');
            const liquidPath = document.getElementById('liquidPath');
            const liquidContainer = document.getElementById('liquidContainer');
            let readyToRefresh = false;
            let isDragging = false;

            feedContainer.addEventListener('touchstart', (e) => {
                if (feedContainer.scrollTop === 0 && !isRefreshing) {
                    touchStartY = e.touches[0].clientY;
                } else {
                    touchStartY = 0;
                }
                isDragging = true;
                pullToRefresh.classList.remove('snapping-back');
            }, { passive: true });

            feedContainer.addEventListener('touchmove', (e) => {
                if (touchStartY === 0 || isRefreshing) return;

                const currentY = e.touches[0].clientY;
                const deltaY = currentY - touchStartY;

                if (deltaY > 0 && isDragging) {
                    e.preventDefault(); // Prevent browser's default pull-to-refresh
                    // Apply damping to the pull distance for a more natural feel
                    const dampedDelta = deltaY * 0.4;
                    const stretch = Math.max(0, dampedDelta - 20);
                    const pathD = `M 25, 20 C 10, ${20 + stretch * 0.5} 40, ${20 + stretch * 0.5} 25, ${20 + dampedDelta}`;
                    
                    liquidPath.setAttribute('d', pathD);
                    // Use requestAnimationFrame for smoother rendering
                    requestAnimationFrame(() => { liquidContainer.style.transform = `translateY(${dampedDelta}px)`; });

                    pullToRefresh.style.top = `-50px`; // Keep the SVG container static

                    if (deltaY > pullThreshold) {
                        if (!readyToRefresh) {
                            readyToRefresh = true;
                            if (navigator.vibrate) {
                                navigator.vibrate(5); // Light vibration when ready
                            }
                        }
                        pullToRefresh.classList.add('ready');
                    } else {
                        pullToRefresh.classList.remove('ready');
                    }
                }
            }, { passive: false });

            feedContainer.addEventListener('touchend', async (e) => {
                isDragging = false;
                if (touchStartY === 0 || isRefreshing) return;

                const currentY = e.changedTouches[0].clientY;
                const deltaY = (currentY - touchStartY) * 0.4; // Use damped value for consistency

                if (deltaY > pullThreshold) {
                    if (navigator.vibrate) {
                        navigator.vibrate(50); // Stronger vibration on refresh
                    }
                    isRefreshing = true;
                    liquidPath.setAttribute('d', 'M 25, 20 C 25, 20 25, 20 25, 20 Z');
                    
                    pullToRefreshIcon.style.display = 'none';
                    pullToRefreshSpinner.style.display = 'block';
                    
                    await refreshCurrentFeed(); // Refresh the current feed
                } else {
                    // If not pulled far enough, just reset
                    pullToRefresh.classList.add('snapping-back');
                    resetPullToRefresh();
                }
                readyToRefresh = false;
            });

            checkGuestMode(); // ADD THIS LINE
            handleSharedLink(); // Handle shared link scrolling

        }
        
        // Fetch only saved posts for the "Saved" feed
        async function fetchSavedPostsFeed() {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
            // Ensure we have the latest list of saved post IDs
            await fetchSavedPosts();
            if (savedPosts.length === 0) {
                initializeFeed([]); // Show empty state if no posts are saved
                return;
            }
            try {
                const { data: { user } } = await supabase.auth.getUser();
                const { data, error } = await supabase
                    .from('posts') // Fetch profile_photo for post author
                    .select(`*, likes(user_id), profiles(username, profile_photo)`)
                    .in('id', savedPosts) // Filter by saved post IDs
                    .order('created_at', { ascending: false });
                if (error) throw error;
                const fetchedPosts = data.map(post => ({
                    ...post,
                    is_liked: user ? post.likes.some(like => like.user_id === user.id) : false,
                    is_saved: true // All posts in this feed are saved
                }));
                initializeFeed(fetchedPosts);
            } catch (error) {
                console.error('Error fetching saved posts feed:', error);
                showToast('Error loading saved posts');
            } finally {
                resetPullToRefresh();
            }
        }

        // Refresh the currently active feed
        async function refreshCurrentFeed() {
            if (currentFeedType === 'following') {
                await fetchFollowingPostsFeed();
            } else if (currentFeedType === 'saved') {
                await fetchSavedPostsFeed();
            } else {
                await fetchPostsFromDatabase();
            }
        }
        // Fetch posts from followed users
        async function fetchFollowingPostsFeed() {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
            try {
                const { data: { user } } = await supabase.auth.getUser();
                // First, get the list of users the current user is following.
                const { data: followingData, error: followingError } = await supabase
                    .from('followers')
                    .select('following_id')
                    .eq('follower_id', user.id);

                if (followingError) throw followingError;

                const followingIds = followingData.map(f => f.following_id);

                if (followingIds.length === 0) {
                    initializeFeed([]); // Show empty state if not following anyone
                    return;
                }

                // Now, fetch posts from those users.
                const { data, error } = await supabase
                    .from('posts')
                    .select(`*, likes(user_id), profiles(username, profile_photo)`)
                    .in('user_id', followingIds)
                    .order('created_at', { ascending: false });

                if (error) throw error;
                initializeFeed(data);
            } catch (error) {
                console.error('Error fetching following feed:', error);
                showToast('Error loading posts from users you follow.');
            } finally {
                resetPullToRefresh();
            }
        }
        // Handle shared link - FIXED VERSION
        async function handleSharedLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const videoId = urlParams.get('videoId');
            const userId = urlParams.get('userId');

            if (!videoId) return; // If there's no videoId, we don't need this special handling.

            try {
                // 1. Fetch the specific video that was clicked/shared.
                const { data: specificVideoData, error: videoError } = await supabase
                    .from('posts')
                    .select(`*, likes(user_id), profiles(username, profile_photo)`)
                    .eq('id', videoId)
                    .single();

                if (videoError) {
                    console.error('Error fetching shared video:', videoError);
                    showToast('Could not load the requested video.');
                    // Fallback to the normal feed if the specific video fails to load
                    await fetchPostsFromDatabase();
                    return;
                }

                const { data: { user } } = await supabase.auth.getUser();

                // Mark if this video is liked by the current user
                const specificVideo = {
                    ...specificVideoData,
                    is_liked: user ? specificVideoData.likes.some(like => like.user_id === user.id) : false,
                    is_saved: savedPosts.includes(specificVideoData.id)
                };

                // 2. Fetch the rest of the posts.
                let query = supabase
                    .from('posts')
                    .select(`*, likes(user_id), profiles(username, profile_photo)`)
                    .neq('id', videoId) // Exclude the one we already fetched
                    .order('created_at', { ascending: false });

                // If a userId is provided, filter the *rest* of the posts by that user.
                if (userId) {
                    query = query.eq('user_id', userId);
                }

                const { data: otherPostsData, error: postsError } = await query;

                if (postsError) {
                    console.error('Error fetching other posts:', postsError);
                    // If fetching other posts fails, at least show the one we successfully loaded.
                    initializeFeed([specificVideo]);
                    return;
                }

                const otherPosts = otherPostsData.map(post => ({
                    ...post,
                    is_liked: user ? post.likes.some(like => like.user_id === user.id) : false,
                    is_saved: savedPosts.includes(post.id)
                }));

                // 3. Combine the specific video with the others, ensuring it's first.
                const allPosts = [specificVideo, ...otherPosts];

                initializeFeed(allPosts);

                // 4. Scroll to the specific video after it has been rendered.
                // 'auto' is better than 'smooth' here for instant positioning.
                setTimeout(() => {
                    const videoElement = document.getElementById(`video-${videoId}`);
                    if (videoElement) {
                        videoElement.scrollIntoView({ behavior: 'auto', block: 'start' });
                    }
                }, 100); // A small delay to ensure DOM is updated.

            } catch (error) {
                console.error('handleSharedLink error:', error);
            }
        }

        async function initializePage() {
            // Show the skeleton loader immediately while we fetch data.
            showSkeletonLoader();

            // Apply theme from localStorage
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            currentTheme = savedTheme;

            await checkLoginStatus();
            await fetchUserProfile(); // Fetch user profile after checking login

            // Check localStorage for the last used feed type
            const lastFeedType = localStorage.getItem('lastFeedType');
            if (lastFeedType && isLoggedIn) {
                currentFeedType = lastFeedType;
            }

            await fetchSavedPosts(); // Fetch saved posts early for UI state

            // Check if there's a shared video before fetching all posts
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('videoId')) {
                await handleSharedLink();
            } else if (currentFeedType === 'saved' && isLoggedIn) {
                await fetchSavedPostsFeed();
            } else if (isLoggedIn) {
                // Fetch saved posts for the logged-in user
                await fetchSavedPosts();
                // Load notifications for badge
                loadUserNotifications();
                // Then load the feed
                await fetchPostsFromDatabase();
            } else {
                // Normal feed load
                await fetchPostsFromDatabase();
            }
            
            setupEventListeners();
            setupPullToRefresh();
        }

        // Check login status
        async function checkLoginStatus() {
            try {
                const { data: { session } } = await supabase.auth.getSession();
                isLoggedIn = !!session;
                if (!isLoggedIn) {
                    document.querySelectorAll('.action-item, .add-post-btn').forEach(el => {
                        // Using guest-mode class now, so this can be removed or kept as fallback
                    });
                }
            } catch (error) {
                console.log('Auth check failed, defaulting to guest mode');
                isLoggedIn = false;
            }
        }

        // Fetch current user's profile
        async function fetchUserProfile() {
            if (!isLoggedIn) return;
            try {
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) return;

                const { data, error } = await supabase
                    .from('profiles')
                    .select('username, profile_photo')
                    .eq('id', user.id)
                    .single();

                if (error) throw error;
                currentUserProfile = data;
            } catch (error) {
                // If profile doesn't exist, create a temporary one for UI consistency
                if (error.code === 'PGRST116') { // "single" query returned no rows
                    const { data: { user } } = await supabase.auth.getUser();
                    currentUserProfile = {
                        username: user.email.split('@')[0],
                        avatar_url: null,
                        id: user.id
                    };
                } else {
                    console.error('Error fetching user profile:', error);
                }
                console.error('Error fetching user profile:', error);
            }
        }

        // Load user notifications count for badge
        async function loadUserNotifications() {
            try {
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) return;
                const { count, error } = await supabase
                    .from('notifications')
                    .select('*', { count: 'exact', head: true })
                    .eq('user_id', user.id)
                    .eq('read', false);
                if (error) throw error;
                if (count > 0) {
                    document.querySelectorAll('.mobile-bottom-nav .notification-badge').forEach(el => el.classList.add('visible'));
                }
            } catch (error) { console.error('Error loading notifications:', error); }
        }

        // Logout function
        async function logout() {
            const modal = document.getElementById('logoutModal');
            modal.style.display = "block";
        }




        // Fetch user's saved posts
        async function fetchSavedPosts() {
            if (!isLoggedIn) return;
            try {
                const { data: { user } } = await supabase.auth.getUser();
                const { data, error } = await supabase
                    .from('saved_posts')
                    .select('post_id')
                    .eq('user_id', user.id);
                if (error) throw error;
                savedPosts = data.map(item => item.post_id);
            } catch (error) {
                console.error('Error fetching saved posts:', error);
                savedPosts = [];
            }
        }
        // Fetch posts from database
        async function fetchPostsFromDatabase() {
            // If refreshing, show spinner
            // This function is now only for the generic "For You" feed.
            // The handleSharedLink function will handle user-specific or video-specific loads.

            try {
                const { data: { user } } = await supabase.auth.getUser();

                // Fetch all posts for the "For You" feed.
                let query = supabase
                    .from('posts')
                    .select(`*, likes(user_id), profiles(username, profile_photo)`)
                    .order('created_at', { ascending: false });

                // NEW: If a userId is in the URL, this function should filter by it.
                // This acts as a fallback if videoId is not present.
                const urlParams = new URLSearchParams(window.location.search);
                const userId = urlParams.get('userId');
                if (userId) {
                    query = query.eq('user_id', userId);
                }

                const { data, error } = await query;
              
                if (error) {
                    console.log('Using sample data due to error:', error);
                    initializeFeed(posts);
                    return;
                }
              
                let fetchedPosts = [];
                if (data) {
                    fetchedPosts = data.map(post => ({
                        ...post,
                        is_liked: user ? post.likes.some(like => like.user_id === user.id) : false,
                        is_saved: savedPosts.includes(post.id) // Check if post is in the saved list
                    }));
                }

                if (fetchedPosts.length > 0) {
                    initializeFeed(fetchedPosts);
                } else {
                    // If no posts, show empty state for the "For You" feed
                    document.getElementById('feed').innerHTML = `
                        <div class="video-container" style="display: flex; justify-content: center; align-items: center; flex-direction: column; gap: 1rem;">
                            <div style="font-size: 1.2rem;">No posts yet</div>
                            ${isLoggedIn ? `
                            <button onclick="openUploadModal()" style="background: var(--primary-color); color: white; border: none; border-radius: 10px; padding: 0.5rem 1rem; cursor: pointer;">
                                Create First Post
                            </button>
                            ` : ''}
                        </div>
                    `;
                }
              
            } catch (error) {
                console.error('Error fetching posts:', error);

            } finally {
                if (isRefreshing) {
                    resetPullToRefresh(); // This correctly resets the pull-to-refresh UI
                }
            }
        }
        // Create video feed
        function initializeFeed(posts) {
            const feed = document.getElementById('feed');
            // Clear the feed, which will remove the skeleton loader or any previous content.
            feed.innerHTML = '';
          
            // Handle empty state for saved feed
            if (posts.length === 0 && currentFeedType === 'saved') {
                feed.innerHTML = `
                    <div class="video-container empty-state-container">
                        <div class="empty-state-icon">üîñ</div>
                        <div style="font-size: 1.2rem; font-weight: bold;">No Saved Posts Yet</div>
                        <div style="opacity: 0.8;">Tap the save icon on a video to keep it here.</div>
                    </div>
                `;
                // We still need to render the top bar for navigation
                renderTopBar();
                setupEventListeners(); // Re-attach listeners for the top bar
                return;
            } else if (posts.length === 0 && currentFeedType === 'following') {
                feed.innerHTML = `
                    <div class="video-container empty-state-container">
                        <div class="empty-state-icon">üë•</div>
                        <div style="font-size: 1.2rem; font-weight: bold;">Your Following Feed is Empty</div>
                        <div style="opacity: 0.8;">Posts from users you follow will appear here.</div>
                    </div>
                `;
                renderTopBar();
                return;
            }

            posts.forEach(video => {
                const videoContainer = document.createElement('div');
                videoContainer.className = 'video-container';
                videoContainer.id = `video-${video.id}`;
              
                // SIMPLE GUEST MODE TEMPLATE - Just add watermark and modify button behavior
                videoContainer.innerHTML = `
                    <div class="video-wrapper" style="position: relative; width: 100%; height: 100%;">
                        <video class="video-player" loop muted playsinline preload="metadata">
                            <source src="${video.media_url}" type="video/mp4">
                        </video>
                        <!-- Hidden video for smooth thumbnail scrubbing -->
                        <video class="video-player" id="scrubbingPlayer-${video.id}" muted playsinline preload="metadata" style="display: none;">
                            <source src="${video.media_url}" type="video/mp4">
                        </video>
                        <div class="loading-overlay" id="loading-${video.id}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 6;">
                            <div class="bouncing-loader">
                                <div style="animation-delay: 0s;"></div>
                                <div style="animation-delay: 0.2s;"></div>
                                <div style="animation-delay: 0.4s;"></div>
                            </div>
                        </div>
                    </div>
                    <div class="video-controls-overlay">
                        <i class="fas fa-play play-pause-btn" id="playPauseBtn-${video.id}"></i>
                    </div>
                    <div class="video-info">
                        <a href="profile.html?userId=${video.user_id}" class="post-author-avatar" style="text-decoration: none; color: inherit;">
                            ${video.profiles?.profile_photo ? `
                                <img src="${video.profiles.profile_photo}" style="width: 24px; height: 24px; border-radius: 50%; object-fit: cover;">
                            ` : `
                                <div class="post-author-initials">${(video.profiles?.username || 'U').substring(0, 2).toUpperCase()}</div>
                            `}
                            <span class="username">@${video.profiles?.username || 'user'}</span>
                        </a>
                        <div class="post-title">${video.title || ''}</div>
                        <div class="caption">${video.content || ''}</div>
                        <div class="hashtags">${video.hashtags || ''}</div>
                    </div><div class="actions-sidebar">
                        <div class="action-item" onclick="handleGuestAction(() => toggleLike(this, '${video.id}'))">
                            <div class="action-icon" id="likeIcon-${video.id}" style="color: ${video.is_liked ? 'var(--primary-color)' : 'currentColor'};">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="${video.is_liked ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
                                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                                </svg>
                            </div>
                            <div class="action-count like-count" id="likeCount-${video.id}">${video.likes_count ?? 0}</div>
                        </div>
                        <div class="action-item" onclick="openComments('${video.id}')">
                            <div class="action-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>
                                </svg>
                            </div>
                            <div class="action-count" id="commentCount-${video.id}">${video.comments_count ?? 0}</div>
                        </div>
                        <div class="action-item" onclick="${isLoggedIn ? `shareVideo('${video.id}')` : `showGuestLoginModal()`}">
                            <div class="action-icon">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path>
                                    <polyline points="16 6 12 2 8 6"></polyline>
                                    <line x1="12" y1="2" x2="12" y2="15"></line>
                                </svg>
                            </div>
                            <div class="action-count">Share</div>
                        </div>
                        ${isLoggedIn ? `
                        <div class="action-item" onclick="toggleSave('${video.id}')">
                            <div class="action-icon" id="saveIcon-${video.id}" style="color: ${video.is_saved ? 'var(--save-color-active)' : 'currentColor'};">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="${video.is_saved ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2">
                                    <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
                                </svg>
                            </div>
                            <div class="action-count">Save</div>
                        </div>
                        ${video.user_id === 'current-user-id' ? '<div class="action-item" onclick="deletePost(\'' + video.id + '\')"><div class="action-icon delete-post">√ó</div><div class="action-count">Delete</div></div>' : ''}
                        ` : ''}
                    </div>
                    <div class="bottom-controls-bar">
                        <div class="progress-bar-container" id="progressBarContainer-${video.id}">
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill-${video.id}"></div>
                            </div>
                            <div class="thumbnail-preview" id="thumbnailPreview-${video.id}">
                                <canvas class="thumbnail-image" id="thumbnailCanvas-${video.id}"></canvas>
                                <span class="thumbnail-time" id="thumbnailTime-${video.id}">0:00</span>
                            </div>
                        </div>
                        <div class="volume-controls">
                            <div class="volume-slider-container">
                                <input type="range" min="0" max="1" step="0.01" value="1" class="volume-slider" id="volumeSlider-${video.id}">
                            </div>
                            <div class="mute-toggle" onclick="toggleMute(this, '${video.id}')">
                                <svg class="volume-icon-unmuted" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                                </svg>
                                <svg class="volume-icon-muted" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display: none;">
                                    <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                                    <line x1="23" y1="9" x2="17" y2="15"></line>
                                    <line x1="17" y1="9" x2="23" y2="15"></line>
                                </svg>
                            </div>
                        </div>
                    </div>
                    <div class="comment-drawer" id="commentDrawer-${video.id}">
                        <div class="comment-header">
                            <div class="comment-title">Comments</div>
                            <button class="close-comments" onclick="closeComments('${video.id}')">√ó</button>
                        </div>
                        <div class="comments-list" id="commentsList-${video.id}">
                            <!-- Comments will be dynamically inserted here -->
                        </div>
                        <div class="reply-indicator" id="replyIndicator-${video.id}" style="display: none; padding: 0.5rem 1rem; font-size: 0.8rem; background: rgba(0,0,0,0.2);">
                            Replying to <span id="replyingToUser-${video.id}" style="font-weight: bold;"></span>
                            <button onclick="cancelReply('${video.id}')" style="background: none; border: none; color: white; margin-left: 1rem; cursor: pointer;">√ó</button>
                        </div>
                     
                        <div class="comment-input-container">
                            <textarea class="comment-input" id="commentInput-${video.id}" placeholder="Add a comment..." rows="1" oninput="autoGrow(this)"></textarea>
                            <button class="comment-submit" onclick="addComment('${video.id}')">Post</button>
                        </div>
                    </div>
                `;
              
                feed.appendChild(videoContainer);
              
                // Add double tap like functionality
                videoContainer.addEventListener('dblclick', function(e) {
                    if (!isLoggedIn) {
                        showGuestLoginModal();
                        return;
                    }
                    const likeButton = this.querySelector(`#likeIcon-${video.id}`).parentElement;
                    createLikeAnimation(e);
                    toggleLike(likeButton, video.id);
                });
              
                // Add single tap to pause/play - MODIFIED CODE
                const videoPlayer = videoContainer.querySelector('.video-player');
                const playPauseBtn = videoContainer.querySelector(`#playPauseBtn-${video.id}`);
                const progressFill = videoContainer.querySelector(`#progressFill-${video.id}`);
                const loadingOverlay = videoContainer.querySelector(`#loading-${video.id}`);
                videoPlayer.addEventListener('loadstart', () => loadingOverlay.style.display = 'flex');
                videoPlayer.addEventListener('waiting', () => loadingOverlay.style.display = 'flex'); // Show when buffering
                videoPlayer.addEventListener('canplay', () => loadingOverlay.style.display = 'none'); // Hide when ready
                const progressBarContainer = videoContainer.querySelector(`#progressBarContainer-${video.id}`);
                let controlsTimeout;
                const toggleControls = () => {
                    videoContainer.classList.toggle('controls-visible');
                    clearTimeout(controlsTimeout);
                    if (videoContainer.classList.contains('controls-visible')) {
                        controlsTimeout = setTimeout(() => {
                            videoContainer.classList.remove('controls-visible');
                        }, 3000);
                    }
                };
                const togglePlayPause = () => {
                    if (videoPlayer.paused) {
                        videoPlayer.play();
                        playPauseBtn.className = 'fas fa-pause play-pause-btn';
                    } else {
                        videoPlayer.pause();
                        playPauseBtn.className = 'fas fa-play play-pause-btn';
                    }
                    toggleControls();
                };
                videoContainer.addEventListener('click', (e) => {
                    if (e.target.closest('.actions-sidebar, .top-bar, .video-info, .mute-toggle, .comment-drawer, .progress-bar-container')) {
                        return;
                    }
                    togglePlayPause();
                });
                videoPlayer.addEventListener('timeupdate', () => {
                    const progress = (videoPlayer.currentTime / videoPlayer.duration) * 100;
                    progressFill.style.width = `${progress}%`;
                });
                progressBarContainer.addEventListener('click', (e) => {
                    const rect = progressBarContainer.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const width = progressBarContainer.clientWidth;
                    const duration = videoPlayer.duration;
                    videoPlayer.currentTime = (clickX / width) * duration;
                });

                // Thumbnail preview on hover
                const thumbnailPreview = videoContainer.querySelector(`#thumbnailPreview-${video.id}`);
                const thumbnailCanvas = videoContainer.querySelector(`#thumbnailCanvas-${video.id}`);
                const thumbnailTime = videoContainer.querySelector(`#thumbnailTime-${video.id}`);
                const scrubbingPlayer = videoContainer.querySelector(`#scrubbingPlayer-${video.id}`);
                const ctx = thumbnailCanvas.getContext('2d');
                let isScrubbing = false;
                let throttleTimer;

                progressBarContainer.addEventListener('mousemove', (e) => {
                    if (isNaN(videoPlayer.duration)) return;

                    const rect = progressBarContainer.getBoundingClientRect();
                    const hoverX = e.clientX - rect.left;
                    const progressBarWidth = progressBarContainer.clientWidth;
                    const hoverTime = (hoverX / progressBarWidth) * videoPlayer.duration;

                    if (hoverTime < 0 || hoverTime > videoPlayer.duration) return;

                    // Position the preview box
                    const previewLeft = Math.max(80, Math.min(hoverX, progressBarWidth - 80)); // Keep preview within bounds
                    thumbnailPreview.style.left = `${previewLeft}px`;

                    // Update the time display
                    const minutes = Math.floor(hoverTime / 60);
                    const seconds = Math.floor(hoverTime % 60).toString().padStart(2, '0');
                    thumbnailTime.textContent = `${minutes}:${seconds}`;

                    // Throttle the expensive video seeking
                    if (!throttleTimer) {
                        throttleTimer = setTimeout(() => {
                            scrubbingPlayer.currentTime = hoverTime; // Use the hidden player
                            throttleTimer = null;
                        }, 100); // Seek at most every 100ms
                    }
                });

                progressBarContainer.addEventListener('mouseenter', () => {
                    isScrubbing = true;
                });

                progressBarContainer.addEventListener('mouseleave', () => {
                    isScrubbing = false;
                    // Clear any pending seek
                    if (throttleTimer) {
                        clearTimeout(throttleTimer);
                        throttleTimer = null;
                    }
                });

                // Draw the frame to the canvas when the video seeks
                scrubbingPlayer.addEventListener('seeked', () => { // Listen to the hidden player
                    // Only draw if the user is actively scrubbing to avoid unnecessary draws
                    if (isScrubbing) {
                        ctx.drawImage(scrubbingPlayer, 0, 0, thumbnailCanvas.width, thumbnailCanvas.height);
                    }
                });

                // Add volume slider event listener
                const volumeSlider = videoContainer.querySelector(`#volumeSlider-${video.id}`);
                volumeSlider.addEventListener('input', (e) => {
                    videoPlayer.volume = e.target.value;
                    const progress = e.target.value * 100;
                    volumeSlider.style.setProperty('--volume-progress', `${progress}%`);
                });

                // FIX: Add touch event prevention for comment input and drawer
                const commentDrawer = videoContainer.querySelector(`#commentDrawer-${video.id}`);
                const commentInput = videoContainer.querySelector(`#commentInput-${video.id}`);
              
                if (commentDrawer) {
                    commentDrawer.addEventListener('touchstart', function(e) {
                        e.stopPropagation();
                    });
                  
                    commentDrawer.addEventListener('touchmove', function(e) {
                        e.stopPropagation();
                    });
                  
                    commentDrawer.addEventListener('touchend', function(e) {
                        e.stopPropagation();
                    });
                }
              
                if (commentInput) {
                    commentInput.addEventListener('focus', function() {
                        // Disable scroll-snap when typing in comment input
                        document.getElementById('feed').classList.add('no-snap');
                    });
                  
                    commentInput.addEventListener('blur', function() {
                        // Only re-enable scroll-snap if comment drawer is closed
                        if (!isCommentDrawerOpen) {
                            document.getElementById('feed').classList.remove('no-snap');
                        }
                    });
                }
            });
          
            // Set up intersection observer after videos are loaded
            setupIntersectionObserver();
            renderTopBar(); // Render the static top bar

            // Re-attach event listeners for newly created elements like feed tabs
            setupEventListeners();
        }


        // Reset pull-to-refresh UI
        function resetPullToRefresh() {
            const pullToRefresh = document.getElementById('pullToRefresh');
            const pullToRefreshIcon = document.getElementById('pullToRefreshIcon');
            const pullToRefreshSpinner = document.getElementById('pullToRefreshSpinner');
            const liquidPath = document.getElementById('liquidPath');
            const liquidContainer = document.getElementById('liquidContainer');

            // Add checks to ensure elements exist before manipulating them
            if (pullToRefresh) pullToRefresh.classList.remove('ready', 'snapping-back');
            if (liquidPath) liquidPath.setAttribute('d', 'M 25, 20 C 25, 20 25, 20 25, 20 Z');
            if (liquidContainer) {
                liquidContainer.style.transform = 'translateY(0)';
                // The transition is now handled by the 'snapping-back' class
            }
            if (pullToRefreshIcon) pullToRefreshIcon.style.display = 'block';
            if (pullToRefreshSpinner) pullToRefreshSpinner.style.display = 'none';

            touchStartY = 0;
            isRefreshing = false;
        }


        // Renders just the top bar, useful for empty feed states
        function renderTopBar() {
            const topBarContainer = document.getElementById('staticTopBar');
            // Check if we are on a mobile-sized screen
            const isMobile = window.innerWidth <= 768;
            const feedNames = {
                'for-you': 'For You', 'following': 'Following', 'saved': 'Saved'
            };

            if (!topBarContainer) return;

            let profileIconHtml = '';
            if (isLoggedIn && currentUserProfile) {
                if (currentUserProfile.profile_photo) {
                    profileIconHtml = `<div class="profile-icon" onclick="toggleProfileDropdown()"><img src="${currentUserProfile.profile_photo}" alt="Profile" crossOrigin="anonymous"></div>`;
                } else {
                    const initials = (currentUserProfile.username || 'U').substring(0, 2).toUpperCase();
                    profileIconHtml = `<div class="profile-icon initials-avatar" onclick="toggleProfileDropdown()"><span>${initials}</span></div>`;
                }
            }

            let feedSwitcherHtml = '';
            if (isMobile) {
                // Render dropdown for mobile
                feedSwitcherHtml = `
                    <div class="feed-switcher-current" onclick="toggleFeedDropdown()">
                        <span id="currentFeedName">${feedNames[currentFeedType]}</span>
                        <i class="fas fa-chevron-down" id="feedDropdownIcon"></i>
                    </div>
                    <div class="feed-switcher-options" id="feedSwitcherOptions"></div>
                `;
            } else {
                // Render tabs for desktop
                feedSwitcherHtml = `
                    <span class="feed-tab ${currentFeedType === 'for-you' ? 'active' : ''}" data-feed-type="for-you"><span class="feed-tab-text">For You</span><div class="tab-spinner"></div></span>
                    ${isLoggedIn ? `<span class="feed-tab ${currentFeedType === 'following' ? 'active' : ''}" data-feed-type="following"><span class="feed-tab-text">Following</span><div class="tab-spinner"></div></span>` : ''}
                    ${isLoggedIn ? `<span class="feed-tab ${currentFeedType === 'saved' ? 'active' : ''}" data-feed-type="saved"><span class="feed-tab-text">Saved</span><div class="tab-spinner"></div></span>` : ''}
                `;
            }
            const topBarHTML = `
                <div class="top-bar-left">
                    <div class="back-button" onclick="goToDashboard()">
                        <i class="fas fa-home"></i>
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    ${profileIconHtml}
                    <div class="profile-dropdown" id="profileDropdown">
                        <a href="profile.html" class="profile-dropdown-item"><i class="fas fa-user-circle" style="width: 16px;"></i> View Profile</a>
                        <div class="profile-dropdown-item" id="desktopSettingsBtn" style="cursor: pointer;"><i class="fas fa-cog" style="width: 16px;"></i> Settings</div>
                        <div class="profile-dropdown-item" onclick="logout()"><i class="fas fa-sign-out-alt" style="width: 16px;"></i> Log Out</div>
                    </div>
                </div>
                <div class="feed-switcher">${feedSwitcherHtml}</div>
                <div style="display: flex; align-items: center; gap: var(--spacing-sm);">
                    ${isLoggedIn && !isMobile ? `<button onclick="openUploadModal()" class="add-post-btn" style="background: var(--primary-color); color: white; border: none; border-radius: 20px; padding: 0.5rem 1rem; cursor: pointer; font-weight: bold; display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;"><i class="fas fa-plus"></i> Create</button>` : ''}
                    ${isLoggedIn ? `<div class="search-icon" id="searchIcon"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></div>` : ''}
                </div>
            `;
            topBarContainer.innerHTML = topBarHTML;

            // If on mobile, populate the dropdown options
            if (isMobile) {
                const optionsContainer = document.getElementById('feedSwitcherOptions');
                if (optionsContainer) {
                    optionsContainer.innerHTML = ''; // Clear previous options
                    Object.keys(feedNames).forEach(feedType => {
                        if (feedType !== currentFeedType && (isLoggedIn || feedType === 'for-you')) {
                            const option = document.createElement('div');
                            option.className = 'feed-switcher-option';
                            option.textContent = feedNames[feedType];
                            option.dataset.feedType = feedType;
                            optionsContainer.appendChild(option);
                        }
                    });
                }
            }
        }

        // Toggle profile dropdown
        function toggleProfileDropdown() {
            const dropdown = document.getElementById('profileDropdown');
            if (!dropdown) return;
            dropdown.classList.toggle('active');
        }

        // Toggle feed dropdown (for mobile)
        function toggleFeedDropdown() {
            const dropdown = document.getElementById('feedSwitcherOptions');
            const icon = document.getElementById('feedDropdownIcon');
            if (!dropdown || !icon) return;
            dropdown.classList.toggle('active');
            icon.style.transform = dropdown.classList.contains('active') ? 'rotate(180deg)' : 'rotate(0deg)';
        }

        // Set up event listeners
        function setupEventListeners() {
            // Use event delegation for feed tabs since they are re-rendered
            const feedContainer = document.getElementById('staticTopBar');
            // Remove any old listener to prevent duplicates - IMPORTANT
            feedContainer.removeEventListener('click', handleFeedTabClick); 
            feedContainer.addEventListener('click', handleFeedTabClick);

            // Handler function for feed tab clicks
            async function handleFeedTabClick(e) {
                const clickedElement = e.target.closest('.feed-tab, .feed-switcher-option');
                if (!clickedElement) return;

                const feedType = clickedElement.dataset.feedType;

                // Handle dropdown option click
                if (clickedElement.classList.contains('feed-switcher-option')) {
                    const dropdown = document.getElementById('feedSwitcherOptions');
                    const icon = document.getElementById('feedDropdownIcon');
                    if (dropdown) dropdown.classList.remove('active');
                    if (icon) icon.style.transform = 'rotate(0deg)';
                }

                // Common logic for both tabs and dropdown options
                // Do nothing if the same tab is clicked or if it's already loading
                if (feedType === currentFeedType || clickedElement.classList.contains('loading')) return;

                // Handle guest attempts to access protected feeds
                if (!isLoggedIn && (feedType === 'following' || feedType === 'saved')) {
                    showGuestLoginModal();
                    return;
                }

                // Show loading state
                showSkeletonLoader();
                // Add loading class to the specific tab that was clicked
                const topBar = document.getElementById('staticTopBar');
                topBar.querySelectorAll('.feed-tab, .feed-switcher-option').forEach(el => el.classList.remove('loading'));
                clickedElement.classList.add('loading');

                // Update state
                currentFeedType = feedType;
                localStorage.setItem('lastFeedType', currentFeedType);

                // Fetch new feed data, which will re-render everything
                await refreshCurrentFeed();
            }

            // Settings Drawer Logic
            const settingsDrawer = document.getElementById('settingsDrawer');
            const overlay = document.getElementById('overlay');
            const mobileSettingsBtn = document.getElementById('mobileSettingsBtn');
            const desktopSettingsBtn = document.getElementById('desktopSettingsBtn');
            const closeDrawerBtn = document.getElementById('closeDrawer');

            function openSettingsDrawer() {
                if (settingsDrawer) settingsDrawer.classList.add('open');
                if (overlay) overlay.classList.add('active');
            }

            if (mobileSettingsBtn) {
                mobileSettingsBtn.addEventListener('click', openSettingsDrawer);
            }

            if (desktopSettingsBtn) {
                desktopSettingsBtn.addEventListener('click', openSettingsDrawer);
            }

            // Mobile Add Post Button
            const mobileAddPostBtn = document.getElementById('mobileAddPostBtn');
            if (mobileAddPostBtn) {
                let pressTimer;
                let longPressTriggered = false;

                const startPress = () => {
                    mobileAddPostBtn.classList.add('pressing');
                    longPressTriggered = false;
                    pressTimer = setTimeout(() => {
                        mobileAddPostBtn.classList.remove('pressing');
                        longPressTriggered = true;
                        if (navigator.vibrate) navigator.vibrate(50);
                        
                        if (!isLoggedIn) {
                            showGuestLoginModal();
                        } else {
                            openUploadModal();
                            showUploadForm('camera');
                        }
                    }, 600);
                };

                const cancelPress = () => {
                    clearTimeout(pressTimer);
                    mobileAddPostBtn.classList.remove('pressing');
                };

                mobileAddPostBtn.addEventListener('touchstart', startPress, { passive: true });
                mobileAddPostBtn.addEventListener('touchend', (e) => {
                    cancelPress();
                    if (longPressTriggered && e.cancelable) e.preventDefault();
                });
                mobileAddPostBtn.addEventListener('mousedown', startPress);
                mobileAddPostBtn.addEventListener('mouseup', cancelPress);
                mobileAddPostBtn.addEventListener('mouseleave', cancelPress);

                mobileAddPostBtn.addEventListener('click', (e) => {
                    if (longPressTriggered) {
                        e.preventDefault();
                        e.stopPropagation();
                    } else {
                        openUploadModal();
                    }
                });
            }

            function closeSettingsDrawer() {
                if (settingsDrawer) settingsDrawer.classList.remove('open');
                if (overlay) overlay.classList.remove('active');
            }

            if (closeDrawerBtn) closeDrawerBtn.addEventListener('click', closeSettingsDrawer);
            if (overlay) overlay.addEventListener('click', closeSettingsDrawer);

            // Close drawer on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeSettingsDrawer();
                }
            });

            // Update profile link with user ID
            async function updateProfileLink() {
                try {
                    const { data: { user } } = await supabase.auth.getUser();
                    const editProfileLink = document.getElementById('editProfileLink');
                    if (user && editProfileLink) {
                        editProfileLink.href = `profile.html?userId=${user.id}`;
                    }
                } catch (error) {
                    console.error('Error updating profile link:', error);
                }
            }
            updateProfileLink();

            // --- The rest of your event listeners ---
          
            // Search icon
            const searchIcon = document.getElementById('searchIcon');
            if (searchIcon) {
                searchIcon.addEventListener('click', function() {
                    const searchOverlay = document.getElementById('searchOverlay');
                    const searchResultsContainer = document.getElementById('searchResults');
                    
                    searchOverlay.classList.add('active');
                    this.classList.add('active');

                    // Set initial state of search overlay
                    searchResultsContainer.innerHTML = '<div style="text-align: center; opacity: 0.7; padding-top: 2rem;">Search for posts, hashtags, or users.</div>';
                });
            }
          
            // Close search
            const closeSearch = document.getElementById('closeSearch');
            if (closeSearch) {
                closeSearch.addEventListener('click', function() {
                    document.getElementById('searchOverlay').classList.remove('active');
                    document.getElementById('searchIcon').classList.remove('active');
                });
            }
          
            // File input change
            const videoFile = document.getElementById('videoFile');
            if (videoFile) {
                videoFile.addEventListener('change', function(e) {
                    handleFileSelect(e);
                });
            }
          
            // Record button
            const recordBtn = document.getElementById('recordBtn');
            if (recordBtn) {
                recordBtn.addEventListener('click', function() {
                    if (isRecording) {
                        stopRecording();
                    } else {
                        startRecording();
                    }
                });
            }
          
            // Upload submit button
            const uploadSubmitBtn = document.getElementById('uploadSubmitBtn');
            if (uploadSubmitBtn) {
                const newSubmitBtn = uploadSubmitBtn.cloneNode(true);
                uploadSubmitBtn.parentNode.replaceChild(newSubmitBtn, uploadSubmitBtn);
                newSubmitBtn.addEventListener('click', submitPost);
            }
          
            // Enter key in comment inputs
            document.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && e.target.classList.contains('comment-input')) {
                    const videoId = e.target.id.split('-')[1];
                    addComment(videoId);
                }
            });
          
            // SIMPLE LOGIN REDIRECT BUTTONS - Replace existing login button code
            const signUpButton = document.getElementById('signUpButton');
            const logInButton = document.getElementById('logInButton');
          
            if (signUpButton) {
                signUpButton.addEventListener('click', function() {
                    // Store current URL for redirect back
                    sessionStorage.setItem('redirectUrl', window.location.href);
                    window.location.href = 'signup.html?redirect=' + encodeURIComponent(window.location.href);
                });
            }
          
            if (logInButton) {
                logInButton.addEventListener('click', function() {
                    // Store current URL for redirect back
                    sessionStorage.setItem('redirectUrl', window.location.href);
                    window.location.href = 'login.html?redirect=' + encodeURIComponent(window.location.href);
                });
            }
          
            // Form validation
            const postTitle = document.getElementById('postTitle');
            if (postTitle) {
                postTitle.addEventListener('input', checkUploadButton);
            }

            // Search input with debouncing
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                let debounceTimer;
                searchInput.addEventListener('input', function() {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        const query = this.value.trim();
                        performSearch(query);
                    }, 300); // Wait 300ms after user stops typing
                });
            }

            // Search sort options
            const searchSortOptions = document.getElementById('searchSortOptions');
            if (searchSortOptions) {
                searchSortOptions.addEventListener('click', (e) => {
                    if (e.target.classList.contains('sort-option')) {
                        searchSortOptions.querySelector('.active').classList.remove('active');
                        e.target.classList.add('active');
                        currentSearchSort = e.target.dataset.sort;
                        // Re-run the search with the new sort order
                        performSearch(document.getElementById('searchInput').value.trim());
                    }
                });
            }

            // Video preview close button
            const videoPreviewCloseBtn = document.getElementById('videoPreviewCloseBtn');
            if (videoPreviewCloseBtn) {
                videoPreviewCloseBtn.addEventListener('click', clearSelectedVideo);
            }

            // Add Page Visibility API listener
            document.addEventListener('visibilitychange', () => {
                handleVisibilityChange();
            });

            // Logout Modal Interaction
            const logoutModal = document.getElementById('logoutModal');
            if (logoutModal) {
                const confirmLogoutButton = document.getElementById('confirmLogout');
                const cancelLogoutButton = document.getElementById('cancelLogout');
                const closeLogoutModal = document.getElementById('closeLogoutModal');

                confirmLogoutButton.addEventListener('click', async () => {
                    // NEW: Close the "Who Reacted" modal if it's open
                    const whoReactedModal = document.getElementById('whoReactedModal');
                    if (whoReactedModal) whoReactedModal.style.display = "none";

                    try {
                        const { error } = await supabase.auth.signOut();
                        if (error) throw error;
                        window.location.href = 'login.html';
                    } catch (error) {
                        console.error('Error logging out:', error);
                        showToast('Error logging out');
                    } finally {
                        logoutModal.style.display = "none";
                    }
                });

                const closeModal = () => logoutModal.style.display = "none";
                cancelLogoutButton.addEventListener('click', closeModal);
                closeLogoutModal.addEventListener('click', closeModal);

                window.addEventListener('click', (event) => {
                    if (event.target == logoutModal) closeModal();
                });
            }

            // NEW: "Who Reacted" Modal Interaction
            const whoReactedModal = document.getElementById('whoReactedModal');
            if (whoReactedModal) {
                const closeWhoReactedModal = document.getElementById('closeWhoReactedModal');
                const closeModal = () => whoReactedModal.style.display = "none";

                closeWhoReactedModal.addEventListener('click', closeModal);

                window.addEventListener('click', (event) => {
                    if (event.target == whoReactedModal) {
                        closeModal();
                    }
                });
            }

            // Global click listener to close dropdowns on click outside
            document.addEventListener('click', (e) => {
                // Close profile dropdown if click is outside
                const profileDropdown = document.getElementById('profileDropdown');
                const profileIcon = document.querySelector('.profile-icon');

                if (profileDropdown && profileDropdown.classList.contains('active')) {
                    // If the click is NOT on the icon AND NOT on the dropdown itself
                    if ((!profileIcon || !profileIcon.contains(e.target)) && !profileDropdown.contains(e.target)) {
                        profileDropdown.classList.remove('active');
                    }
                }

                // Close feed switcher dropdown if click is outside
                const feedDropdown = document.getElementById('feedSwitcherOptions');
                const feedSwitcherCurrent = document.querySelector('.feed-switcher-current');
                const feedIcon = document.getElementById('feedDropdownIcon');

                if (feedDropdown && feedDropdown.classList.contains('active')) {
                    if ((!feedSwitcherCurrent || !feedSwitcherCurrent.contains(e.target)) && !feedDropdown.contains(e.target)) {
                        feedDropdown.classList.remove('active');
                        if (feedIcon) feedIcon.style.transform = 'rotate(0deg)';
                    }
                }
            });

        }
        // Intersection Observer for video autoplay
        function setupIntersectionObserver() {
            const options = {
                root: document.getElementById('feed'),
                rootMargin: '0px',
                threshold: 0.6 // Only trigger when 60% of the video is visible
            };
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const video = entry.target.querySelector('.video-player');
                  
                    if (entry.isIntersecting) {
                        currentVideoId = entry.target.id; // Store the current video's container ID
                        // Try to play with sound first
                        video.muted = false;
                        const playPromise = video.play();
                      
                        if (playPromise !== undefined) {
                            playPromise.catch(error => {
                                // If autoplay with sound fails, mute and try again
                                video.muted = true;
                                video.play().catch(e => console.log('Autoplay prevented:', e));
                            });
                        }
                        // Add class for visible animation
                        entry.target.querySelector('.video-player').style.transform = 'scale(1)';
                        entry.target.querySelector('.video-player').style.opacity = '1';
                    } else {
                        video.pause();
                        // video.currentTime = 0; // Don't reset video to the beginning
                        if (currentVideoId === entry.target.id) {
                            currentVideoId = null;
                        }
                        // Add class for scrolled-away animation
                        entry.target.querySelector('.video-player').style.transform = 'scale(0.9)';
                        entry.target.querySelector('.video-player').style.opacity = '0.7';
                    }
                });
            }, options);
          
            // Observe all video containers
            document.querySelectorAll('.video-container').forEach(container => {
                observer.observe(container);
            });
        }
        // Handle browser tab visibility changes
        function handleVisibilityChange() {
            if (!currentVideoId) return;

            const currentVideoContainer = document.getElementById(currentVideoId);
            if (!currentVideoContainer) return;

            const video = currentVideoContainer.querySelector('video');
            if (document.hidden) {
                video.pause();
            } else {
                video.play().catch(e => console.log('Autoplay on visibility change prevented:', e));
            }
        }
        // Toggle theme between dark and light
        function toggleTheme() {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', currentTheme);
            localStorage.setItem('theme', currentTheme); // Save the theme preference
        }
        // Create like animation on double tap
        function createLikeAnimation(event) {
            const likeAnimation = document.createElement('div');
            likeAnimation.className = 'like-animation';
            likeAnimation.innerHTML = `
                <svg width="80" height="80" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>
                </svg>
            `;
          
            // Position the animation at the tap location
            likeAnimation.style.left = `${event.clientX}px`;
            likeAnimation.style.top = `${event.clientY}px`;
          
            document.body.appendChild(likeAnimation);
          
            // Remove animation after it completes
            setTimeout(() => {
                likeAnimation.remove();
            }, 1000);
        }
        // Toggle like status
        async function toggleLike(element, videoId) {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
            // Optimistically update the UI
            const likeIcon = document.getElementById(`likeIcon-${videoId}`);
            const likeCount = document.getElementById(`likeCount-${videoId}`);
            const svg = likeIcon.querySelector('svg');
            const isCurrentlyLiked = svg.getAttribute('fill') === 'currentColor';

            // Add the popping animation to the icon
            likeIcon.classList.add('popping');
            likeIcon.addEventListener('animationend', () => {
                likeIcon.classList.remove('popping');
            }, { once: true });

            svg.setAttribute('fill', isCurrentlyLiked ? 'none' : 'currentColor'); // Toggle fill
            likeIcon.style.color = isCurrentlyLiked ? 'currentColor' : 'var(--like-color-active)'; // Use new variable
            likeCount.textContent = parseInt(likeCount.textContent) + (isCurrentlyLiked ? -1 : 1);
            try {
                const { data, error } = await supabase.rpc('toggle_like', { post_id_to_toggle: videoId });
                if (error) throw error;
                // Re-sync UI with the actual state from the database
                likeCount.textContent = data.likes_count;
                if (data.liked) {
                    svg.setAttribute('fill', 'currentColor'); // Liked state
                    likeIcon.style.color = 'var(--like-color-active)'; // Use new variable
                } else {
                    svg.setAttribute('fill', 'none');
                    likeIcon.style.color = 'currentColor';
                }
            } catch (error) {
                console.error('Error toggling like:', error);
                showToast('Error updating like');
                // Revert UI on error by refreshing the feed
                // This is a simple way to handle errors, you could also revert the optimistic update manually
                await fetchPostsFromDatabase();
            } 
        }
        // Share video
        function shareVideo(videoId) {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
          
            // Create a shareable link that works on GitHub Pages
            const videoLink = `${window.location.origin}${window.location.pathname}?videoId=${videoId}`;
          
            // Check if the Web Share API is available
            if (navigator.share) {
                navigator.share({
                    title: 'Check out this video on Skrolz!',
                    text: 'I found this amazing video on Skrolz',
                    url: videoLink,
                })
                .then(() => console.log('Successful share'))
                .catch((error) => {
                    console.log('Error sharing:', error);
                    copyToClipboard(videoLink);
                });
            } else {
                // Fallback: copy to clipboard
                copyToClipboard(videoLink);
            }
        }
        // Copy text to clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Link copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy: ', err);
                showToast('Failed to copy link');
            });
        }
        // Toggle save video
        async function toggleSave(videoId) {
            const saveIcon = document.getElementById(`saveIcon-${videoId}`);
            const svg = saveIcon.querySelector('svg');
            const isSaved = savedPosts.includes(videoId);

            // Optimistic UI update
            if (isSaved) { // It is saved, so we are unsaving it
                savedPosts = savedPosts.filter(id => id !== videoId);
                svg.setAttribute('fill', 'none');
                saveIcon.style.color = 'currentColor';
            } else { // It is not saved, so we are saving it
                savedPosts.push(videoId);
                svg.setAttribute('fill', 'currentColor');
                saveIcon.style.color = 'var(--save-color-active)';
            }

            try {
                const { data: { user } } = await supabase.auth.getUser();
                if (isSaved) {
                    // Delete from saved_posts table
                    const { error } = await supabase.from('saved_posts').delete().match({ user_id: user.id, post_id: videoId });
                    if (error) throw error;
                    showToast('Video removed from saved');
                } else {
                    // Insert into saved_posts table
                    const { error } = await supabase.from('saved_posts').insert({ user_id: user.id, post_id: videoId });
                    if (error) throw error;
                    showToast('Video saved');
                }
            } catch (error) {
                console.error('Error toggling save:', error);
                showToast('Error updating saved videos');
                // Revert UI on error by re-fetching saved posts and re-rendering feed
                await fetchSavedPosts();
                await refreshCurrentFeed(); // Refresh the current feed
                renderTopBar(); // Re-render top bar
            }
        }
        // Show toast notification
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
          
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        // Toggle mute
        function toggleMute(button, videoId) {
            const videoContainer = button.closest('.video-container');
            const video = videoContainer.querySelector('video');
            const volumeSlider = document.getElementById(`volumeSlider-${videoId}`);
            const unmutedIcon = button.querySelector('.volume-icon-unmuted');
            const mutedIcon = button.querySelector('.volume-icon-muted');

            // Toggle slider visibility
            button.parentElement.classList.toggle('slider-visible');

            if (video.muted) {
                video.muted = false;
                // Restore volume to slider's value, or a default if slider is at 0
                let newVolume = parseFloat(volumeSlider.value);
                if (newVolume === 0) {
                    newVolume = 0.5; // Default volume if unmuting from 0
                    volumeSlider.value = newVolume;
                }
                video.volume = newVolume;
                unmutedIcon.style.display = 'block';
                mutedIcon.style.display = 'none';
            } else {
                video.muted = true;
                unmutedIcon.style.display = 'none';
                mutedIcon.style.display = 'block';
            }
        }
        // Update mute icon based on volume level
        function updateMuteIcon(video, button) {
            // This function can be expanded to show different icons for low/high volume
        }
        // Open comments drawer
        function openComments(videoId) {
            const drawer = document.getElementById(`commentDrawer-${videoId}`);
            const commentsList = document.getElementById(`commentsList-${videoId}`);

            // Clear previous comments
            commentsList.innerHTML = '';

            // Load comments for this video
            loadComments(videoId, commentsList);

            // Open drawer
            drawer.classList.add('open');
            isCommentDrawerOpen = true;

            // FIX: Disable scroll-snap when comment drawer is open
            document.getElementById('feed').classList.add('no-snap');
        }
        // Load comments
        async function loadComments(videoId, commentsList) {
            // Show skeleton loader for comments
            let skeletonHTML = '';
            const commentSkeleton = `
                <div class="skeleton-comment">
                    <div class="skeleton-avatar" style="width: 32px; height: 32px; flex-shrink: 0;"></div>
                    <div class="skeleton-comment-content">
                        <div class="skeleton-line" style="width: 100px; height: 0.8rem;"></div>
                        <div class="skeleton-line" style="width: 90%; height: 1rem;"></div>
                        <div class="skeleton-line" style="width: 60%; height: 1rem;"></div>
                    </div>
                </div>
            `;
            
            for (let i = 0; i < 5; i++) { // Display 5 skeleton items
                skeletonHTML += commentSkeleton;
            }
            commentsList.innerHTML = skeletonHTML;

            try {
                const { data: { user } } = await supabase.auth.getUser();
                const { data: comments, error } = await supabase
                    .from('comments') // Fetch profile_photo for commenter
                    .select(`*, profiles:user_id(username, profile_photo), parent_comment:parent_comment_id(profiles:user_id(username))`)
                    .eq('post_id', videoId)
                    .order('created_at', { ascending: true });
                if (error) throw error;
                commentsList.innerHTML = '';
                if (!comments || comments.length === 0) {
                    if (!isLoggedIn) {
                        commentsList.innerHTML = `
                            <div class="guest-comment-message">
                                <span>No comments yet. Log in to add one!</span>
                                <button onclick="showGuestLoginModal()">Join/Login</button>
                            </div>
                        `;
                    } else {
                        commentsList.innerHTML = '<div style="text-align: center; padding: 1rem;">No comments yet</div>';
                    }
                    return;
                }
                // Build a tree structure for comments and replies
                const commentMap = {};
                const rootComments = [];
                comments.forEach(comment => { // Ensure user is defined for is_liked check
                    comment.replies = [];
                    commentMap[comment.id] = comment;
                    if (comment.parent_comment_id) {
                        if (commentMap[comment.parent_comment_id]) {
                            commentMap[comment.parent_comment_id].replies.push(comment);
                        }
                    } else {
                        rootComments.push(comment);
                        // Ensure user_reaction is an array before using .find()
                        comment.user_reaction_type = user && Array.isArray(comment.user_reaction) ? comment.user_reaction.find(r => r.user_id === user.id)?.reaction_type : null;
                    }
                });
                // Render comments and their replies
                for (const comment of rootComments) {
                    await renderComment(comment, commentsList, 0, videoId);
                }
            } catch (error) {
                console.error('Error loading comments:', error);
                commentsList.innerHTML = '<div style="text-align: center; padding: 1rem;">Error loading comments</div>';
            }
        }
        // Render a single comment and its replies recursively
        async function renderComment(comment, parentElement, depth, videoId) {
            const { data: { user } } = await supabase.auth.getUser();
            const commentItem = document.createElement('div');
            commentItem.className = 'comment-item';
            commentItem.id = `comment-item-${comment.id}`; // Add a unique ID to the comment container
            commentItem.style.marginLeft = `${depth * 20}px`; // Indent replies
            if (user && comment.user_id === user.id) {
                commentItem.classList.add('current-user');
                commentItem.classList.remove('other-user'); // Ensure only one class
            } else {
                commentItem.classList.add('other-user');
                commentItem.classList.remove('current-user'); // Ensure only one class
            }
            const parentUsername = comment.parent_comment?.profiles?.username;
            const username = comment.profiles ? comment.profiles.username : 'user';
            const profilePhoto = comment.profiles ? comment.profiles.profile_photo : null;
            const initials = (username || 'U').substring(0, 2).toUpperCase();

            const avatarImgHtml = profilePhoto
                ? `<img src="${profilePhoto}" style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover; flex-shrink: 0;">`
                : `<div class="comment-avatar-initials">${initials}</div>`;

            const avatarHtml = `<a href="profile.html?userId=${comment.user_id}" style="text-decoration: none; color: inherit;">${avatarImgHtml}</a>`;

            // Build the HTML for the main comment part
            let commentHtml = `
                ${parentUsername ? `<div class="reply-info">Replying to @${parentUsername}</div>` : ''}
                <div class="comment-header-line">
                    ${avatarHtml}
                    <div style="display: flex; flex-direction: column;">
                        <div class="comment-info">
                            <div class="comment-user">@${username}</div>
                            <div class="comment-time">${new Date(comment.created_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                        </div>
                        <div class="comment-text">${comment.content}</div>
                    </div>
                </div>
                <div class="comment-actions">
                    <div class="comment-reaction-btn" onclick="showReactionPicker('${comment.id}', this)">
                        <i class="far fa-smile"></i> React
                    </div>
                    <div class="reaction-summary" id="reaction-summary-${comment.id}">
                    </div>
                    <span class="reply-btn" data-video-id="${videoId}" data-comment-id="${comment.id}" data-username="${username}">Reply</span>`;
            // Add replies count if there are replies
            if (comment.replies && comment.replies.length > 0) {
                commentHtml += `<span class="replies-count replies-count-toggle" data-comment-id="${comment.id}" data-reply-count="${comment.replies.length}">${comment.replies.length} ${comment.replies.length > 1 ? 'replies' : 'reply'}</span>`;
            }
           commentHtml += `</div>`;
            commentItem.innerHTML = commentHtml;
            parentElement.appendChild(commentItem);
            // Update reactions UI
            await updateCommentReactionsUI(comment.id);
            // If there are replies, create a container for them and render them there
            // Add a click listener to the reaction summary to show who reacted.
            // We use an onclick attribute here because the element is created dynamically.
            // The showWhoReacted function is attached to the window object to make it accessible.
            const reactionSummary = commentItem.querySelector('.reaction-summary');
            if (reactionSummary) reactionSummary.setAttribute('onclick', `showWhoReacted('${comment.id}')`);

            if (comment.replies && comment.replies.length > 0) {
                const repliesContainer = document.createElement('div');
                repliesContainer.className = 'replies-container';
                repliesContainer.id = `repliesContainer-${comment.id}`;
                repliesContainer.style.display = 'none'; // Initially hidden
                commentItem.appendChild(repliesContainer); // Append to the current comment item
                for (const reply of comment.replies) {
                    await renderComment(reply, repliesContainer, depth + 1, videoId);
                }
            }
            // Attach event listeners programmatically
            const replyBtn = commentItem.querySelector('.reply-btn');
            if (replyBtn) {
                replyBtn.addEventListener('click', () => {
                    if (!isLoggedIn) {
                        showGuestLoginModal();
                        return;
                    }
                    startReply(replyBtn.dataset.videoId, replyBtn.dataset.commentId, replyBtn.dataset.username);
                });
            }
            const repliesCountToggle = commentItem.querySelector('.replies-count-toggle');
            if (repliesCountToggle) {
                repliesCountToggle.addEventListener('click', () => {
                    toggleReplies(repliesCountToggle.dataset.commentId);
                });
            }
        }

        // NEW: Function to show who reacted to a comment
        async function showWhoReacted(commentId) {
            const modal = document.getElementById('whoReactedModal');
            const list = document.getElementById('whoReactedList');
            const title = document.getElementById('whoReactedModalTitle');

            if (!modal || !list || !title) return;

            // Show modal with a loading state
            title.textContent = 'Reactions';
            list.innerHTML = '<div>Loading...</div>';
            modal.style.display = 'block';

            try {
                const { data, error } = await supabase
                    .from('comment_reactions')
                    .select(`
                        reaction_type,
                        profiles ( username, profile_photo )
                    `)
                    .eq('comment_id', commentId);

                if (error) throw error;

                if (data.length === 0) {
                    list.innerHTML = '<div>No reactions yet.</div>';
                    return;
                }

                list.innerHTML = data.map(reaction => `
                    <div class="reaction-user-item">
                        <img src="${reaction.profiles.profile_photo || ''}" class="reaction-user-avatar" alt="${reaction.profiles.username}'s avatar">
                        <div class="reaction-user-info">
                            <div class="reaction-user-name">@${reaction.profiles.username}</div>
                        </div>
                        <div class="reaction-emoji">${reaction.reaction_type}</div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error fetching who reacted:', error);
                list.innerHTML = '<div>Could not load reactions.</div>';
            }
        }

        // Toggle visibility of replies
        function toggleReplies(commentId) {
            const repliesContainer = document.getElementById(`repliesContainer-${commentId}`);
            const repliesCountSpan = document.querySelector(`.replies-count-toggle[data-comment-id="${commentId}"]`); // Find the span by its data attribute
          
            if (repliesContainer && repliesCountSpan) {
                const currentReplyCount = repliesCountSpan.dataset.replyCount; // Get original count from data attribute
              
                if (repliesContainer.style.display === 'none') {
                    repliesContainer.style.display = 'block';
                    repliesCountSpan.textContent = `Hide replies`;
                } else {
                    repliesContainer.style.display = 'none';
                    repliesCountSpan.textContent = `${currentReplyCount} ${currentReplyCount > 1 ? 'replies' : 'reply'}`;
                }
            }
        }
        // Close comments drawer
        function closeComments(videoId) {
            const drawer = document.getElementById(`commentDrawer-${videoId}`);
            drawer.classList.remove('open');
            isCommentDrawerOpen = false;
            // Re-enable scroll-snap
            document.getElementById('feed').classList.remove('no-snap');
        }
        // Global variable to track the currently open reaction picker
        let openReactionPicker = null;
        // Function to show the reaction picker
        function showReactionPicker(commentId, triggerElement) {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
            // Close any other open reaction picker
            if (openReactionPicker && openReactionPicker.id !== `reactionPicker-${commentId}`) {
                openReactionPicker.classList.remove('active');
            }
            let reactionPicker = document.getElementById(`reactionPicker-${commentId}`);
            if (!reactionPicker) {
                // Create the reaction picker if it doesn't exist
                reactionPicker = document.createElement('div');
                reactionPicker.className = 'reaction-picker';
                reactionPicker.id = `reactionPicker-${commentId}`;
                reactionPicker.innerHTML = `
                    <span class="reaction-option" data-reaction-type="üëç">üëç</span>
                    <span class="reaction-option" data-reaction-type="‚ù§Ô∏è">‚ù§Ô∏è</span>
                    <span class="reaction-option" data-reaction-type="üòÇ">üòÇ</span>
                    <span class="reaction-option" data-reaction-type="üî•">üî•</span>
                    <span class="reaction-option" data-reaction-type="ü§Ø">ü§Ø</span>
                    <span class="reaction-option" data-reaction-type="üëè">üëè</span>
                    <span class="reaction-option" data-reaction-type="ü§î">ü§î</span>
                    <span class="reaction-option" data-reaction-type="ü•∞">ü•∞</span>
                    <span class="reaction-option" data-reaction-type="üôè">üôè</span>
                    <span class="reaction-option" data-reaction-type="üéâ">üéâ</span>
                `;
                triggerElement.appendChild(reactionPicker);
                // Attach event listeners to reaction options
                reactionPicker.querySelectorAll('.reaction-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        const reactionType = e.currentTarget.dataset.reactionType;
                        toggleCommentReaction(commentId, reactionType);
                        reactionPicker.classList.remove('active');
                        openReactionPicker = null;
                    });
                });
            }
            // Toggle visibility
            reactionPicker.classList.toggle('active');
            openReactionPicker = reactionPicker.classList.contains('active') ? reactionPicker : null;
            // Close picker if clicking outside
            document.addEventListener('click', function closePickerOnClickOutside(event) {
                if (openReactionPicker && !reactionPicker.contains(event.target) && !triggerElement.contains(event.target)) {
                    reactionPicker.classList.remove('active');
                    openReactionPicker = null;
                    document.removeEventListener('click', closePickerOnClickOutside);
                }
            });
        }
        // Function to update the UI with new reaction counts
        async function updateCommentReactionsUI(commentId) {
            const reactionSummaryDisplay = document.getElementById(`reaction-summary-${commentId}`);
            // If the comment ID is temporary (from an optimistic update), don't query the DB.
            if (typeof commentId === 'string' && commentId.startsWith('temp-')) {
                if (reactionSummaryDisplay) reactionSummaryDisplay.innerHTML = ''; // Ensure it's empty
                return;
            }

            if (!reactionSummaryDisplay) return;
            const { data: reactions, error } = await supabase
                .from('comment_reactions')
                .select('reaction_type, user_id')
                .eq('comment_id', commentId);
            if (error) {
                console.error('Error fetching reactions:', error);
                return;
            }
            const { data: { user } } = await supabase.auth.getUser();
            const currentUserId = user ? user.id : null;
            const reactionsSummary = {};
            let userReactionType = null;
            reactions.forEach(reaction => {
                reactionsSummary[reaction.reaction_type] = (reactionsSummary[reaction.reaction_type] || 0) + 1;
                if (currentUserId && reaction.user_id === currentUserId) {
                    userReactionType = reaction.reaction_type;
                }
            });
            reactionSummaryDisplay.innerHTML = ''; // Clear existing reactions
            for (const reactionType in reactionsSummary) {
                const count = reactionsSummary[reactionType];
                if (count > 0) {
                    const reactionItem = document.createElement('span');
                    reactionItem.className = `reaction-summary-item ${userReactionType === reactionType ? 'user-reacted' : ''}`;
                    reactionItem.dataset.reactionType = reactionType;
                    reactionItem.dataset.commentId = commentId;
                    reactionItem.innerHTML = `${reactionType} ${count}`;
                    reactionSummaryDisplay.appendChild(reactionItem);
                }
            }
        }
        // Toggle reaction for comments
        async function toggleCommentReaction(commentId, reactionType) {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
          
            try {
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) throw new Error('User not found');
              
                // Call the RPC function
                const { error } = await supabase.rpc('toggle_comment_reaction', {
                    p_comment_id: commentId,
                    p_user_id: user.id,
                    p_reaction_type: reactionType
                });
              
                if (error) throw error;
              
                // After toggling, refresh the reactions for that comment
                await updateCommentReactionsUI(commentId);
              
                // Close the picker
                const picker = document.getElementById(`reactionPicker-${commentId}`);
                if (picker) picker.classList.remove('active');
                openReactionPicker = null;
            } catch (error) {
                console.error('Error toggling comment reaction:', error);
                showToast('Error updating comment reaction');
            }
        }
        // Add a new comment
        async function addComment(videoId) {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
          
            if (isAddingComment) return; // Prevent double submission if already processing
            isAddingComment = true; // Set flag
            const commentInput = document.getElementById(`commentInput-${videoId}`);
            if (!commentInput) {
                console.error(`Error: Comment input element with ID 'commentInput-${videoId}' not found.`);
                isAddingComment = false; // Reset flag
                return;
            }
            const commentText = commentInput.value.trim();
          
            if (!commentText) return;
          
            try {
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) throw new Error('User not found');
                commentInput.disabled = true; // Disable input to prevent further interaction
                // Call the new RPC function to insert comment and increment count
                const { data: result, error: rpcError } = await supabase.rpc('insert_comment_and_increment', {
                    v_post_id: videoId,
                    v_user_id: user.id,
                    v_content: commentText,
                    v_parent_comment_id: replyingToCommentId // Pass the parent comment ID
                });

                if (rpcError) {
                    throw rpcError;
                }
                // Update the comment count on the UI from the function's return value
                const newCountValue = Array.isArray(result) ? result[0] : result;
                if (newCountValue && newCountValue.updated_comments_count != null) {
                    document.getElementById(`commentCount-${videoId}`).textContent = String(newCountValue.updated_comments_count);
                }

                const tempId = `temp-${Date.now()}`; // Store temp ID for later
                // Clear input
                commentInput.value = '';
                cancelReply(videoId); // Clear reply state
                // Optimistically render the new comment without a full reload
                const commentsList = document.getElementById(`commentsList-${videoId}`);
                const newComment = {
                    id: tempId, // Use the stored temporary ID
                    post_id: videoId,
                    user_id: user.id,
                    content: commentText,
                    created_at: new Date().toISOString(),
                    parent_comment_id: replyingToCommentId,
                    profiles: {
                        username: currentUserProfile?.username || user.email.split('@')[0],
                        profile_photo: currentUserProfile?.profile_photo || null
                    },
                    replies: []
                };
                // If it's a reply, find the parent and append it there. Otherwise, append to the main list.
                if (replyingToCommentId) {
                    let parentContainer = document.getElementById(`repliesContainer-${replyingToCommentId}`);
                    if (!parentContainer) {
                        // If replies container doesn't exist, we might need to create it or just reload.
                        // For simplicity, we'll just reload in this edge case.
                        await loadComments(videoId, commentsList);
                    } else {
                        await renderComment(newComment, parentContainer, 1, videoId);
                        parentContainer.style.display = 'block'; // Ensure replies are visible
                    }
                } else {
                    await renderComment(newComment, commentsList, 0, videoId);
                }
                commentsList.scrollTop = commentsList.scrollHeight; // Scroll to the new comment
              
                // ** SWAP TEMPORARY ID WITH REAL ID FROM DATABASE **
                if (newCountValue && newCountValue.new_comment_id) {
                    const realId = newCountValue.new_comment_id;
                    const tempCommentElement = document.getElementById(`comment-item-${tempId}`);
                    if (tempCommentElement) {
                        // Update the main element's ID
                        tempCommentElement.id = `comment-item-${realId}`;

                        // Update IDs of child elements that depend on the comment ID
                        tempCommentElement.querySelector(`#reaction-summary-${tempId}`).id = `reaction-summary-${realId}`;
                        // You can add more selectors here for other elements like reply buttons if they also have dynamic IDs

                        // Now that the ID is real, fetch the (empty) reactions UI.
                        await updateCommentReactionsUI(realId);
                    }
                }

                showToast('Comment added');
                commentInput.disabled = false; // Re-enable input
                isAddingComment = false; // Reset flag
            } catch (error) {
                console.error('Error adding comment:', error);
                showToast('Error adding comment');
                commentInput.disabled = false; // Re-enable input on error
                isAddingComment = false; // Reset flag on error
            }
        }
        // Start a reply to a specific comment
        function startReply(videoId, commentId, username) {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
            replyingToCommentId = commentId;
            const replyIndicator = document.getElementById(`replyIndicator-${videoId}`);
            const replyingToUser = document.getElementById(`replyingToUser-${videoId}`);
            const commentInput = document.getElementById(`commentInput-${videoId}`);
            replyingToUser.textContent = `@${username}`;
            replyIndicator.style.display = 'flex';
            commentInput.focus();
        }
        // Cancel the current reply
        function cancelReply(videoId) {
            replyingToCommentId = null;
            const replyIndicator = document.getElementById(`replyIndicator-${videoId}`);
            replyIndicator.style.display = 'none';
        }
        // Delete post (only for user's own posts)
        async function deletePost(videoId) {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
          
            if (confirm('Are you sure you want to delete this post?')) {
                try {
                    // Remove from UI
                    const videoContainer = document.getElementById(`video-${videoId}`);
                    videoContainer.remove();
                  
                    showToast('Post deleted');
                } catch (error) {
                    console.error('Error deleting post:', error);
                    showToast('Error deleting post');
                }
            }
        }
        // Auto-grow textarea
        function autoGrow(element) {
            element.style.height = "5px";
            element.style.height = (element.scrollHeight) + "px";
        }
        // Go to dashboard function
        function goToDashboard() {
            // Redirect to dashboard page
            window.location.href = 'dashboard.html';
            // If you don't have a dashboard page, you can use:
            // window.location.href = '/'; // for home page
            // or show a message
            // showToast('Redirecting to dashboard...');
        }
        // Open upload modal
        function openUploadModal() {
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
          
            document.getElementById('uploadModal').classList.add('active');
        }
        // Show upload form based on type (upload or camera)
        function showUploadForm(type) {
            document.getElementById('uploadOptions').style.display = 'none';
            document.getElementById('uploadForm').classList.add('active');
          
            if (type === 'camera') {
                // Show camera interface
                document.getElementById('cameraContainer').style.display = 'block';
                document.getElementById('recordingControls').style.display = 'flex';
                document.getElementById('uploadGallerySection').style.display = 'none';
                startCamera();
            } else {
                // Show file upload interface
                document.getElementById('uploadGallerySection').style.display = 'block';
                document.getElementById('cameraContainer').style.display = 'none';
                document.getElementById('recordingControls').style.display = 'none';
                stopCamera();
            }
          
            // Enable upload button if title is filled
            checkUploadButton();
        }
        // Hide upload form
        function hideUploadForm() {
            document.getElementById('uploadForm').classList.remove('active');
            document.getElementById('uploadOptions').style.display = 'flex';
            document.getElementById('uploadModal').classList.remove('active');
          
            // Clear form and reset state
            document.getElementById('postTitle').value = '';
            document.getElementById('postCaption').value = '';
            document.getElementById('postHashtags').value = '';
            document.getElementById('videoFile').value = '';
            document.getElementById('videoPreviewContainer').classList.remove('active');
            document.getElementById('uploadSubmitBtn').disabled = true;
          
            // Stop camera and recording
            stopRecording();
            stopCamera();
          
            selectedVideoFile = null;
            selectedVideoDuration = null;
        }
        // Start camera
        async function startCamera() {
            try {
                // Try to get user media with different constraints for better compatibility
                const constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    },
                    audio: true
                };
              
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                const cameraPreview = document.getElementById('cameraPreview');
                if (cameraPreview) {
                    cameraPreview.srcObject = mediaStream;
                }
            } catch (error) {
                console.error('Error accessing camera:', error);
                showToast('Error accessing camera. Please check permissions.');
                // Fallback to upload form if camera fails
                showUploadForm('upload');
            }
        }
        // Stop camera
        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
        }
        // Start recording
        function startRecording() {
            if (!mediaStream) {
                showToast('Camera not available');
                return;
            }
          
            recordedChunks = [];
          
            try {
                // Try different MIME types for better compatibility
                const options = { mimeType: 'video/webm; codecs=vp9,opus' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm; codecs=vp8,opus';
                }
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm';
                }
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/mp4';
                }
              
                mediaRecorder = new MediaRecorder(mediaStream, options);
              
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
              
                mediaRecorder.onstop = () => {
                    if (recordedChunks.length === 0) {
                        showToast('No video data recorded');
                        return;
                    }
                  
                    const blob = new Blob(recordedChunks, { type: recordedChunks[0].type });
                  
                    // Validate the blob before creating object URL
                    if (!blob || blob.size === 0) {
                        showToast('Recorded video is empty or invalid');
                        return;
                    }
                  
                    selectedVideoFile = new File([blob], 'recorded-video.webm', { type: blob.type });
                  
                    // Show preview
                    const videoPreviewContainer = document.getElementById('videoPreviewContainer');
                    const videoPreview = document.getElementById('videoPreview');
                    const videoFilename = document.getElementById('videoFilename');
                    const videoDuration = document.getElementById('videoDuration');
                  
                    if (videoPreview) {
                        try {
                            const validation = validateFileForObjectURL(blob);
                            if (!validation.valid) {
                                showToast(validation.error || 'Invalid video file');
                                return;
                            }
                          
                            const objectUrl = URL.createObjectURL(blob);
                            videoPreview.src = objectUrl;
                          
                            // Clean up on error
                            videoPreview.onerror = function() {
                                URL.revokeObjectURL(objectUrl);
                                showToast('Error processing recorded video');
                            };
                        } catch (error) {
                            console.error('Error creating object URL for recording:', error);
                            showToast('Error processing recorded video');
                            return;
                        }
                    }
                  
                    if (videoPreviewContainer) {
                        videoPreviewContainer.classList.add('active');
                    }
                    if (videoFilename) {
                        videoFilename.textContent = 'Recorded Video';
                    }
                  
                    // Check duration
                    if (videoPreview) {
                        videoPreview.onloadedmetadata = () => {
                            selectedVideoDuration = videoPreview.duration;
                            const minutes = Math.floor(selectedVideoDuration / 60);
                            const seconds = Math.floor(selectedVideoDuration % 60);
                            if (videoDuration) {
                                videoDuration.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                            }
                          
                            if (selectedVideoDuration > 120) {
                                showToast('Video must be 120 seconds or less');
                                document.getElementById('uploadSubmitBtn').disabled = true;
                            } else {
                                checkUploadButton();
                            }
                        };
                    }
                  
                    // Update UI
                    const recordBtn = document.getElementById('recordBtn');
                    if (recordBtn) {
                        recordBtn.classList.remove('recording');
                        recordBtn.textContent = '‚óè';
                    }
                    isRecording = false;
                };
              
                mediaRecorder.start();
                isRecording = true;
              
                // Update UI
                const recordBtn = document.getElementById('recordBtn');
                if (recordBtn) {
                    recordBtn.classList.add('recording');
                    recordBtn.textContent = '‚ñ†';
                }
              
                // Auto-stop after 120 seconds
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        stopRecording();
                    }
                }, 120000);
              
            } catch (error) {
                console.error('Error starting recording:', error);
                showToast('Error starting recording');
            }
        }
        // Stop recording
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }
        // Handle file selection
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
          
            // Check if file is a video
            if (!file.type.startsWith('video/')) {
                showToast('Please select a video file');
                document.getElementById('uploadSubmitBtn').disabled = true;
                return;
            }
          
            // File size validation (100MB limit)
            if (file.size > 100 * 1024 * 1024) {
                showToast('Video file must be less than 100MB');
                document.getElementById('uploadSubmitBtn').disabled = true;
                return;
            }
          
            // Validate file before processing
            const validation = validateFileForObjectURL(file);
            if (!validation.valid) {
                showToast(validation.error || 'Invalid video file');
                document.getElementById('uploadSubmitBtn').disabled = true;
                return;
            }
          
            selectedVideoFile = file;
          
            // Show preview
            const videoPreviewContainer = document.getElementById('videoPreviewContainer');
            const videoPreview = document.getElementById('videoPreview');
            const videoFilename = document.getElementById('videoFilename');
            const videoDuration = document.getElementById('videoDuration');
          
            if (videoPreview) {
                try {
                    const objectUrl = URL.createObjectURL(file);
                    videoPreview.src = objectUrl;
                  
                    // Clean up the object URL when video loads or on error
                    videoPreview.onload = function() {
                        // Don't revoke immediately if we need to keep it for preview
                        // URL.revokeObjectURL(objectUrl);
                    };
                  
                    videoPreview.onerror = function() {
                        URL.revokeObjectURL(objectUrl);
                        showToast('Error loading video file');
                        document.getElementById('uploadSubmitBtn').disabled = true;
                    };
                } catch (error) {
                    console.error('Error creating object URL:', error);
                    showToast('Error loading video file');
                    document.getElementById('uploadSubmitBtn').disabled = true;
                    return;
                }
            }
          
            if (videoPreviewContainer) {
                videoPreviewContainer.classList.add('active');
            }
            if (videoFilename) {
                videoFilename.textContent = file.name;
            }
          
            // Check duration
            if (videoPreview) {
                videoPreview.onloadedmetadata = function() {
                    selectedVideoDuration = videoPreview.duration;
                    const minutes = Math.floor(selectedVideoDuration / 60);
                    const seconds = Math.floor(selectedVideoDuration % 60);
                    if (videoDuration) {
                        videoDuration.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                  
                    if (selectedVideoDuration > 120) {
                        showToast('Video must be 120 seconds or less');
                        document.getElementById('uploadSubmitBtn').disabled = true;
                    } else {
                        // Enable upload button if video is valid
                        checkUploadButton();
                    }
                };
              
                videoPreview.onerror = function() {
                    showToast('Error loading video file');
                    document.getElementById('uploadSubmitBtn').disabled = true;
                    clearSelectedVideo(); // Clear the invalid file
                };
            }
          
            // Immediately check if we have a valid file (even before metadata loads)
            checkUploadButton();
        }
        // Clear selected video from the upload form
        function clearSelectedVideo() {
            selectedVideoFile = null;
            selectedVideoDuration = null;
          
            const videoFileInput = document.getElementById('videoFile');
            if (videoFileInput) videoFileInput.value = '';
          
            const videoPreviewContainer = document.getElementById('videoPreviewContainer');
            if (videoPreviewContainer) videoPreviewContainer.classList.remove('active');
          
            const videoPreview = document.getElementById('videoPreview');
            if (videoPreview) videoPreview.src = '';
            checkUploadButton();
        }
        // Check if upload button should be enabled
        function checkUploadButton() {
            const titleInput = document.getElementById('postTitle');
            const title = titleInput ? titleInput.value.trim() : '';
            const hasVideo = selectedVideoFile !== null;
          
            const uploadSubmitBtn = document.getElementById('uploadSubmitBtn');
            if (uploadSubmitBtn) {
                uploadSubmitBtn.disabled = !(title && hasVideo);
            }
        }
        // Submit post
        async function submitPost() {
            const titleInput = document.getElementById('postTitle');
            const captionInput = document.getElementById('postCaption');
            const hashtagsInput = document.getElementById('postHashtags');
          
            const title = titleInput ? titleInput.value.trim() : '';
            const caption = captionInput ? captionInput.value.trim() : '';
            const hashtags = hashtagsInput ? hashtagsInput.value.trim() : '';
          
            if (!title) {
                showToast('Title is required');
                return;
            }
          
            if (!selectedVideoFile) {
                showToast('Please select or record a video');
                return;
            }
          
            const fileToUpload = selectedVideoFile;
            // Close upload modal and show progress
            hideUploadForm();
            await uploadPost(title, caption, hashtags, fileToUpload);
        }
        // Upload post
        async function uploadPost(title, caption, hashtags, fileToUpload) {
            const uploadProgress = document.getElementById('uploadProgress');
            const progressFill = document.getElementById('progressFill');
            const progressStatus = document.getElementById('progressStatus');
          
            if (!isLoggedIn) {
                showGuestLoginModal();
                return;
            }
            const { data: { user } } = await supabase.auth.getUser();
            if (!user) {
                showGuestLoginModal();
                return;
            }
            try {
                // Show upload progress
                if (uploadProgress) {
                    uploadProgress.classList.add('active');
                }
                if (progressStatus) {
                    progressStatus.textContent = 'Processing your video...';
                }
              
                // 1. Upload the video file to Supabase Storage
                const fileExt = fileToUpload.name.split('.').pop();
                const fileName = `${user.id}-${Date.now()}.${fileExt}`;
                const filePath = `videos/${fileName}`;
      
                // The progress callback is not part of the upload method anymore.
                // We can use `await` directly and handle progress with XHR if needed,
                // but for simplicity, we'll show a loading state.
                if (progressStatus) {
                    progressStatus.textContent = 'Uploading...';
                }
                if (progressFill) {
                    progressFill.style.width = '50%'; // Indeterminate progress
                }
      
                const { data: uploadData, error: uploadError } = await supabase.storage
                    .from('Facts')
                    .upload(filePath, fileToUpload, {
                        cacheControl: '3600',
                        upsert: false
                    });
                if (uploadError) {
                    throw uploadError;
                }
                console.log('File uploaded successfully:', uploadData);
      
                if (progressFill) {
                    progressFill.style.width = '100%';
                }
                if (progressStatus) progressStatus.textContent = 'Processing...';
                // 2. Get the public URL of the uploaded file
                const { data: urlData } = supabase.storage.from('Facts').getPublicUrl(filePath);
                const publicUrl = urlData.publicUrl;
                if (!publicUrl) {
                    throw new Error('Could not get public URL for the video.');
                }
                 // 3. Insert the post metadata into the 'posts' table
                const { data: newPost, error: insertError } = await supabase
                    .from('posts')
                    .insert({
                        user_id: user.id,
                        username: user.user_metadata.username || user.email.split('@')[0],
                        content: caption || title,
                        media_url: publicUrl,
                        hashtags: hashtags,
                        title: title
                    }).select().single();
                if (insertError) {
                    throw insertError;
                }

                // --- Create Notifications for Followers ---
                try {
                    // 1. Get followers of the user who posted
                    const { data: followers, error: followersError } = await supabase
                        .from('followers')
                        .select('follower_id')
                        .eq('following_id', user.id);

                    if (followersError) {
                        console.error('Error fetching followers for notification:', followersError);
                    } else if (followers && followers.length > 0) {
                        // 2. Create a notification for each follower
                        const notifications = followers.map(f => ({
                            user_id: f.follower_id, // The person to be notified
                            sender_id: user.id,      // The person who created the post
                            type: 'new_post',
                            content: `@${newPost.username} just added a new post: "${newPost.title}"`,
                            post_id: newPost.id      // Link to the new post
                        }));

                        // 3. Insert all notifications
                        const { error: notificationError } = await supabase.from('notifications').insert(notifications);
                        if (notificationError) {
                            console.error('Error creating new post notifications:', notificationError);
                        }
                    }
                } catch (e) {
                    console.error('An unexpected error occurred while creating notifications:', e);
                }
                // --- End Notification Creation ---

                // 4. Update UI on success
                if (progressStatus) progressStatus.textContent = 'Post created successfully!';
                
                // --- Immediate user feedback ---
                const prefs = currentUserProfile?.notification_preferences || {};
                if (prefs.sound !== false) {
                    playNotificationSound();
                }
                if (prefs.push !== false) {
                    showDesktopNotification('Post Created', { body: `Your post "${newPost.title}" is now live!` });
                }
                // --- End immediate feedback ---

                setTimeout(() => {
                    if (uploadProgress) uploadProgress.classList.remove('active');
                    if (progressFill) progressFill.style.width = '0%';
                    showToast('Video posted successfully!');
                    fetchPostsFromDatabase(); // Refresh the feed
                }, 1000);
            } catch (error) {
                console.error('Error uploading post:', error);
                if (uploadProgress) {
                    uploadProgress.classList.remove('active');
                }
                showToast(`Error uploading post: ${error.message}`);
            }
        }

        // Helper function to escape special characters for ILIKE
        function escapeLike(string) {
            // Escapes backslash, percent, and underscore
            return string.replace(/[\\%_]/g, '\\$&');
        }

        // Perform search and render results
        async function performSearch(query, sortOrder = currentSearchSort) {
            const searchResultsContainer = document.getElementById('searchResults');
            if (!searchResultsContainer) return;

            if (!query) {
                // If query is empty, show trending hashtags instead of a message
                fetchAndRenderTrendingHashtags();
                return;
            }

            searchResultsContainer.innerHTML = '<div style="text-align: center; padding-top: 2rem;">Searching...</div>';

            try {
                // FIX: Escape the user's query to handle special characters like '%', '_', and '\'
                const escapedQuery = escapeLike(query);

                // FIX: Use the new, simplified RPC function 'search_posts' which is more reliable.
                const { data, error } = await supabase
                    .rpc('search_posts', { search_term: escapedQuery })
                    .limit(20); // It's good practice to limit results

                if (error) throw error;

                if (data && data.length > 0) {
                    // The data structure is slightly different, so we need to map it.
                    const formattedData = data.map(post => ({
                        ...post,
                        username: post.username ?? 'unknown' // The view already flattens this
                    }));
                    // The simple search doesn't have a relevance score, so we sort client-side if needed.
                    sortAndRenderResults(formattedData, sortOrder);
                } else {
                    searchResultsContainer.innerHTML = `<div style="text-align: center; opacity: 0.7; padding-top: 2rem;">No results found for "${query}"</div>`;
                }
            } catch (error) {
                console.error('Error performing search:', error);
                searchResultsContainer.innerHTML = '<div style="text-align: center; color: #ff6b6b; padding-top: 2rem;">Error during search.</div>';
            }
        }

        // New function to handle sorting and rendering
        function sortAndRenderResults(results, sortOrder) {
            if (sortOrder === 'likes') {
                results.sort((a, b) => (b.likes_count || 0) - (a.likes_count || 0));
            } else if (sortOrder === 'recent') {
                results.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            }
            // 'relevance' is the default from the DB which is now just 'created_at', so no extra sort is needed.
            
            // Now render the (potentially sorted) results
            renderSearchResults(results);
        }


        // Fetch and render trending hashtags
        async function fetchAndRenderTrendingHashtags() {
            const searchResultsContainer = document.getElementById('searchResults');
            if (!searchResultsContainer) return;

            searchResultsContainer.innerHTML = '<div style="text-align: center; padding-top: 2rem;">Loading trends...</div>';

            try {
                // Call the RPC function we created in Supabase
                const { data, error } = await supabase.rpc('get_trending_hashtags', { limit_count: 15 });

                if (error) throw error;

                if (data && data.length > 0) {
                    renderTrendingHashtags(data);
                } else {
                    searchResultsContainer.innerHTML = '<div style="text-align: center; opacity: 0.7; padding-top: 2rem;">No trending hashtags right now.</div>';
                }
            } catch (error) {
                console.error('Error fetching trending hashtags:', error);
                searchResultsContainer.innerHTML = '<div style="text-align: center; color: #ff6b6b; padding-top: 2rem;">Could not load trends.</div>';
            }
        }

        // Render the trending hashtags UI
        function renderTrendingHashtags(hashtags) {
            const searchResultsContainer = document.getElementById('searchResults');
            const hashtagPills = hashtags.map(tag => 
                `<div class="hashtag-pill" data-hashtag="${tag.hashtag}">${tag.hashtag}</div>`
            ).join('');

            searchResultsContainer.innerHTML = `
                <div class="trending-hashtags-container">
                    <div class="trending-title">üî• Trending Hashtags</div>
                    <div class="hashtags-grid">${hashtagPills}</div>
                </div>
            `;

            // Add event listener for the newly created pills
            searchResultsContainer.querySelectorAll('.hashtag-pill').forEach(pill => {
                pill.addEventListener('click', () => {
                    const searchInput = document.getElementById('searchInput');
                    searchInput.value = pill.dataset.hashtag;
                    performSearch(pill.dataset.hashtag);
                });
            });
        }

        // Render search results
        function renderSearchResults(results) {
            const searchResultsContainer = document.getElementById('searchResults');
            searchResultsContainer.innerHTML = ''; // Clear previous results

            results.forEach(post => {
                const resultItem = document.createElement('div'); // Changed from 'a' to 'div'
                resultItem.className = 'search-result-item';
                resultItem.dataset.videoId = post.id; // Store video ID in a data attribute

                resultItem.innerHTML = `
                    <video class="search-result-thumbnail" src="${post.media_url}#t=1" preload="metadata"></video>
                    <div class="search-result-info">
                        <div class="title">${post.title || 'Untitled Post'}</div>
                        <div class="username">@${post.username || 'user'} &bull; ‚ù§Ô∏è ${post.likes_count || 0}</div>
                    </div>
                `;

                resultItem.addEventListener('click', (e) => {
                    e.preventDefault();
                    navigateToVideo(post.id);
                });

                searchResultsContainer.appendChild(resultItem);
            });
        }

        // New function to handle navigation to a video without a page reload
        async function navigateToVideo(videoId) {
            // 1. Close the search overlay
            document.getElementById('searchOverlay').classList.remove('active');
            document.getElementById('searchIcon').classList.remove('active');

            // 2. Check if the video element already exists in the feed
            let videoElement = document.getElementById(`video-${videoId}`);

            if (videoElement) {
                // 3. If it exists, scroll to it smoothly
                videoElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                // 4. If it doesn't exist, fetch it and prepend it to the feed
                try {
                    showSkeletonLoader(); // Show loading state
                    // Use the logic from handleSharedLink but without a full page reload
                    await handleSharedLink(videoId);

                    // After re-initialization, the element should exist
                    videoElement = document.getElementById(`video-${videoId}`);
                    if (videoElement) {
                        videoElement.scrollIntoView({ behavior: 'auto', block: 'start' });
                    }
                } catch (error) {
                    console.error('Error navigating to video:', error);
                    showToast('Could not load the selected video.');
                    await refreshCurrentFeed(); // Fallback to refreshing the current feed on error
                }
            }

        }

        // Make functions globally available
        window.openUploadModal = openUploadModal;
        window.showUploadForm = showUploadForm;
        window.hideUploadForm = hideUploadForm;
        window.startRecording = startRecording;
        window.stopRecording = stopRecording;
        window.submitPost = submitPost;
        window.toggleLike = toggleLike;
        window.openComments = openComments;
        window.closeComments = closeComments;
        window.addComment = addComment;
        window.shareVideo = shareVideo;
        window.toggleSave = toggleSave;
        window.deletePost = deletePost;
        window.toggleMute = toggleMute;
        window.startReply = startReply;
        window.cancelReply = cancelReply;
        window.autoGrow = autoGrow;
        window.checkUploadButton = checkUploadButton;
        window.handleFileSelect = handleFileSelect;
        window.showReactionPicker = showReactionPicker;
        window.toggleCommentReaction = toggleCommentReaction;
        window.showWhoReacted = showWhoReacted;
        window.updateCommentReactionsUI = updateCommentReactionsUI;
        window.goToDashboard = goToDashboard;
        window.showGuestLoginModal = showGuestLoginModal; // Add this line
        window.toggleProfileDropdown = toggleProfileDropdown;
        window.toggleFeedDropdown = toggleFeedDropdown; // Add this line
        window.logout = logout;
        window.handleGuestAction = handleGuestAction; // Add this line to make the function globally available
        window.toggleTheme = toggleTheme;
    </script>
</body>
</html>