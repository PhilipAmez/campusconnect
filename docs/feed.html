<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Skrolz</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0f0f10;
    --card: #141416;
    --muted: #bfc3cc;
    --accent-1: #7bdff6;
    --accent-2: #2fb3ff;
    --accent: #6a40ff;
    --glass: rgba(255,255,255,0.05);
    --transition: 320ms cubic-bezier(.2,.9,.3,1);
    --blue-aqua: #7bdff6;
    --like-blue: #2fb3ff;
  }
  html.light {
    --bg: #f6f7fa;
    --card: #fff;
    --muted: #374151;
    --glass: rgba(0,0,0,0.03);
  }

  * { box-sizing: border-box }
  html, body {
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  html::-webkit-scrollbar, body::-webkit-scrollbar { display: none; }

  body {
    margin: 0;
    font-family: 'Poppins', sans-serif;
    background: var(--bg);
    color: #fff;
    -webkit-font-smoothing: antialiased;
    transition: background var(--transition), color var(--transition);
    min-height: 100vh;
    overflow-x: hidden;
    scroll-behavior: smooth;
    padding-bottom: env(safe-area-inset-bottom);
  }

  /* HEADER */
  header {
    position: sticky; top: 0; z-index: 40;
    height: 64px; display: flex; align-items: center; justify-content: center;
    background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.05));
    backdrop-filter: blur(8px) saturate(140%);
    border-bottom: 1px solid rgba(255,255,255,0.03);
    transition: background var(--transition), color var(--transition), transform 220ms ease;
    user-select: none;
    touch-action: none;
  }
  html.light header {
    background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.85));
    border-bottom: 1px solid rgba(0,0,0,0.06);
    color: #111;
  }
  .header-inner { text-align: center; pointer-events: none; width: 100%; max-width: 360px; }
  .header-title { font-weight: 700; font-size: 18px; letter-spacing: 0.3px }
  .header-hint { position: absolute; right: 14px; font-size: 13px; opacity: 0.75; pointer-events: none }

  /* AVATAR */
  .avatar {
    width: 32px; height: 32px; border-radius: 50%; 
    background: linear-gradient(135deg, var(--accent), #b473ff);
    display: flex; align-items: center; justify-content: center;
    color: white; font-weight: 600; font-size: 14px; text-transform: uppercase;
  }

  /* SEARCH BAR */
  .search-container {
    position: sticky;
    top: 64px;
    z-index: 39;
    background: var(--bg);
    padding: 8px 16px;
    border-bottom: 1px solid rgba(255,255,255,0.03);
  }
  .search-wrapper {
    max-width: 300px;
    margin: 0 auto;
    display: flex;
    gap: 8px;
    align-items: center;
  }
  #searchBar {
    flex: 1;
    padding: 10px 14px;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 25px;
    background: var(--glass);
    color: inherit;
    font-size: 14px;
    backdrop-filter: blur(8px);
    outline: none;
    transition: all 0.2s ease;
  }
  html.light #searchBar { background: rgba(0,0,0,0.04); border-color: rgba(0,0,0,0.1); }
  #searchBar::placeholder { color: var(--muted); }
  #searchBar:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(106, 64, 255, 0.1);
  }

  /* FEED */
  main#feed {
    padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 28px; padding-bottom: 120px;
    position: relative;
    overflow-y: auto;
    height: calc(100vh - 128px);
    scroll-snap-type: y mandatory;
  }
  #feedContent {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 28px;
    width: 100%;
    transition: transform var(--transition);
    will-change: transform;
  }

  #pullIndicator {
    position: fixed;
    top: 128px;
    left: 50%;
    transform: translateX(-50%) translateY(-100%);
    width: 360px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--glass);
    border-radius: 18px 18px 0 0;
    transition: opacity 0.2s, transform 0.3s;
    opacity: 0;
    z-index: 50;
    pointer-events: none;
  }
  html.light #pullIndicator { background: rgba(0,0,0,0.03); }
  #pullIndicator > div { display: flex; align-items: center; gap: 8px; }
  #pullText { font-size: 13px; color: var(--muted); }
  #pullIcon.refreshing { animation: spin 0.8s linear infinite; }
  @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

  @media (max-width: 420px) {
    #pullIndicator { width: 92vw; }
    .search-wrapper { max-width: 100%; }
    #searchBar { font-size: 16px; }
    .post { width: 92vw; height: 70vh; border-radius: 12px; }
    .icons { right: 6px; bottom: 60px; }
    .drawer.open { height: 40% }
  }

  /* LOADING */
  .loading { display: flex; align-items: center; justify-content: center; height: 100px; font-size: 14px; color: var(--muted); }

  /* CARD / POST */
  .post {
    width: 360px; height: 640px; border-radius: 18px; overflow: visible; position: relative;
    background: var(--card); box-shadow: 0 12px 40px rgba(2,6,23,0.55);
    transition: transform var(--transition), box-shadow var(--transition), background var(--transition);
    will-change: transform;
    touch-action: pan-y;
    scroll-snap-align: start;
  }
  html.light .post { box-shadow: 0 8px 28px rgba(2,6,23,0.06) }
  .post.swiping { transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); }

  .post-inner { width: 100%; height: 100%; border-radius: 18px; overflow: hidden; position: relative; background: var(--card); }
  .post video { width: 100%; height: 100%; object-fit: cover; display: block; }

  .play-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;
    opacity: 0; transition: opacity 200ms ease; z-index: 10; pointer-events: none;
  }
  .post.paused .play-overlay { opacity: 1; pointer-events: auto; }
  .play-icon {
    width: 80px; height: 80px; border-radius: 50%; background: var(--blue-aqua);
    display: flex; align-items: center; justify-content: center; font-size: 32px;
    color: white; opacity: 0.9; box-shadow: 0 4px 20px rgba(123, 223, 246, 0.4);
  }

  .upload-progress {
    position: absolute; top: 0; left: 0; height: 4px; background: rgba(0,0,0,0.3); overflow: hidden; z-index: 15;
  }
  .upload-progress-bar {
    height: 100%; background: linear-gradient(90deg, var(--blue-aqua), var(--accent-2)); width: 0%; transition: width 100ms linear;
  }

  .overlay {
    position: absolute; left: 0; right: 0; bottom: 0; padding: 14px;
    background: linear-gradient(0deg, rgba(0,0,0,0.6), transparent 40%); color: #fff;
    transition: background var(--transition), color var(--transition);
  }
  html.light .overlay { background: linear-gradient(0deg, rgba(255,255,255,0.86), transparent 40%); color: #111; }
  .overlay h3 { margin: 0 0 6px 0; font-size: 14px; font-weight: 600 }
  .overlay p { margin: 0; font-size: 13px; color: var(--muted); }

  .icons {
    position: absolute; right: 10px; bottom: 84px; display: flex; flex-direction: column; gap: 12px; align-items: center; z-index: 22;
  }
  .btn {
    width: 48px; height: 48px; border-radius: 50%; display: flex; align-items: center; justify-content: center; border: none; cursor: pointer;
    background: rgba(255,255,255,0.06); backdrop-filter: blur(8px); color: #fff; font-size: 18px;
    transition: transform 160ms ease, background 160ms, color 160ms;
  }
  .btn:active { transform: scale(.96) }
  html.light .btn { color: #111; background: rgba(0,0,0,0.04) }

  .like-btn.liked {
    background: linear-gradient(135deg, var(--like-blue), #2f8fff);
    color: white;
    box-shadow: 0 0 12px rgba(47, 179, 255, 0.4);
  }

  .like-wrap { display: flex; flex-direction: column; align-items: center; gap: 6px }
  .like-count { font-size: 12px; color: var(--muted); user-select: none }

  .delete-btn { background: rgba(255, 50, 50, 0.2); color: #ff6b6b; }

  .drawer {
    position: absolute; left: 8px; right: 8px; bottom: 8px; height: 0; max-height: 58%;
    border-radius: 14px; overflow: hidden; display: flex; flex-direction: column; align-items: center;
    backdrop-filter: blur(14px) saturate(140%); background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
    border: 1px solid rgba(255,255,255,0.1);
    transition: height 360ms cubic-bezier(.2,.9,.3,1), transform 320ms ease;
    z-index: 26;
    pointer-events: none;
  }
  html.light .drawer { 
    background: linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.03)); 
    color: #111;
    border: 1px solid rgba(0,0,0,0.1);
  }

  .drawer.open { height: 42%; pointer-events: auto; }

  .drawer-inner {
    width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center;
    padding: 12px 12px 8px 12px; gap: 10px; box-sizing: border-box; overflow: auto;
    -webkit-overflow-scrolling: touch; scroll-behavior: smooth;
  }
  .drawer-inner::-webkit-scrollbar { display: none }
  .drawer-inner { -ms-overflow-style: none; scrollbar-width: none }

  .drawer-handle { width: 54px; height: 6px; border-radius: 6px; background: rgba(255,255,255,0.12); margin-top: 6px; }
  html.light .drawer-handle { background: rgba(0,0,0,0.08) }

  .comments-list { display: flex; flex-direction: column; align-items: center; gap: 8px; width: 100%; padding-top: 6px; box-sizing: border-box; }
  .comment { 
    width: 88%; text-align: left; padding: 10px 12px; border-radius: 10px; 
    background: rgba(255,255,255,0.08); color: #ffffff; 
    user-select: none; font-size: 14px; line-height: 1.4;
    border: 1px solid rgba(255,255,255,0.1);
  }
  html.light .comment { 
    background: rgba(0,0,0,0.06); 
    color: #333; 
    border: 1px solid rgba(0,0,0,0.1);
  }

  .drawer-footer { width: 100%; display: flex; justify-content: center; gap: 8px; padding: 8px 0 4px; align-items: center; }
  .comment-input { display: none; width: 84%; }
  .comment-input.active { display: block; }
  .comment-input input { 
    width: 100%; padding: 10px 12px; border-radius: 999px; border: none; outline: none; 
    background: rgba(255,255,255,0.1); color: #fff; font-size: 14px;
  }
  html.light .comment-input input { background: rgba(0,0,0,0.08); color: #111 }
  .send-small { padding: 8px 12px; border-radius: 10px; border: none; background: var(--accent); color: #fff; font-weight: 600; cursor: pointer }

  .heart-hit { 
    position: absolute; pointer-events: none; width: 120px; height: 120px; left: 50%; top: 50%; 
    transform: translate(-50%,-50%); z-index: 30; opacity: 0; transition: opacity 120ms linear; 
  }
  .heart-hit.show { opacity: 1; animation: heart-pop 420ms cubic-bezier(.2,.85,.25,1); }
  @keyframes heart-pop {
    0% { transform: translate(-50%,-50%) scale(.84); opacity: 0; filter: blur(6px) }
    10% { transform: translate(-50%,-50%) scale(1.04); opacity: 1; filter: blur(0) }
    80% { transform: translate(-50%,-50%) scale(1); opacity: 1 }
    100% { transform: translate(-50%,-50%) scale(1); opacity: 0 }
  }

  .fab {
    position: fixed; right: 22px; bottom: 22px; z-index: 40; width: 64px; height: 64px; border-radius: 50%; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center; font-size: 28px;
    background: linear-gradient(135deg, var(--accent), #b473ff); color: #fff;
    box-shadow: 0 14px 40px rgba(100,40,255,0.12); transition: transform 180ms ease;
  }
  .fab:active { transform: scale(.98) }

  #recordModal {
    position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 70;
  }
  #recordModal.show { display: flex; }
  .record-container {
    width: 100%; height: 100%; position: relative; display: flex; flex-direction: column;
  }
  #videoPreview { width: 100%; height: calc(100% - 100px); object-fit: cover; background: black; }
  .record-controls {
    position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; align-items: center;
  }
  .record-btn {
    width: 80px; height: 80px; border-radius: 50%; background: var(--blue-aqua); border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center; font-size: 30px; color: white;
    box-shadow: 0 4px 20px rgba(123, 223, 246, 0.4); transition: transform 0.2s;
  }
  .record-btn.recording { background: #ff4757; transform: scale(1.1); }
  .record-btn:active { transform: scale(0.95); }
  .close-record { position: absolute; top: 20px; right: 20px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; }

  #uploadProgressModal {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 80;
  }
  #uploadProgressModal.show {
    display: flex;
  }
  .progress-box {
    background: var(--card);
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    text-align: center;
    width: 300px;
    max-width: 90vw;
  }
  .progress-bar {
    width: 100%;
    height: 20px;
    background: var(--glass);
    border-radius: 10px;
    overflow: hidden;
    margin: 10px 0;
  }
  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--blue-aqua), var(--accent-2));
    width: 0%;
    transition: width 0.3s ease;
  }
  .progress-text { font-size: 14px; color: var(--muted); }

  /* UPLOAD MODAL STYLES */
  .upload-modal {
    position: fixed; inset: 0; background: rgba(2,6,23,0.45); backdrop-filter: blur(6px) saturate(130%);
    display: none; align-items: center; justify-content: center; z-index: 60;
  }
  .upload-modal.show { display: flex; }
  .upload-content {
    width: min(720px,92vw); padding: 20px; border-radius: 14px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    box-shadow: 0 18px 60px rgba(0,0,0,0.6); color: inherit;
  }

  @media (max-width: 420px) {
    .post { width: 92vw; height: 70vh; }
    .icons { right: 6px; bottom: 60px; }
    .drawer.open { height: 40% }
    .progress-box { width: 90vw; }
  }

  .muted { color: var(--muted); font-size: 13px }
  .center { display: flex; align-items: center; justify-content: center }

  /* BLUE HEART ANIMATION */
  .blue-heart {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 80px; color: var(--like-blue); opacity: 0; z-index: 25; pointer-events: none;
    text-shadow: 0 0 20px rgba(47, 179, 255, 0.6);
  }
  .blue-heart.animate {
    animation: blueHeartPop 0.8s ease-out;
  }
  @keyframes blueHeartPop {
    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
  }
</style>
</head>
<body>
  <header id="header" aria-hidden="false">
    <div class="header-inner">
      <div id="sessionInfo" style="position: absolute; left: 12px; top: 12px; display: flex; align-items: center; gap: 8px; pointer-events: auto">
        <div class="avatar" id="userAvatar">?</div>
      </div>
      <div class="header-title">Skrolz</div>
      <div class="header-hint">Swipe ← / → to toggle theme</div>
    </div>
  </header>

  <div class="search-container">
    <div class="search-wrapper">
      <input type="text" id="searchBar" placeholder="Search posts..." autocomplete="off">
    </div>
  </div>

  <main id="feed" aria-live="polite"></main>

  <button class="fab" id="fab">＋</button>

  <!-- Record Modal -->
  <div id="recordModal">
    <div class="record-container">
      <button class="close-record" id="closeRecord">×</button>
      <video id="videoPreview" autoplay playsinline></video>
      <div class="record-controls">
        <button class="record-btn" id="recordBtnModal">⏺</button>
      </div>
    </div>
  </div>

  <!-- Upload Progress Modal -->
  <div id="uploadProgressModal">
    <div class="progress-box">
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <div class="progress-text" id="progressText">Uploading... 0%</div>
    </div>
  </div>

  <!-- Upload Modal -->
  <div class="upload-modal" id="uploadModal">
    <div class="upload-content">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px">
        <div><strong style="font-size: 18px">Create a Post</strong><div class="muted small" style="margin-top: 6px">Videos must be 60s or less.</div></div>
        <button id="closeUpload" style="background: none; border: none; color: inherit; font-size: 22px; cursor: pointer">×</button>
      </div>
      <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px">
        <input id="uploadTitle" placeholder="Enter title (required)" style="padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); background: var(--glass); color: inherit; outline: none;">
        <textarea id="uploadCaption" placeholder="Enter caption (optional)" style="padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); background: var(--glass); color: inherit; outline: none; resize: none; height: 80px;"></textarea>
      </div>
      <div style="display: flex; gap: 10px; flex-wrap: wrap">
        <button id="recordBtn" style="padding: 12px 14px; border-radius: 12px; border: none; background: linear-gradient(135deg, var(--accent), #b473ff); color: #fff; cursor: pointer; flex: 1">🎥 Record</button>
        <label style="padding: 12px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); display: inline-flex; align-items: center; cursor: pointer; flex: 1; justify-content: center; background: var(--glass);">
          📁 Upload <input id="filePicker" type="file" accept="video/*" style="display: none" />
        </label>
      </div>
    </div>
  </div>

<script type="module">
// Import Supabase client
import { supabase } from './js/supabaseClient.js';
import './js/toast.js';

// Global state
let allPosts = [];
let posts = [];
let currentVideoIndex = 0;
let loadingMore = false;
let searchQuery = '';

// DOM elements
const feed = document.getElementById('feed');
let feedContent;
const progressModal = document.getElementById('uploadProgressModal');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');
const uploadModal = document.getElementById('uploadModal');

// Wait for DOM to be fully loaded
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, initializing Skrolz...');
  initApp();
});

async function initApp() {
  try {
    setupEventListeners();
    setupAuthListener();
    await loadInitialPosts();
    renderFeed();
    setupVerticalSwipe();
    console.log('Skrolz initialized successfully');
  } catch (error) {
    console.error('Failed to initialize app:', error);
  }
}

// Like Manager with persistent likes
class LikeManager {
  constructor() {
    this.likes = JSON.parse(localStorage.getItem('videoLikes') || '{}');
    this.init();
  }

  init() {
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('like-btn')) {
        e.stopPropagation();
        this.handleLike(e.target);
      }
    });
  }

  async handleLike(button) {
    const postId = button.closest('.post').dataset.id;
    const isLiked = this.isLiked(postId);
    const likeCountEl = button.parentElement.querySelector('.like-count');
    const post = allPosts.find(p => p.id === postId);

    if (isLiked && button.classList.contains('liked')) return;

    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        alert('Please sign in to like videos');
        return;
      }

      if (!isLiked) {
        this.addLike(postId);
        button.classList.add('liked');
        post.liked = true;
        post.likes = (post.likes || 0) + 1;
        likeCountEl.textContent = post.likes;
        showBlueHeart(button.closest('.post'));
        
        // Update in Supabase
        await this.updateLikeInSupabase(postId, true);
      } else {
        this.removeLike(postId);
        button.classList.remove('liked');
        post.liked = false;
        post.likes = Math.max(0, (post.likes || 1) - 1);
        likeCountEl.textContent = post.likes;
        
        // Update in Supabase
        await this.updateLikeInSupabase(postId, false);
      }
      updatePostElement(postId, post);
    } catch (error) {
      console.error('Like error:', error);
    }
  }

  async updateLikeInSupabase(postId, liked) {
    try {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) return;

      if (liked) {
        await supabase.from('likes').insert({
          post_id: postId,
          user_id: session.user.id
        });
      } else {
        await supabase.from('likes').delete()
          .eq('post_id', postId)
          .eq('user_id', session.user.id);
      }
    } catch (error) {
      console.error('Error updating like in Supabase:', error);
    }
  }

  isLiked(videoId) {
    return this.likes[videoId] === true;
  }

  addLike(videoId) {
    this.likes[videoId] = true;
    this.saveLikes();
  }

  removeLike(videoId) {
    delete this.likes[videoId];
    this.saveLikes();
  }

  saveLikes() {
    localStorage.setItem('videoLikes', JSON.stringify(this.likes));
  }
}

const likeManager = new LikeManager();

// Avatar and session management
const sessionInfoEl = document.getElementById('sessionInfo');
const userAvatar = document.getElementById('userAvatar');

async function updateSessionInfo() {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      sessionInfoEl.innerHTML = '<div class="avatar">?</div>';
      return null;
    }
    const u = session.user;
    const name = u.user_metadata?.username || u.user_metadata?.full_name || u.email || u.id;
    const initial = name.charAt(0).toUpperCase();
    userAvatar.textContent = initial;
    sessionInfoEl.innerHTML = `<div class="avatar">${initial}</div>`;
    return session;
  } catch (err) {
    console.error('updateSessionInfo error', err);
    sessionInfoEl.innerHTML = '<div class="avatar">!</div>';
    return null;
  }
}

function setupAuthListener() {
  supabase.auth.onAuthStateChange((event, session) => {
    updateSessionInfo().catch(() => {});
  });
}

// Post loading with infinite scroll
async function loadInitialPosts(limit = 10) {
  try {
    await updateSessionInfo();
    const { data: { session } } = await supabase.auth.getSession();
    const currentUserId = session?.user?.id || null;

    // Load posts from Supabase
    const { data, error } = await supabase
      .from('posts')
      .select(`
        id, 
        author_id, 
        author_name, 
        video_url, 
        created_at, 
        title,
        caption,
        likes_count
      `)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error loading posts:', error);
      loadMockData();
      return;
    }

    if (data && data.length > 0) {
      // Load likes for each post
      const postsWithLikes = await Promise.all(data.map(async (post) => {
        const { data: likesData } = await supabase
          .from('likes')
          .select('user_id')
          .eq('post_id', post.id);
        
        const userLiked = likesData?.some(like => like.user_id === currentUserId) || false;
        
        return {
          id: post.id,
          user: post.author_name ? `@${post.author_name}` : `@user_${post.author_id?.slice(0, 8)}`,
          title: post.title || 'Untitled',
          caption: post.caption || '',
          src: post.video_url,
          likes: post.likes_count || likesData?.length || 0,
          comments: [],
          liked: userLiked,
          uploading: false,
          owner: currentUserId && post.author_id === currentUserId,
          paused: false,
        };
      }));

      allPosts = postsWithLikes;
      posts = [...allPosts];
      console.log(`Loaded ${posts.length} posts from Supabase`);
    } else {
      loadMockData();
    }
  } catch (err) {
    console.error('Error loading initial posts:', err);
    loadMockData();
  }
}

function loadMockData() {
  console.log('Loading mock data...');
  allPosts = [
    {
      id: '1',
      user: '@creative_mind',
      title: 'Sunset Vibes 🌅',
      caption: 'Chasing golden hour never gets old',
      src: '',
      likes: 42,
      comments: ['So beautiful!', 'Where was this taken?'],
      liked: false,
      uploading: false,
      owner: false,
      paused: false,
    },
    {
      id: '2', 
      user: '@tech_guru',
      title: 'Coding Session',
      caption: 'Late night coding with some lo-fi beats',
      src: '',
      likes: 18,
      comments: ['What language is this?', 'Great setup!'],
      liked: false,
      uploading: false,
      owner: false,
      paused: false,
    },
    {
      id: '3',
      user: '@adventure_seeker',
      title: 'Mountain Hike',
      caption: 'The view from the top was worth every step',
      src: '',
      likes: 156,
      comments: ['Amazing view!', 'Which mountain is this?'],
      liked: false,
      uploading: false,
      owner: false,
      paused: false,
    }
  ];
  posts = [...allPosts];
}

// Search functionality
const searchBar = document.getElementById('searchBar');

function setupEventListeners() {
  searchBar.addEventListener('input', debounce((e) => {
    searchQuery = e.target.value.toLowerCase();
    filterPosts();
    renderFeed();
  }, 300));

  document.getElementById('fab').addEventListener('click', openUploadModal);
  setupThemeSwipe();
}

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function filterPosts() {
  if (!searchQuery) {
    posts = [...allPosts];
  } else {
    posts = allPosts.filter(post =>
      post.user.toLowerCase().includes(searchQuery) ||
      (post.title && post.title.toLowerCase().includes(searchQuery)) ||
      (post.caption && post.caption.toLowerCase().includes(searchQuery))
    );
  }
}

// Feed rendering with videos
function renderFeed() {
  if (!feed) return;

  feed.innerHTML = `
    <div id="pullIndicator">
      <div><span id="pullIcon">⬇</span><span id="pullText" class="muted">Pull to refresh</span></div>
    </div>
    <div id="feedContent"></div>
  `;

  feedContent = document.getElementById('feedContent');

  if (posts.length === 0) {
    feedContent.innerHTML = `
      <div style="color: var(--muted); text-align: center; padding: 50px;">
        ${searchQuery ? 'No posts found' : 'No posts available'}
      </div>
    `;
    return;
  }

  posts.forEach((post, index) => {
    const postEl = createPostElement(post, index);
    feedContent.appendChild(postEl);
  });

  setupPullToRefresh();
  setupVideoPlayback();
  setupInfiniteScroll();
}

function createPostElement(post, index) {
  const postEl = document.createElement('article');
  postEl.className = `post ${post.paused ? 'paused' : ''} ${post.uploading ? 'uploading' : ''}`;
  postEl.dataset.id = post.id;
  postEl.dataset.index = index;
  
  postEl.innerHTML = `
    <div class="post-inner">
      ${post.uploading ? `<div class="upload-progress"><div class="upload-progress-bar" style="width: ${post.uploadProgress || 0}%"></div></div>` : ''}
      
      <!-- Video Element -->
      <video 
        playsinline 
        ${!post.paused ? 'autoplay' : ''} 
        loop 
        preload="metadata" 
        crossorigin="anonymous"
        oncontextmenu="return false;"
        style="width: 100%; height: 100%; object-fit: cover;"
      >
        ${post.src ? `<source src="${post.src}" type="video/mp4">` : ''}
      </video>
      
      <div class="blue-heart">♥</div>
      <div class="play-overlay"><div class="play-icon">▶</div></div>
      <div class="overlay">
        <h3>${post.user}</h3>
        <p>${post.title}</p>
        ${post.caption ? `<p style="display: block; margin-top: 4px;">${post.caption}</p>` : ''}
      </div>
      <div class="icons">
        <div class="like-wrap">
          <button class="btn like-btn ${post.liked ? 'liked' : ''}" title="Like">♡</button>
          <div class="like-count">${post.likes}</div>
        </div>
        ${post.owner ? 
          '<button class="btn delete-btn" title="Delete Post">🗑️</button>' : 
          '<button class="btn comment-open" title="Comments">💬</button><button class="btn share-btn" title="Share">↗️</button>'
        }
      </div>
      
      ${!post.owner ? `
      <div class="drawer" aria-hidden="true">
        <div class="drawer-inner">
          <div class="drawer-handle"></div>
          <div class="muted small center" style="margin-top: 4px;">Comments</div>
          <div class="comments-list" aria-live="polite"></div>
          <div class="drawer-footer">
            <div class="comment-input"><input placeholder="Write your comment..." /></div>
            <button class="send-small">Send</button>
          </div>
        </div>
      </div>
      ` : ''}
    </div>
  `;

  attachPostBehavior(postEl, post);
  return postEl;
}

function attachPostBehavior(postEl, postData) {
  const video = postEl.querySelector('video');
  const likeBtn = postEl.querySelector('.like-btn');
  const deleteBtn = postEl.querySelector('.delete-btn');
  const commentOpen = postEl.querySelector('.comment-open');
  const shareBtn = postEl.querySelector('.share-btn');
  const blueHeart = postEl.querySelector('.blue-heart');

  // Load video source if available
  if (postData.src && video) {
    const source = video.querySelector('source');
    if (source) {
      source.src = postData.src;
      video.load();
    }
  }

  // Single tap to pause/play
  let tapCount = 0;
  let tapTimer;

  postEl.addEventListener('click', (e) => {
    if (e.target.closest('.icons') || e.target.closest('.drawer')) return;
    
    tapCount++;
    
    if (tapCount === 1) {
      tapTimer = setTimeout(() => {
        // Single tap - toggle play/pause
        if (video.paused) {
          video.play().catch(console.error);
          postData.paused = false;
        } else {
          video.pause();
          postData.paused = true;
        }
        postEl.classList.toggle('paused');
        tapCount = 0;
      }, 300);
    } else if (tapCount === 2) {
      clearTimeout(tapTimer);
      // Double tap - like
      if (!postData.liked) {
        likeManager.handleLike(likeBtn);
      }
      tapCount = 0;
    }
  });

  // Like button
  likeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    likeManager.handleLike(likeBtn);
  });

  // Delete post
  if (deleteBtn) {
    deleteBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (confirm('Delete this post permanently?')) {
        try {
          await supabase.from('posts').delete().eq('id', postData.id);
          allPosts = allPosts.filter(p => p.id !== postData.id);
          posts = posts.filter(p => p.id !== postData.id);
          postEl.remove();
        } catch (error) {
          console.error('Error deleting post:', error);
          alert('Error deleting post');
        }
      }
    });
  }

  // Share post
  if (shareBtn) {
    shareBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const shareUrl = `${window.location.origin}/post/${postData.id}`;
      if (navigator.share) {
        navigator.share({
          title: `${postData.title} by ${postData.user}`,
          text: postData.caption,
          url: shareUrl,
        });
      } else {
        navigator.clipboard.writeText(shareUrl).then(() => {
          alert('Link copied to clipboard!');
        });
      }
    });
  }

  // Comments drawer
  if (commentOpen) {
    setupCommentsDrawer(postEl, postData);
  }
}

function setupCommentsDrawer(postEl, postData) {
  const drawer = postEl.querySelector('.drawer');
  const commentOpen = postEl.querySelector('.comment-open');
  const commentsList = postEl.querySelector('.comments-list');
  const commentInput = postEl.querySelector('.comment-input input');
  const sendBtn = postEl.querySelector('.send-small');
  const commentInputWrap = postEl.querySelector('.comment-input');

  commentOpen.addEventListener('click', (e) => {
    e.stopPropagation();
    drawer.classList.toggle('open');
  });

  // Close drawer when clicking outside
  postEl.addEventListener('click', (e) => {
    if (drawer.classList.contains('open') && !e.target.closest('.drawer')) {
      drawer.classList.remove('open');
    }
  });

  // Long press on comments to reply
  commentsList.addEventListener('pointerdown', (e) => {
    if (!e.target.classList.contains('comment')) return;
    
    const commentEl = e.target;
    let pressTimer = setTimeout(() => {
      commentInputWrap.classList.add('active');
      commentInput.value = `@${commentEl.textContent.split(':')[0]}: `;
      commentInput.focus();
    }, 1000);

    const cancelPress = () => {
      clearTimeout(pressTimer);
      document.removeEventListener('pointerup', cancelPress);
      document.removeEventListener('pointermove', cancelPress);
    };

    document.addEventListener('pointerup', cancelPress);
    document.addEventListener('pointermove', cancelPress);
  });

  // Send comment
  sendBtn.addEventListener('click', async () => {
    const comment = commentInput.value.trim();
    if (comment) {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        if (!session) {
          alert('Please sign in to comment');
          return;
        }

        const userName = session.user.user_metadata?.username || session.user.email.split('@')[0];
        const newComment = `@${userName}: ${comment}`;
        
        // Add to Supabase
        const { error } = await supabase.from('comments').insert({
          post_id: postData.id,
          user_id: session.user.id,
          user_name: userName,
          comment: comment
        });

        if (error) throw error;

        if (!postData.comments) postData.comments = [];
        postData.comments.push(newComment);
        refreshComments(commentsList, postData.comments);
        commentInput.value = '';
      } catch (error) {
        console.error('Error posting comment:', error);
        alert('Error posting comment');
      }
    }
  });

  // Load comments from Supabase
  loadComments(postData.id, commentsList);
}

async function loadComments(postId, commentsList) {
  try {
    const { data, error } = await supabase
      .from('comments')
      .select('user_name, comment, created_at')
      .eq('post_id', postId)
      .order('created_at', { ascending: true });

    if (error) throw error;

    const comments = data.map(c => `@${c.user_name}: ${c.comment}`);
    refreshComments(commentsList, comments);
  } catch (error) {
    console.error('Error loading comments:', error);
  }
}

function refreshComments(commentsList, comments) {
  commentsList.innerHTML = '';
  comments.forEach(comment => {
    const commentEl = document.createElement('div');
    commentEl.className = 'comment';
    commentEl.textContent = comment;
    commentsList.appendChild(commentEl);
  });
}

function updatePostElement(postId, postData) {
  const postEl = document.querySelector(`[data-id="${postId}"]`);
  if (!postEl) return;
  
  const likeBtn = postEl.querySelector('.like-btn');
  const likeCountEl = postEl.querySelector('.like-count');
  const overlay = postEl.querySelector('.overlay h3');
  const caption = postEl.querySelector('.overlay p:last-child');
  
  if (likeBtn) likeBtn.classList.toggle('liked', postData.liked);
  if (likeCountEl) likeCountEl.textContent = postData.likes;
  if (overlay) overlay.textContent = postData.user;
  if (caption) caption.textContent = postData.title;
}

function showBlueHeart(postEl) {
  const blueHeart = postEl.querySelector('.blue-heart');
  blueHeart.classList.remove('animate');
  void blueHeart.offsetWidth; // Trigger reflow
  blueHeart.classList.add('animate');
}

// Video playback management
function setupVideoPlayback() {
  const videos = document.querySelectorAll('.post video');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const video = entry.target;
      const postEl = video.closest('.post');
      
      if (entry.isIntersecting && entry.intersectionRatio > 0.7) {
        if (!postEl.classList.contains('paused')) {
          video.play().catch(console.error);
        }
      } else {
        video.pause();
      }
    });
  }, { threshold: [0.7], rootMargin: '50px' });

  videos.forEach(video => observer.observe(video));
}

// Vertical swipe between videos
function setupVerticalSwipe() {
  let startY = 0;
  let currentTranslate = 0;
  let currentIndex = 0;

  feed.addEventListener('touchstart', (e) => {
    startY = e.touches[0].clientY;
  }, { passive: true });

  feed.addEventListener('touchmove', (e) => {
    const currentY = e.touches[0].clientY;
    const deltaY = currentY - startY;
    
    // Only allow swipe if at the top or bottom of scroll
    if (feed.scrollTop === 0 && deltaY > 0) {
      e.preventDefault();
    } else if (feed.scrollHeight - feed.scrollTop === feed.clientHeight && deltaY < 0) {
      e.preventDefault();
    }
  }, { passive: false });

  feed.addEventListener('touchend', (e) => {
    const endY = e.changedTouches[0].clientY;
    const deltaY = endY - startY;
    const swipeThreshold = 50;

    if (Math.abs(deltaY) > swipeThreshold) {
      if (deltaY < 0 && currentIndex < posts.length - 1) {
        // Swipe up - next video
        currentIndex++;
        scrollToVideo(currentIndex);
      } else if (deltaY > 0 && currentIndex > 0) {
        // Swipe down - previous video
        currentIndex--;
        scrollToVideo(currentIndex);
      }
    }
  }, { passive: true });
}

function scrollToVideo(index) {
  const postEl = document.querySelector(`[data-index="${index}"]`);
  if (postEl) {
    postEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    
    // Pause all other videos
    document.querySelectorAll('.post video').forEach((video, i) => {
      if (i !== index) {
        video.pause();
      }
    });
  }
}

// Pull to refresh
function setupPullToRefresh() {
  let startY = 0;
  let pulling = false;
  let translateY = 0;
  const refreshThreshold = 100;

  if (!feedContent) return;

  feed.addEventListener('pointerdown', (e) => {
    if (e.pointerType !== 'touch' || feed.scrollTop !== 0) return;
    startY = e.clientY;
    pulling = true;
    feedContent.style.transition = 'none';
  });

  feed.addEventListener('pointermove', (e) => {
    if (!pulling) return;
    const deltaY = e.clientY - startY;
    if (deltaY <= 0) return;
    e.preventDefault();
    translateY = deltaY * 0.5;
    translateY = Math.min(translateY, 200);
    feedContent.style.transform = `translateY(${translateY}px)`;
    updateRefreshIndicator(translateY);
  });

  feed.addEventListener('pointerup', () => {
    if (!pulling) return;
    pulling = false;
    if (translateY >= refreshThreshold) {
      refreshContent();
    } else {
      resetPull();
    }
  });

  function updateRefreshIndicator(dist) {
    const indicator = document.getElementById('pullIndicator');
    const icon = document.getElementById('pullIcon');
    const text = document.getElementById('pullText');

    if (dist < 10) {
      indicator.style.opacity = '0';
      indicator.style.transform = 'translateX(-50%) translateY(-100%)';
      return;
    }

    indicator.style.opacity = '1';
    indicator.style.transform = 'translateX(-50%) translateY(0px)';

    if (dist > refreshThreshold) {
      icon.textContent = '○';
      text.textContent = 'Release to refresh';
    } else {
      icon.textContent = '⬇';
      text.textContent = 'Pull to refresh';
    }
  }

  function resetPull() {
    feedContent.style.transition = 'transform 0.3s ease';
    feedContent.style.transform = 'translateY(0px)';
    updateRefreshIndicator(0);
  }

  function refreshContent() {
    const indicator = document.getElementById('pullIndicator');
    const icon = document.getElementById('pullIcon');
    const text = document.getElementById('pullText');

    icon.textContent = '🔄';
    icon.classList.add('refreshing');
    text.textContent = 'Refreshing...';

    setTimeout(async () => {
      await loadInitialPosts();
      renderFeed();
      icon.classList.remove('refreshing');
      icon.textContent = '✅';
      text.textContent = 'Updated!';
      setTimeout(() => {
        indicator.style.opacity = '0';
        resetPull();
      }, 1000);
    }, 1500);
  }
}

// Infinite scroll
function setupInfiniteScroll() {
  let loading = false;

  feed.addEventListener('scroll', debounce(() => {
    if (loading || searchQuery) return;
    
    const { scrollTop, scrollHeight, clientHeight } = feed;
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      loading = true;
      loadMorePosts();
    }
  }, 100));
}

async function loadMorePosts() {
  try {
    const { data, error } = await supabase
      .from('posts')
      .select('id, author_id, author_name, video_url, created_at, title, caption')
      .order('created_at', { ascending: false })
      .range(allPosts.length, allPosts.length + 4);

    if (error) throw error;

    if (data && data.length > 0) {
      const { data: { session } } = await supabase.auth.getSession();
      const currentUserId = session?.user?.id || null;

      const newPosts = data.map(post => ({
        id: post.id,
        user: post.author_name ? `@${post.author_name}` : `@user_${post.author_id?.slice(0, 8)}`,
        title: post.title || 'Untitled',
        caption: post.caption || '',
        src: post.video_url,
        likes: 0,
        comments: [],
        liked: likeManager.isLiked(post.id),
        uploading: false,
        owner: currentUserId && post.author_id === currentUserId,
        paused: false,
      }));

      allPosts.push(...newPosts);
      posts = [...allPosts];
      renderFeed();
    }
  } catch (error) {
    console.error('Error loading more posts:', error);
  } finally {
    loading = false;
  }
}

// Theme swipe functionality
function setupThemeSwipe() {
  const header = document.getElementById('header');
  let pDown = false, pStartX = 0;
  
  header.addEventListener('pointerdown', (e) => {
    pDown = true;
    pStartX = e.clientX;
  });
  
  header.addEventListener('pointermove', (e) => {
    if (!pDown) return;
    const dx = e.clientX - pStartX;
    header.style.transform = `translateX(${dx * 0.08}px)`;
  });
  
  header.addEventListener('pointerup', (e) => {
    header.style.transform = '';
    if (!pDown) return;
    pDown = false;
    const dx = e.clientX - pStartX;
    const threshold = 80;
    if (dx <= -threshold || dx >= threshold) {
      document.documentElement.classList.toggle('light');
    }
  });
}

// Upload functionality
function openUploadModal() {
  uploadModal.classList.add('show');
  
  document.getElementById('closeUpload').addEventListener('click', () => {
    uploadModal.classList.remove('show');
  });

  document.getElementById('recordBtn').addEventListener('click', openRecordModal);
  
  document.getElementById('filePicker').addEventListener('change', handleFileUpload);
}

function openRecordModal() {
  const title = document.getElementById('uploadTitle').value.trim();
  const caption = document.getElementById('uploadCaption').value.trim();
  
  if (!title) {
    alert('Please enter a title for your video');
    return;
  }

  uploadModal.classList.remove('show');
  
  navigator.mediaDevices.getUserMedia({ video: true, audio: true })
    .then(stream => {
      const videoPreview = document.getElementById('videoPreview');
      videoPreview.srcObject = stream;

      const recordModal = document.getElementById('recordModal');
      recordModal.classList.add('show');

      let mediaRecorder;
      let recordedChunks = [];
      let recordingTimer;
      let recordingTime = 0;
      const recordBtnModal = document.getElementById('recordBtnModal');

      recordBtnModal.addEventListener('click', () => {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') {
          // Start recording
          mediaRecorder = new MediaRecorder(stream, { 
            mimeType: 'video/webm;codecs=vp9,opus',
            videoBitsPerSecond: 2500000
          });
          
          recordedChunks = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) recordedChunks.push(e.data);
          };
          
          mediaRecorder.onstop = async () => {
            clearInterval(recordingTimer);
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            
            // Check duration
            const video = document.createElement('video');
            video.src = URL.createObjectURL(blob);
            await new Promise(resolve => {
              video.onloadedmetadata = resolve;
            });
            
            if (video.duration > 60) {
              alert('Video must be 60 seconds or less');
              URL.revokeObjectURL(video.src);
              return;
            }
            
            const id = 'p' + Math.random().toString(36).slice(2, 9);
            const newPost = { 
              id, 
              user: `@${sessionInfoEl.textContent.split('@')[1] || 'you'}`, 
              title, 
              caption, 
              src: URL.createObjectURL(blob), 
              likes: 0, 
              comments: [], 
              liked: false, 
              uploading: true, 
              owner: true, 
              uploadProgress: 0, 
              paused: false 
            };
            
            allPosts.unshift(newPost);
            filterPosts();
            renderFeed();
            uploadVideo(newPost, blob, title, caption);
            
            stream.getTracks().forEach(track => track.stop());
            recordedChunks = [];
            recordModal.classList.remove('show');
          };
          
          mediaRecorder.start(1000); // Collect data every second
          recordBtnModal.textContent = '⏹';
          recordBtnModal.classList.add('recording');
          
          // Start timer
          recordingTime = 0;
          recordingTimer = setInterval(() => {
            recordingTime++;
            if (recordingTime >= 60) {
              mediaRecorder.stop();
            }
          }, 1000);
        } else {
          // Stop recording
          mediaRecorder.stop();
          recordBtnModal.textContent = '⏺';
          recordBtnModal.classList.remove('recording');
        }
      });

      document.getElementById('closeRecord').addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }
        stream.getTracks().forEach(track => track.stop());
        recordModal.classList.remove('show');
        clearInterval(recordingTimer);
      });
    })
    .catch(err => {
      console.error('Camera access error:', err);
      alert('Camera access denied or not available.');
    });
}

async function handleFileUpload(e) {
  const file = e.target.files[0];
  const title = document.getElementById('uploadTitle').value.trim();
  const caption = document.getElementById('uploadCaption').value.trim();
  
  if (!title) {
    alert('Please enter a title for your video');
    return;
  }
  
  if (!file) return;
  
  if (!file.type.startsWith('video/')) {
    alert('Please select a video file');
    return;
  }

  // Check duration
  const video = document.createElement('video');
  video.src = URL.createObjectURL(file);
  
  try {
    await new Promise((resolve, reject) => {
      video.onloadedmetadata = resolve;
      video.onerror = reject;
    });
    
    if (video.duration > 60) {
      alert('Video must be 60 seconds or less');
      URL.revokeObjectURL(video.src);
      return;
    }
    
    uploadModal.classList.remove('show');
    const id = 'p' + Math.random().toString(36).slice(2, 9);
    const newPost = { 
      id, 
      user: `@${sessionInfoEl.textContent.split('@')[1] || 'you'}`, 
      title, 
      caption, 
      src: URL.createObjectURL(file), 
      likes: 0, 
      comments: [], 
      liked: false, 
      uploading: true, 
      owner: true, 
      uploadProgress: 0, 
      paused: false 
    };
    
    allPosts.unshift(newPost);
    filterPosts();
    renderFeed();
    uploadVideo(newPost, file, title, caption);
    
    URL.revokeObjectURL(video.src);
  } catch (error) {
    console.error('Error checking video duration:', error);
    alert('Error processing video file');
  }
}

async function uploadVideo(post, file, title, caption) {
  progressModal.classList.add('show');
  updateProgress(0);
  
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      alert('You must be signed in to upload.');
      post.uploading = false;
      updateProgress(100);
      setTimeout(() => progressModal.classList.remove('show'), 1000);
      return;
    }
    
    const userId = session.user.id;
    const authorName = session.user.user_metadata?.username || session.user.email.split('@')[0];
    const ext = file.name.split('.').pop() || 'mp4';
    const filename = `${Date.now()}_${Math.random().toString(36).slice(2, 8)}.${ext}`;
    const path = `posts/${userId}/${filename}`;

    // Start progress simulation
    const progressInterval = setInterval(() => {
      if (post.uploadProgress < 90) {
        post.uploadProgress += Math.random() * 10;
        updateProgress(post.uploadProgress);
        updatePostElement(post.id, post);
      }
    }, 200);

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('videos')
      .upload(path, file, { 
        cacheControl: '3600', 
        upsert: false,
        onUploadProgress: (progress) => {
          const percent = (progress.loaded / progress.total) * 100;
          post.uploadProgress = percent;
          updateProgress(percent);
          updatePostElement(post.id, post);
        }
      });

    clearInterval(progressInterval);

    if (uploadError) {
      console.error('Upload error', uploadError);
      alert('Upload failed: ' + uploadError.message);
      post.uploading = false;
      updateProgress(100);
      setTimeout(() => progressModal.classList.remove('show'), 1000);
      return;
    }

    const { data: urlData } = supabase.storage.from('videos').getPublicUrl(uploadData.path);
    const publicUrl = urlData?.publicUrl || '';

    const insertPayload = { 
      author_id: userId, 
      author_name: authorName, 
      video_url: publicUrl, 
      title,
      caption 
    };
    
    const { data: inserted, error: insertError } = await supabase
      .from('posts')
      .insert(insertPayload)
      .select()
      .single();

    if (insertError) {
      console.error('Insert error', insertError);
      alert('Insert failed: ' + insertError.message);
      post.uploading = false;
      updateProgress(100);
      setTimeout(() => progressModal.classList.remove('show'), 1000);
      return;
    }

    post.src = publicUrl;
    post.uploading = false;
    post.uploadProgress = 100;
    post.owner = true;
    if (inserted && inserted.id) post.id = inserted.id;
    
    updatePostElement(post.id, post);
    updateProgress(100);
    
    // Hide progress modal quickly after completion
    setTimeout(() => {
      progressModal.classList.remove('show');
    }, 500);
    
  } catch (err) {
    console.error('Unexpected upload error', err);
    alert('Upload failed: ' + (err?.message || err));
    post.uploading = false;
    updateProgress(100);
    setTimeout(() => progressModal.classList.remove('show'), 1000);
  }
}

function updateProgress(percent) {
  progressFill.style.width = `${percent}%`;
  progressText.textContent = `Uploading... ${Math.round(percent)}%`;
}

// Global error handling
window.addEventListener('error', (e) => {
  console.error('Global error:', e.error);
});

window.addEventListener('unhandledrejection', (e) => {
  console.error('Unhandled promise rejection:', e.reason);
});

// Escape key to close modals
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    document.querySelectorAll('.drawer.open').forEach(d => d.classList.remove('open'));
    uploadModal.classList.remove('show');
    document.getElementById('recordModal').classList.remove('show');
  }
});
</script>
</body>
</html>
