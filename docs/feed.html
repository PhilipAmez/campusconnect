<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Skrolz</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0f0f10;
    --card: #141416;
    --muted: #bfc3cc;
    --accent-1: #7bdff6;
    --accent-2: #2fb3ff;
    --accent: #6a40ff;
    --glass: rgba(255,255,255,0.05);
    --transition: 320ms cubic-bezier(.2,.9,.3,1);
    --blue-aqua: #7bdff6;
    --like-blue: #2fb3ff;
  }
  html.light {
    --bg: #f6f7fa;
    --card: #fff;
    --muted: #374151;
    --glass: rgba(0,0,0,0.03);
  }

  * { box-sizing: border-box }
  html, body {
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  html::-webkit-scrollbar, body::-webkit-scrollbar { display: none; }

  body {
    margin: 0;
    font-family: 'Poppins', sans-serif;
    background: var(--bg);
    color: #fff;
    -webkit-font-smoothing: antialiased;
    transition: background var(--transition), color var(--transition);
    min-height: 100vh;
    overflow-x: hidden;
    scroll-behavior: smooth;
    padding-bottom: env(safe-area-inset-bottom);
  }

  /* HEADER */
  header {
    position: sticky; top: 0; z-index: 40;
    height: 64px; display: flex; align-items: center; justify-content: center;
    background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.05));
    backdrop-filter: blur(8px) saturate(140%);
    border-bottom: 1px solid rgba(255,255,255,0.03);
    transition: background var(--transition), color var(--transition), transform 220ms ease;
    user-select: none;
    touch-action: none;
  }
  html.light header {
    background: linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.85));
    border-bottom: 1px solid rgba(0,0,0,0.06);
    color: #111;
  }
  .header-inner { text-align: center; pointer-events: none; width: 100%; max-width: 360px; }
  .header-title { font-weight: 700; font-size: 18px; letter-spacing: 0.3px }
  .header-hint { position: absolute; right: 14px; font-size: 13px; opacity: 0.75; pointer-events: none }

  /* AVATAR */
  .avatar {
    width: 32px; height: 32px; border-radius: 50%; 
    background: linear-gradient(135deg, var(--accent), #b473ff);
    display: flex; align-items: center; justify-content: center;
    color: white; font-weight: 600; font-size: 14px; text-transform: uppercase;
  }

  /* SEARCH BAR - Mobile optimized */
  .search-container {
    position: sticky;
    top: 64px;
    z-index: 39;
    background: var(--bg);
    padding: 8px 16px;
    border-bottom: 1px solid rgba(255,255,255,0.03);
    transition: all 0.3s ease;
  }
  
  /* Hide search on mobile when scrolling */
  .search-container.hidden {
    transform: translateY(-100%);
    opacity: 0;
    pointer-events: none;
  }
  
  .search-wrapper {
    max-width: 300px;
    margin: 0 auto;
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  @media (max-width: 768px) {
    .search-wrapper {
      max-width: 100%;
    }
    
    .search-container {
      padding: 6px 12px;
    }
  }
  
  #searchBar {
    flex: 1;
    padding: 10px 14px;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 25px;
    background: var(--glass);
    color: inherit;
    font-size: 14px;
    backdrop-filter: blur(8px);
    outline: none;
    transition: all 0.2s ease;
  }
  html.light #searchBar { background: rgba(0,0,0,0.04); border-color: rgba(0,0,0,0.1); }
  #searchBar::placeholder { color: var(--muted); }
  #searchBar:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(106, 64, 255, 0.1);
  }

  /* FEED - Mobile optimized */
  main#feed {
    padding: 0; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 0;
    position: relative;
    overflow-y: auto;
    height: calc(100vh - 64px);
    scroll-snap-type: y mandatory;
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
  }
  
  /* Hide search bar on mobile when scrolling */
  @media (max-width: 768px) {
    main#feed {
      height: calc(100vh - 64px);
    }
    
    .search-container {
      position: fixed;
      width: 100%;
      top: 64px;
      z-index: 39;
    }
  }
  
  #feedContent {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0;
    width: 100%;
    transition: transform var(--transition);
    will-change: transform;
  }

  #pullIndicator {
    position: fixed;
    top: 128px;
    left: 50%;
    transform: translateX(-50%) translateY(-100%);
    width: 360px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--glass);
    border-radius: 18px 18px 0 0;
    transition: opacity 0.2s, transform 0.3s;
    opacity: 0;
    z-index: 50;
    pointer-events: none;
  }
  html.light #pullIndicator { background: rgba(0,0,0,0.03); }
  #pullIndicator > div { display: flex; align-items: center; gap: 8px; }
  #pullText { font-size: 13px; color: var(--muted); }
  #pullIcon.refreshing { animation: spin 0.8s linear infinite; }
  @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

  @media (max-width: 420px) {
    #pullIndicator { width: 92vw; }
    .search-wrapper { max-width: 100%; }
    #searchBar { font-size: 16px; }
    .post { width: 100vw; height: 100vh; border-radius: 0; }
    .icons { right: 12px; bottom: 120px; }
    .drawer.open { height: 70% }
  }

  /* LOADING */
  .loading { display: flex; align-items: center; justify-content: center; height: 100px; font-size: 14px; color: var(--muted); }

  /* CARD / POST - Mobile optimized */
  .post {
    width: 100vw; 
    height: 100vh; 
    border-radius: 0; 
    overflow: visible; 
    position: relative;
    background: var(--card); 
    box-shadow: none;
    transition: transform var(--transition), box-shadow var(--transition), background var(--transition);
    will-change: transform;
    touch-action: pan-y;
    scroll-snap-align: start;
  }
  
  /* Desktop styles */
  @media (min-width: 769px) {
    .post {
      width: 360px; 
      height: 640px; 
      border-radius: 18px; 
      box-shadow: 0 12px 40px rgba(2,6,23,0.55);
      margin: 20px 0;
    }
    
    main#feed {
      padding: 20px;
      height: calc(100vh - 128px);
    }
  }
  
  html.light .post { box-shadow: 0 8px 28px rgba(2,6,23,0.06) }
  .post.swiping { transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); }

  .post-inner { width: 100%; height: 100%; border-radius: inherit; overflow: hidden; position: relative; background: var(--card); }
  .post video { width: 100%; height: 100%; object-fit: cover; display: block; }

  .play-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center;
    opacity: 0; transition: opacity 200ms ease; z-index: 10; pointer-events: none;
  }
  .post.paused .play-overlay { opacity: 1; pointer-events: auto; }
  .play-icon {
    width: 80px; height: 80px; border-radius: 50%; background: var(--blue-aqua);
    display: flex; align-items: center; justify-content: center; font-size: 32px;
    color: white; opacity: 0.9; box-shadow: 0 4px 20px rgba(123, 223, 246, 0.4);
  }

  .upload-progress {
    position: absolute; top: 0; left: 0; height: 4px; background: rgba(0,0,0,0.3); overflow: hidden; z-index: 15;
  }
  .upload-progress-bar {
    height: 100%; background: linear-gradient(90deg, var(--blue-aqua), var(--accent-2)); width: 0%; transition: width 100ms linear;
  }

  .overlay {
    position: absolute; left: 0; right: 0; bottom: 0; padding: 14px;
    background: linear-gradient(0deg, rgba(0,0,0,0.6), transparent 40%); color: #fff;
    transition: background var(--transition), color var(--transition);
  }
  html.light .overlay { background: linear-gradient(0deg, rgba(255,255,255,0.86), transparent 40%); color: #111; }
  .overlay h3 { margin: 0 0 6px 0; font-size: 14px; font-weight: 600 }
  .overlay p { margin: 0; font-size: 13px; color: var(--muted); }
  .post-title { font-weight: 600; font-size: 14px; margin-bottom: 4px; }
  .post-caption { font-size: 13px; color: var(--muted); line-height: 1.4; }

  .icons {
    position: absolute; right: 10px; bottom: 84px; display: flex; flex-direction: column; gap: 12px; align-items: center; z-index: 22;
  }
  
  @media (max-width: 768px) {
    .icons {
      right: 12px;
      bottom: 120px;
    }
  }
  
  .btn {
    width: 48px; height: 48px; border-radius: 50%; display: flex; align-items: center; justify-content: center; border: none; cursor: pointer;
    background: rgba(255,255,255,0.06); backdrop-filter: blur(8px); color: #fff; font-size: 18px;
    transition: transform 160ms ease, background 160ms, color 160ms;
  }
  .btn:active { transform: scale(.96) }
  html.light .btn { color: #111; background: rgba(0,0,0,0.04) }

  .like-btn.liked {
    background: linear-gradient(135deg, var(--like-blue), #2f8fff);
    color: white;
    box-shadow: 0 0 12px rgba(47, 179, 255, 0.4);
  }

  .icon-wrap { display: flex; flex-direction: column; align-items: center; gap: 6px }
  .icon-count { font-size: 12px; color: var(--muted); user-select: none }

  .delete-btn { background: rgba(255, 50, 50, 0.2); color: #ff6b6b; }

  /* Comments Drawer - Improved for mobile */
  .drawer {
    position: absolute; left: 0; right: 0; bottom: 0; height: 0; max-height: 85%;
    border-radius: 14px 14px 0 0; overflow: hidden; display: flex; flex-direction: column; align-items: center;
    backdrop-filter: blur(14px) saturate(140%); background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
    border: 1px solid rgba(255,255,255,0.1);
    transition: height 360ms cubic-bezier(.2,.9,.3,1), transform 320ms ease;
    z-index: 26;
  }
  html.light .drawer { 
    background: linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.03)); 
    color: #111;
    border: 1px solid rgba(0,0,0,0.1);
  }

  .drawer.open { 
    height: 70%; 
    pointer-events: auto;
  }

  .drawer-inner {
    width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center;
    padding: 12px 12px 8px 12px; gap: 10px; box-sizing: border-box; overflow: auto;
    -webkit-overflow-scrolling: touch; scroll-behavior: smooth;
  }
  .drawer-inner::-webkit-scrollbar { display: none }
  .drawer-inner { -ms-overflow-style: none; scrollbar-width: none }

  .drawer-handle { width: 54px; height: 6px; border-radius: 6px; background: rgba(255,255,255,0.12); margin-top: 6px; }
  html.light .drawer-handle { background: rgba(0,0,0,0.08) }

  .comments-header {
    width: 100%;
    text-align: center;
    padding: 8px 0;
    font-size: 14px;
    color: var(--muted);
    user-select: none;
    cursor: pointer;
  }

  .comments-list { 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    gap: 8px; 
    width: 100%; 
    padding-top: 6px; 
    box-sizing: border-box;
    overflow-y: auto;
    max-height: 300px;
  }
  .comment { 
    width: 94%; text-align: left; padding: 10px 12px; border-radius: 10px; 
    background: rgba(255,255,255,0.08); color: #ffffff; 
    user-select: none; font-size: 14px; line-height: 1.4;
    border: 1px solid rgba(255,255,255,0.1);
    cursor: pointer;
    position: relative;
  }
  html.light .comment { 
    background: rgba(0,0,0,0.06); 
    color: #333; 
    border: 1px solid rgba(0,0,0,0.1);
  }
  
  .comment-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
  }
  
  .comment-user {
    font-weight: 600;
    font-size: 13px;
  }
  
  .comment-time {
    font-size: 11px;
    color: var(--muted);
  }
  
  .comment-text {
    font-size: 14px;
    line-height: 1.4;
  }
  
  .comment-actions {
    display: flex;
    gap: 12px;
    margin-top: 6px;
  }
  
  .comment-action {
    font-size: 12px;
    color: var(--muted);
    background: none;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 4px;
  }
  
  .reply-section {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid rgba(255,255,255,0.1);
  }
  
  .replies-list {
    margin-top: 8px;
    padding-left: 12px;
    border-left: 2px solid rgba(255,255,255,0.1);
  }
  
  .reply {
    background: rgba(255,255,255,0.05);
    padding: 8px 10px;
    border-radius: 8px;
    margin-top: 6px;
  }

  .drawer-footer { 
    width: 100%; 
    display: flex; 
    justify-content: center; 
    gap: 8px; 
    padding: 8px 0 4px; 
    align-items: center; 
    position: sticky;
    bottom: 0;
    background: inherit;
  }
  .comment-input { 
    display: none; 
    width: 84%; 
    position: relative;
  }
  .comment-input.active { display: block; }
  .comment-input input { 
    width: 100%; 
    padding: 10px 12px; 
    border-radius: 999px; 
    border: none; 
    outline: none; 
    background: rgba(255,255,255,0.1); 
    color: #fff; 
    font-size: 14px;
    font-family: 'Poppins', sans-serif;
  }
  html.light .comment-input input { background: rgba(0,0,0,0.08); color: #111 }
  .send-small { padding: 8px 12px; border-radius: 10px; border: none; background: var(--accent); color: #fff; font-weight: 600; cursor: pointer; font-family: 'Poppins', sans-serif; }

  .heart-hit { 
    position: absolute; pointer-events: none; width: 120px; height: 120px; left: 50%; top: 50%; 
    transform: translate(-50%,-50%); z-index: 30; opacity: 0; transition: opacity 120ms linear; 
  }
  .heart-hit.show { opacity: 1; animation: heart-pop 420ms cubic-bezier(.2,.85,.25,1); }
  @keyframes heart-pop {
    0% { transform: translate(-50%,-50%) scale(.84); opacity: 0; filter: blur(6px) }
    10% { transform: translate(-50%,-50%) scale(1.04); opacity: 1; filter: blur(0) }
    80% { transform: translate(-50%,-50%) scale(1); opacity: 1 }
    100% { transform: translate(-50%,-50%) scale(1); opacity: 0 }
  }

  .fab {
    position: fixed; right: 22px; bottom: 22px; z-index: 40; width: 64px; height: 64px; border-radius: 50%; border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center; font-size: 28px;
    background: linear-gradient(135deg, var(--accent), #b473ff); color: #fff;
    box-shadow: 0 14px 40px rgba(100,40,255,0.12); transition: transform 180ms ease;
  }
  .fab:active { transform: scale(.98) }

  /* Auth Modal */
  .auth-modal {
    position: fixed; inset: 0; background: rgba(2,6,23,0.75); backdrop-filter: blur(12px) saturate(180%);
    display: none; align-items: center; justify-content: center; z-index: 100;
  }
  .auth-modal.show { display: flex; }
  .auth-content {
    width: min(400px, 90vw); padding: 30px; border-radius: 20px;
    background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.08));
    backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 25px 50px rgba(0,0,0,0.3); color: inherit;
    text-align: center;
  }
  .auth-title { font-size: 24px; font-weight: 700; margin-bottom: 10px; }
  .auth-subtitle { color: var(--muted); margin-bottom: 30px; font-size: 14px; }
  .auth-buttons { display: flex; flex-direction: column; gap: 12px; }
  .auth-btn {
    padding: 14px; border-radius: 12px; border: none; 
    background: linear-gradient(135deg, var(--accent), #b473ff); 
    color: white; font-weight: 600; cursor: pointer;
    font-family: 'Poppins', sans-serif; font-size: 15px;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }
  .auth-btn:active { transform: scale(0.98); }
  .auth-btn.secondary {
    background: rgba(255,255,255,0.1); 
    border: 1px solid rgba(255,255,255,0.2);
  }

  /* Login Link Styles */
  .login-link {
    color: var(--accent);
    text-decoration: none;
    font-weight: 600;
    cursor: pointer;
    transition: opacity 0.2s ease;
  }
  .login-link:hover {
    opacity: 0.8;
  }

  #recordModal {
    position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 70;
  }
  #recordModal.show { display: flex; }
  .record-container {
    width: 100%; height: 100%; position: relative; display: flex; flex-direction: column;
  }
  #videoPreview { width: 100%; height: calc(100% - 100px); object-fit: cover; background: black; }
  .record-controls {
    position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; align-items: center;
  }
  .record-btn {
    width: 80px; height: 80px; border-radius: 50%; background: var(--blue-aqua); border: none; cursor: pointer;
    display: flex; align-items: center; justify-content: center; font-size: 30px; color: white;
    box-shadow: 0 4px 20px rgba(123, 223, 246, 0.4); transition: transform 0.2s;
  }
  .record-btn.recording { background: #ff4757; transform: scale(1.1); }
  .record-btn:active { transform: scale(0.95); }
  .close-record { position: absolute; top: 20px; right: 20px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; }

  #uploadProgressModal {
    position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 80;
  }
  #uploadProgressModal.show {
    display: flex;
  }
  .progress-box {
    background: var(--card);
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    text-align: center;
    width: 300px;
    max-width: 90vw;
  }
  .progress-bar {
    width: 100%;
    height: 20px;
    background: var(--glass);
    border-radius: 10px;
    overflow: hidden;
    margin: 10px 0;
  }
  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--blue-aqua), var(--accent-2));
    width: 0%;
    transition: width 0.3s ease;
  }
  .progress-text { font-size: 14px; color: var(--muted); }

  /* UPLOAD MODAL STYLES */
  .upload-modal {
    position: fixed; inset: 0; background: rgba(2,6,23,0.45); backdrop-filter: blur(6px) saturate(130%);
    display: none; align-items: center; justify-content: center; z-index: 60;
  }
  .upload-modal.show { display: flex; }
  .upload-content {
    width: min(720px,92vw); padding: 20px; border-radius: 14px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    box-shadow: 0 18px 60px rgba(0,0,0,0.6); color: inherit;
  }

  @media (max-width: 420px) {
    .post { width: 100vw; height: 100vh; border-radius: 0; }
    .icons { right: 12px; bottom: 120px; }
    .drawer.open { height: 70% }
    .progress-box { width: 90vw; }
  }

  .muted { color: var(--muted); font-size: 13px }
  .center { display: flex; align-items: center; justify-content: center }

  /* BLUE HEART ANIMATION */
  .blue-heart {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    font-size: 80px; color: var(--like-blue); opacity: 0; z-index: 25; pointer-events: none;
    text-shadow: 0 0 20px rgba(47, 179, 255, 0.6);
  }
  .blue-heart.animate {
    animation: blueHeartPop 0.8s ease-out;
  }
  @keyframes blueHeartPop {
    0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
  }

  /* SWIPE INDICATOR */
  .swipe-indicator {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.6);
    color: white;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 14px;
    z-index: 30;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  .swipe-indicator.show {
    opacity: 1;
  }
</style>
</head>
<body>
  <header id="header" aria-hidden="false">
    <div class="header-inner">
      <div id="sessionInfo" style="position: absolute; left: 12px; top: 12px; display: flex; align-items: center; gap: 8px; pointer-events: auto">
        <div class="avatar" id="userAvatar">?</div>
      </div>
      <div class="header-title">Skrolz</div>
      <div class="header-hint">Swipe ← / → to toggle theme</div>
    </div>
  </header>

  <div class="search-container" id="searchContainer">
    <div class="search-wrapper">
      <input type="text" id="searchBar" placeholder="Search posts..." autocomplete="off">
    </div>
  </div>

  <main id="feed" aria-live="polite"></main>

  <div class="swipe-indicator" id="swipeIndicator">Swipe up for next video</div>

  <button class="fab" id="fab">＋</button>

  <!-- Auth Modal -->
  <div class="auth-modal" id="authModal">
    <div class="auth-content">
      <div class="auth-title">Join Skrolz</div>
      <div class="auth-subtitle">Sign in to create and interact with posts</div>
      <div class="auth-buttons">
        <button class="auth-btn" id="signInBtn">Sign In</button>
        <button class="auth-btn secondary" id="signUpBtn">Sign Up</button>
      </div>
    </div>
  </div>

  <!-- Record Modal -->
  <div id="recordModal">
    <div class="record-container">
      <button class="close-record" id="closeRecord">×</button>
      <video id="videoPreview" autoplay playsinline muted></video>
      <div class="record-controls">
        <button class="record-btn" id="recordBtnModal">⏺</button>
      </div>
    </div>
  </div>

  <!-- Upload Progress Modal -->
  <div id="uploadProgressModal">
    <div class="progress-box">
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <div class="progress-text" id="progressText">Uploading... 0%</div>
    </div>
  </div>

  <!-- Upload Modal -->
  <div class="upload-modal" id="uploadModal">
    <div class="upload-content">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px">
        <div><strong style="font-size: 18px">Create a Post</strong><div class="muted small" style="margin-top: 6px">Videos must be 60s or less.</div></div>
        <button id="closeUpload" style="background: none; border: none; color: inherit; font-size: 22px; cursor: pointer">×</button>
      </div>
      <div style="display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px">
        <input id="uploadTitle" placeholder="Enter title (required)" style="padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); background: var(--glass); color: inherit; outline: none; font-family: 'Poppins', sans-serif;">
        <textarea id="uploadCaption" placeholder="Enter caption (optional)" style="padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); background: var(--glass); color: inherit; outline: none; resize: none; height: 80px; font-family: 'Poppins', sans-serif;"></textarea>
      </div>
      <div style="display: flex; gap: 10px; flex-wrap: wrap">
        <button id="recordBtn" style="padding: 12px 14px; border-radius: 12px; border: none; background: linear-gradient(135deg, var(--accent), #b473ff); color: #fff; cursor: pointer; flex: 1; font-family: 'Poppins', sans-serif;">🎥 Record</button>
        <label style="padding: 12px 14px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); display: inline-flex; align-items: center; cursor: pointer; flex: 1; justify-content: center; background: var(--glass); font-family: 'Poppins', sans-serif;">
          📁 Upload <input id="filePicker" type="file" accept="video/*" style="display: none" />
        </label>
      </div>
    </div>
  </div>

<script type="module">
// Import Supabase client
// Note: You'll need to create a supabaseClient.js file with your Supabase credentials
// For now, we'll use a mock implementation

// Mock Supabase client for demonstration
const supabase = {
  auth: {
    getSession: () => Promise.resolve({ data: { session: null }, error: null }),
    onAuthStateChange: (callback) => {
      // Mock implementation
      return { data: { subscription: { unsubscribe: () => {} } } };
    }
  },
  from: (table) => ({
    select: (columns) => ({
      eq: (col, val) => ({
        order: (col, order) => ({
          limit: (num) => Promise.resolve({ data: [], error: null })
        })
      }),
      order: (col, order) => ({
        limit: (num) => Promise.resolve({ data: [], error: null })
      }),
      single: () => Promise.resolve({ data: null, error: null })
    }),
    insert: (data) => Promise.resolve({ data: null, error: null }),
    update: (data) => ({
      eq: (col, val) => Promise.resolve({ data: null, error: null })
    }),
    delete: () => ({
      eq: (col, val) => Promise.resolve({ data: null, error: null })
    })
  }),
  storage: {
    from: (bucket) => ({
      upload: (path, file, options) => Promise.resolve({ data: { path: 'mock/path' }, error: null }),
      getPublicUrl: (path) => ({ data: { publicUrl: 'https://example.com/video.mp4' } })
    })
  },
  channel: (name) => ({
    on: (event, filter, callback) => ({
      subscribe: () => ({})
    })
  }),
  rpc: (fn, params) => Promise.resolve({ data: null, error: null })
};

// Global state
let allPosts = [];
let posts = [];
let currentVideoIndex = 0;
let loadingMore = false;
let searchQuery = '';
let isRefreshing = false;
let viewedPosts = new Set(); // Track viewed posts for view count
let realtimeSubscriptions = {}; // Track realtime subscriptions
let userInteracted = false; // Track if user has interacted with the page
let audioEnabled = false; // Track if audio is enabled

// DOM elements
const feed = document.getElementById('feed');
let feedContent;
const progressModal = document.getElementById('uploadProgressModal');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');
const uploadModal = document.getElementById('uploadModal');
const authModal = document.getElementById('authModal');
const swipeIndicator = document.getElementById('swipeIndicator');
const searchContainer = document.getElementById('searchContainer');

// Wait for DOM to be fully loaded
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, initializing Skrolz...');
  initApp();
});

async function initApp() {
  try {
    setupEventListeners();
    setupAuthListener();
    setupMobileSearchBehavior();
    await loadInitialPosts();
    renderFeed();
    setupSmoothScrolling();
    console.log('Skrolz initialized successfully');
    
    // Show swipe indicator briefly on first load
    setTimeout(() => {
      showSwipeIndicator();
    }, 2000);
  } catch (error) {
    console.error('Failed to initialize app:', error);
  }
}

// Mobile search behavior - hide on scroll
function setupMobileSearchBehavior() {
  let lastScrollTop = 0;
  
  feed.addEventListener('scroll', () => {
    if (window.innerWidth > 768) return; // Only on mobile
    
    const scrollTop = feed.scrollTop;
    
    if (scrollTop > lastScrollTop && scrollTop > 100) {
      // Scrolling down
      searchContainer.classList.add('hidden');
    } else {
      // Scrolling up
      searchContainer.classList.remove('hidden');
    }
    
    lastScrollTop = scrollTop;
  });
}

// Show swipe indicator
function showSwipeIndicator() {
  swipeIndicator.classList.add('show');
  setTimeout(() => {
    swipeIndicator.classList.remove('show');
  }, 3000);
}

// Auth Modal Management
function showAuthModal() {
  authModal.classList.add('show');
}

function hideAuthModal() {
  authModal.classList.remove('show');
}

// Like Manager with proper Supabase integration
class LikeManager {
  constructor() {
    this.init();
  }

  init() {
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('like-btn')) {
        e.stopPropagation();
        this.handleLike(e.target);
      }
    });
  }

  async handleLike(button) {
    // Check if user is signed in
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      showAuthModal();
      return;
    }

    const postEl = button.closest('.post');
    const postId = postEl.dataset.id;
    const isLiked = button.classList.contains('liked');
    const likeCountEl = button.parentElement.querySelector('.like-count');
    const post = allPosts.find(p => p.id === postId);

    if (!post) return;

    try {
      if (isLiked) {
        // Unlike
        const { error } = await supabase
          .from('likes')
          .delete()
          .eq('post_id', postId)
          .eq('user_id', session.user.id);

        if (!error) {
          // Update likes_count in posts table
          const { error: updateError } = await supabase
            .from('posts')
            .update({ likes_count: Math.max(0, (post.likes || 1) - 1) })
            .eq('id', postId);

          if (!updateError) {
            button.classList.remove('liked');
            post.liked = false;
            post.likes = Math.max(0, (post.likes || 1) - 1);
            likeCountEl.textContent = post.likes;
            updatePostElement(postId, post);
          }
        } else {
          console.error('Error unliking post:', error);
        }
      } else {
        // Like
        const { error } = await supabase
          .from('likes')
          .insert({
            post_id: postId,
            user_id: session.user.id
          });

        if (!error) {
          // Update likes_count in posts table
          const { error: updateError } = await supabase
            .from('posts')
            .update({ likes_count: (post.likes || 0) + 1 })
            .eq('id', postId);

          if (!updateError) {
            button.classList.add('liked');
            post.liked = true;
            post.likes = (post.likes || 0) + 1;
            likeCountEl.textContent = post.likes;
            showBlueHeart(postEl);
            updatePostElement(postId, post);
          }
        } else {
          console.error('Error liking post:', error);
        }
      }
    } catch (error) {
      console.error('Like error:', error);
    }
  }
}

const likeManager = new LikeManager();

// Enhanced Comment Manager with Reply Support
class CommentManager {
  constructor() {
    this.replyingTo = null;
    this.init();
  }

  init() {
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('comment-open') || 
          e.target.closest('.comment-open')) {
        e.stopPropagation();
        this.openComments(e.target);
      }
      
      if (e.target.classList.contains('send-small') || 
          e.target.closest('.send-small')) {
        e.stopPropagation();
        this.sendComment(e.target);
      }
      
      if (e.target.classList.contains('reply-comment') || 
          e.target.closest('.reply-comment')) {
        e.stopPropagation();
        this.startReply(e.target);
      }
      
      if (e.target.classList.contains('cancel-reply')) {
        e.stopPropagation();
        this.cancelReply();
      }
    });
  }

  async openComments(button) {
    const postEl = button.closest('.post');
    const postId = postEl.dataset.id;
    const drawer = postEl.querySelector('.drawer');
    const commentsList = postEl.querySelector('.comments-list');
    const commentInput = postEl.querySelector('.comment-input');
    const sendBtn = postEl.querySelector('.send-small');

    // Check if user is signed in
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      showAuthModal();
      return;
    }

    drawer.classList.toggle('open');
    
    if (drawer.classList.contains('open')) {
      await this.loadComments(postId, commentsList);
      commentInput.classList.add('active');
      
      // Focus input when drawer opens
      setTimeout(() => {
        const input = commentInput.querySelector('input');
        input.focus();
      }, 300);
    } else {
      this.cancelReply();
    }
  }

  async loadComments(postId, commentsList) {
    try {
      commentsList.innerHTML = '<div class="comment loading-comment">Loading comments...</div>';
      
      // In a real app, this would fetch from your database
      // For now, we'll use mock data
      const mockComments = [
        {
          id: '1',
          user_name: 'user123',
          comment: 'This is an amazing video! 😍',
          created_at: new Date(Date.now() - 3600000).toISOString(),
          likes: 3,
          replies: [
            {
              id: '1-1',
              user_name: 'creator',
              comment: 'Thank you! Glad you liked it!',
              created_at: new Date(Date.now() - 1800000).toISOString(),
              likes: 1
            }
          ]
        },
        {
          id: '2',
          user_name: 'video_lover',
          comment: 'Where was this filmed? The scenery is breathtaking!',
          created_at: new Date(Date.now() - 7200000).toISOString(),
          likes: 5,
          replies: []
        },
        {
          id: '3',
          user_name: 'traveler',
          comment: 'I\'ve been there too! Such a beautiful place.',
          created_at: new Date(Date.now() - 10800000).toISOString(),
          likes: 2,
          replies: [
            {
              id: '3-1',
              user_name: 'user123',
              comment: 'Lucky you! I hope to visit someday.',
              created_at: new Date(Date.now() - 5400000).toISOString(),
              likes: 0
            },
            {
              id: '3-2',
              user_name: 'traveler',
              comment: 'You should definitely go! It\'s worth it.',
              created_at: new Date(Date.now() - 3600000).toISOString(),
              likes: 1
            }
          ]
        }
      ];
      
      this.renderComments(commentsList, mockComments);
      
    } catch (error) {
      console.error('Error loading comments:', error);
      commentsList.innerHTML = '<div class="comment error-comment">Failed to load comments</div>';
    }
  }

  renderComments(commentsList, comments) {
    commentsList.innerHTML = '';
    
    if (comments.length === 0) {
      commentsList.innerHTML = '<div class="comment no-comments">No comments yet. Be the first to comment!</div>';
      return;
    }
    
    comments.forEach(comment => {
      const commentEl = this.createCommentElement(comment);
      commentsList.appendChild(commentEl);
    });
  }

  createCommentElement(comment) {
    const commentEl = document.createElement('div');
    commentEl.className = 'comment';
    commentEl.dataset.commentId = comment.id;
    
    const timeAgo = this.getTimeAgo(comment.created_at);
    
    commentEl.innerHTML = `
      <div class="comment-header">
        <div class="comment-user">@${comment.user_name}</div>
        <div class="comment-time">${timeAgo}</div>
      </div>
      <div class="comment-text">${comment.comment}</div>
      <div class="comment-actions">
        <button class="comment-action like-comment">👍 ${comment.likes || 0}</button>
        <button class="comment-action reply-comment">Reply</button>
      </div>
    `;
    
    // Add replies if they exist
    if (comment.replies && comment.replies.length > 0) {
      const repliesSection = document.createElement('div');
      repliesSection.className = 'replies-list';
      
      comment.replies.forEach(reply => {
        const replyEl = this.createReplyElement(reply);
        repliesSection.appendChild(replyEl);
      });
      
      commentEl.appendChild(repliesSection);
    }
    
    return commentEl;
  }

  createReplyElement(reply) {
    const replyEl = document.createElement('div');
    replyEl.className = 'reply';
    replyEl.dataset.replyId = reply.id;
    
    const timeAgo = this.getTimeAgo(reply.created_at);
    
    replyEl.innerHTML = `
      <div class="comment-header">
        <div class="comment-user">@${reply.user_name}</div>
        <div class="comment-time">${timeAgo}</div>
      </div>
      <div class="comment-text">${reply.comment}</div>
      <div class="comment-actions">
        <button class="comment-action like-comment">👍 ${reply.likes || 0}</button>
      </div>
    `;
    
    return replyEl;
  }

  getTimeAgo(timestamp) {
    const now = new Date();
    const past = new Date(timestamp);
    const diffMs = now - past;
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    
    if (diffMins < 1) return 'just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    
    return past.toLocaleDateString();
  }

  startReply(button) {
    const commentEl = button.closest('.comment');
    const commentId = commentEl.dataset.commentId;
    const userName = commentEl.querySelector('.comment-user').textContent;
    
    this.replyingTo = {
      id: commentId,
      userName: userName
    };
    
    // Update the input placeholder to show we're replying
    const postEl = commentEl.closest('.post');
    const commentInput = postEl.querySelector('.comment-input input');
    commentInput.placeholder = `Replying to ${userName}...`;
    
    // Add cancel button
    const drawerFooter = postEl.querySelector('.drawer-footer');
    if (!drawerFooter.querySelector('.cancel-reply')) {
      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'cancel-reply';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style.padding = '8px 12px';
      cancelBtn.style.borderRadius = '10px';
      cancelBtn.style.border = 'none';
      cancelBtn.style.background = 'rgba(255,255,255,0.1)';
      cancelBtn.style.color = 'inherit';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.style.fontFamily = "'Poppins', sans-serif";
      drawerFooter.appendChild(cancelBtn);
    }
    
    // Scroll to input
    commentInput.focus();
  }

  cancelReply() {
    this.replyingTo = null;
    
    // Reset all input placeholders
    document.querySelectorAll('.comment-input input').forEach(input => {
      input.placeholder = 'Write your comment...';
    });
    
    // Remove all cancel buttons
    document.querySelectorAll('.cancel-reply').forEach(btn => {
      btn.remove();
    });
  }

  async sendComment(button) {
    const postEl = button.closest('.post');
    const postId = postEl.dataset.id;
    const commentInput = postEl.querySelector('.comment-input input');
    const commentsList = postEl.querySelector('.comments-list');
    const commentText = commentInput.value.trim();
    
    if (!commentText) return;
    
    // Check if user is signed in
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      showAuthModal();
      return;
    }
    
    try {
      const userName = session.user.user_metadata?.username || session.user.email.split('@')[0];
      
      if (this.replyingTo) {
        // This is a reply
        const { error } = await supabase.from('comments').insert({
          post_id: postId,
          user_id: session.user.id,
          user_name: userName,
          comment: commentText,
          parent_id: this.replyingTo.id
        });

        if (error) {
          // Fallback to local storage if table doesn't exist
          console.warn('Comments table not available, using local storage for reply');
          // In a real app, you would update the UI with the new reply
        }
        
        this.cancelReply();
      } else {
        // This is a top-level comment
        const { error } = await supabase.from('comments').insert({
          post_id: postId,
          user_id: session.user.id,
          user_name: userName,
          comment: commentText
        });

        if (error) {
          // Fallback to local storage if table doesn't exist
          console.warn('Comments table not available, using local storage for comment');
          // In a real app, you would update the UI with the new comment
        }
      }
      
      // Clear input
      commentInput.value = '';
      
      // Reload comments to show the new one
      await this.loadComments(postId, commentsList);
      
    } catch (error) {
      console.error('Error posting comment:', error);
      alert('Error posting comment. Please try again.');
    }
  }
}

const commentManager = new CommentManager();

// Avatar and session management
const sessionInfoEl = document.getElementById('sessionInfo');
const userAvatar = document.getElementById('userAvatar');

async function updateSessionInfo() {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      // When user is not signed in, show a login link
      sessionInfoEl.innerHTML = `
        <div class="avatar" style="cursor: pointer; background: linear-gradient(135deg, var(--accent), #b473ff);" title="Sign in to Skrolz">
          <a href="#" class="login-link" style="color: white; text-decoration: none; font-size: 14px; font-weight: 600;">🔐</a>
        </div>
      `;
      
      // Add click event to show auth modal
      const loginAvatar = sessionInfoEl.querySelector('.avatar');
      if (loginAvatar) {
        loginAvatar.onclick = showAuthModal;
      }
      return null;
    }
    const u = session.user;
    const name = u.user_metadata?.username || u.user_metadata?.full_name || u.email || u.id;
    const initial = name.charAt(0).toUpperCase();
    userAvatar.textContent = initial;
    sessionInfoEl.innerHTML = `<div class="avatar">${initial}</div>`;
    return session;
  } catch (err) {
    console.error('updateSessionInfo error', err);
    sessionInfoEl.innerHTML = '<div class="avatar">!</div>';
    return null;
  }
}

function setupAuthListener() {
  supabase.auth.onAuthStateChange((event, session) => {
    updateSessionInfo().catch(() => {});
    if (event === 'SIGNED_OUT') {
      showAuthModal();
    }
  });
}

// Post loading with proper like handling
async function loadInitialPosts(limit = 10) {
  try {
    await updateSessionInfo();
    const { data: { session } } = await supabase.auth.getSession();
    const currentUserId = session?.user?.id || null;

    // Load posts from Supabase - match your actual schema columns
    const { data, error } = await supabase
      .from('posts')
      .select(`
        id, 
        author_id, 
        author_name, 
        video_url, 
        created_at, 
        title,
        caption,
        likes_count,
        views
      `)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error loading posts:', error);
      loadMockData();
      return;
    }

    if (data && data.length > 0) {
      const postsWithLikes = await Promise.all(data.map(async (post) => {
        // Get user like status
        let userLiked = false;
        if (currentUserId) {
          const { data: userLike } = await supabase
            .from('likes')
            .select('id')
            .eq('post_id', post.id)
            .eq('user_id', currentUserId)
            .single();
          userLiked = !!userLike;
        }

        return {
          id: post.id,
          user: post.author_name ? `@${post.author_name}` : `@user_${post.author_id?.slice(0, 8)}`,
          title: post.title || 'Untitled',
          caption: post.caption || '',
          src: post.video_url,
          likes: post.likes_count || 0,
          views: post.views || 0,
          comments: [],
          liked: userLiked,
          uploading: false,
          owner: currentUserId && post.author_id === currentUserId,
          paused: false, // Start playing by default
        };
      }));

      allPosts = postsWithLikes;
      posts = [...allPosts];
      console.log(`Loaded ${posts.length} posts from Supabase`);
      
      // Setup realtime subscriptions for all loaded posts
      setupRealtimeSubscriptions();
    } else {
      loadMockData();
    }
  } catch (err) {
    console.error('Error loading initial posts:', err);
    loadMockData();
  }
}

function loadMockData() {
  console.log('Loading mock data...');
  allPosts = [
    {
      id: '1',
      user: '@creative_mind',
      title: 'Sunset Vibes 🌅',
      caption: 'Chasing golden hour never gets old',
      src: 'https://assets.mixkit.co/videos/preview/mixkit-sunset-over-a-stone-beach-40657-large.mp4',
      likes: 42,
      views: 1250,
      comments: ['So beautiful!', 'Where was this taken?'],
      liked: false,
      uploading: false,
      owner: false,
      paused: false,
    },
    {
      id: '2', 
      user: '@tech_guru',
      title: 'Coding Session',
      caption: 'Late night coding with some lo-fi beats',
      src: 'https://assets.mixkit.co/videos/preview/mixkit-close-up-of-computer-keyboard-40659-large.mp4',
      likes: 18,
      views: 890,
      comments: ['What language is this?', 'Great setup!'],
      liked: false,
      uploading: false,
      owner: false,
      paused: false,
    },
    {
      id: '3',
      user: '@adventure_seeker',
      title: 'Mountain Hike',
      caption: 'The view from the top was worth every step',
      src: 'https://assets.mixkit.co/videos/preview/mixkit-walking-on-a-mountain-40658-large.mp4',
      likes: 156,
      views: 3200,
      comments: ['Amazing view!', 'Which mountain is this?'],
      liked: false,
      uploading: false,
      owner: false,
      paused: false,
    }
  ];
  posts = [...allPosts];
}

// Setup realtime subscriptions for likes and comments
function setupRealtimeSubscriptions() {
  // Subscribe to likes changes
  const likesSubscription = supabase
    .channel('likes-changes')
    .on('postgres_changes', 
      { 
        event: '*', 
        schema: 'public', 
        table: 'likes' 
      }, 
      (payload) => {
        console.log('Likes change received!', payload);
        handleLikesChange(payload);
      }
    )
    .subscribe();

  // Subscribe to comments changes
  const commentsSubscription = supabase
    .channel('comments-changes')
    .on('postgres_changes', 
      { 
        event: '*', 
        schema: 'public', 
        table: 'comments' 
      }, 
      (payload) => {
        console.log('Comments change received!', payload);
        handleCommentsChange(payload);
      }
    )
    .subscribe();

  // Subscribe to posts changes for view counts
  const postsSubscription = supabase
    .channel('posts-changes')
    .on('postgres_changes', 
      { 
        event: 'UPDATE', 
        schema: 'public', 
        table: 'posts' 
      }, 
      (payload) => {
        console.log('Posts change received!', payload);
        handlePostsChange(payload);
      }
    )
    .subscribe();

  // Store subscriptions for cleanup if needed
  realtimeSubscriptions.likes = likesSubscription;
  realtimeSubscriptions.comments = commentsSubscription;
  realtimeSubscriptions.posts = postsSubscription;
}

function handleLikesChange(payload) {
  const { eventType, new: newRecord, old: oldRecord } = payload;
  
  if (eventType === 'INSERT') {
    // New like added
    const postId = newRecord.post_id;
    const post = allPosts.find(p => p.id === postId);
    if (post) {
      post.likes = (post.likes || 0) + 1;
      updatePostElement(postId, post);
    }
  } else if (eventType === 'DELETE') {
    // Like removed
    const postId = oldRecord.post_id;
    const post = allPosts.find(p => p.id === postId);
    if (post) {
      post.likes = Math.max(0, (post.likes || 1) - 1);
      updatePostElement(postId, post);
    }
  }
}

function handleCommentsChange(payload) {
  const { eventType, new: newRecord } = payload;
  
  if (eventType === 'INSERT') {
    // New comment added
    const postId = newRecord.post_id;
    const post = allPosts.find(p => p.id === postId);
    if (post) {
      // Reload comments for this post
      const postEl = document.querySelector(`[data-id="${postId}"]`);
      if (postEl) {
        const commentsList = postEl.querySelector('.comments-list');
        if (commentsList) {
          commentManager.loadComments(postId, commentsList);
        }
      }
    }
  }
}

function handlePostsChange(payload) {
  const { new: newRecord } = payload;
  
  // Update view count
  const postId = newRecord.id;
  const post = allPosts.find(p => p.id === postId);
  if (post && newRecord.views !== undefined) {
    post.views = newRecord.views;
    updatePostElement(postId, post);
  }
}

// Search functionality
const searchBar = document.getElementById('searchBar');

function setupEventListeners() {
  searchBar.addEventListener('input', debounce((e) => {
    searchQuery = e.target.value.toLowerCase();
    filterPosts();
    renderFeed();
  }, 300));

  document.getElementById('fab').addEventListener('click', () => {
    supabase.auth.getSession().then(({ data: { session } }) => {
      if (session) {
        openUploadModal();
      } else {
        showAuthModal();
      }
    });
  });

  // Auth modal buttons
  document.getElementById('signInBtn').addEventListener('click', () => {
    // Implement sign in logic here
    hideAuthModal();
    console.log('Sign in clicked');
  });

  document.getElementById('signUpBtn').addEventListener('click', () => {
    // Implement sign up logic here
    hideAuthModal();
    console.log('Sign up clicked');
  });

  setupThemeSwipe();
  
  // Enable audio on first user interaction
  document.addEventListener('click', enableAudio, { once: true });
  document.addEventListener('touchstart', enableAudio, { once: true });
}

function enableAudio() {
  userInteracted = true;
  audioEnabled = true;
  
  // Unmute all videos and try to play them
  document.querySelectorAll('.post video').forEach(video => {
    video.muted = false;
    if (isElementInViewport(video.closest('.post'))) {
      video.play().catch(e => {
        console.log('Audio play failed, keeping muted:', e);
        video.muted = true;
        video.play().catch(console.error);
      });
    }
  });
}

function isElementInViewport(el) {
  const rect = el.getBoundingClientRect();
  return (
    rect.top >= 0 &&
    rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
  );
}

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function filterPosts() {
  if (!searchQuery) {
    posts = [...allPosts];
  } else {
    posts = allPosts.filter(post =>
      post.user.toLowerCase().includes(searchQuery) ||
      (post.title && post.title.toLowerCase().includes(searchQuery)) ||
      (post.caption && post.caption.toLowerCase().includes(searchQuery))
    );
  }
}

// Feed rendering with videos
function renderFeed() {
  if (!feed) return;

  feed.innerHTML = `
    <div id="pullIndicator">
      <div><span id="pullIcon">⬇</span><span id="pullText" class="muted">Pull to refresh</span></div>
    </div>
    <div id="feedContent"></div>
  `;

  feedContent = document.getElementById('feedContent');

  if (posts.length === 0) {
    feedContent.innerHTML = `
      <div style="color: var(--muted); text-align: center; padding: 50px;">
        ${searchQuery ? 'No posts found' : 'No posts available'}
      </div>
    `;
    return;
  }

  posts.forEach((post, index) => {
    const postEl = createPostElement(post, index);
    feedContent.appendChild(postEl);
  });

  setupPullToRefresh();
  setupVideoPlayback();
  setupInfiniteScroll();
}

function createPostElement(post, index) {
  const postEl = document.createElement('article');
  postEl.className = `post ${post.paused ? 'paused' : ''} ${post.uploading ? 'uploading' : ''}`;
  postEl.dataset.id = post.id;
  postEl.dataset.index = index;
  
  // Start with muted video for autoplay, will be unmuted after user interaction
  const shouldMute = !audioEnabled;
  
  postEl.innerHTML = `
    <div class="post-inner">
      ${post.uploading ? `<div class="upload-progress"><div class="upload-progress-bar" style="width: ${post.uploadProgress || 0}%"></div></div>` : ''}
      
      <!-- Video Element -->
      <video 
        playsinline 
        ${shouldMute ? 'muted' : ''}
        loop 
        preload="auto" 
        crossorigin="anonymous"
        oncontextmenu="return false;"
        style="width: 100%; height: 100%; object-fit: cover;"
      >
        ${post.src ? `<source src="${post.src}" type="video/mp4">` : ''}
      </video>
      
      <div class="blue-heart">♥</div>
      <div class="play-overlay"><div class="play-icon">▶</div></div>
      <div class="overlay">
        <h3>${post.user}</h3>
        <div class="post-title">${post.title}</div>
        ${post.caption ? `<div class="post-caption">${post.caption}</div>` : ''}
      </div>
      <div class="icons">
        <div class="icon-wrap">
          <button class="btn like-btn ${post.liked ? 'liked' : ''}" title="Like">♡</button>
          <div class="icon-count like-count">${post.likes}</div>
        </div>
        <div class="icon-wrap">
          <button class="btn comment-open" title="Comments">💬</button>
          <div class="icon-count comment-count">${post.comments ? post.comments.length : 0}</div>
        </div>
        <div class="icon-wrap">
          <div class="btn view-btn" title="Views">👁️</div>
          <div class="icon-count view-count">${post.views || 0}</div>
        </div>
        <button class="btn share-btn" title="Share">↗️</button>
        ${post.owner ? '<button class="btn delete-btn" title="Delete Post">🗑️</button>' : ''}
      </div>
      
      <div class="drawer">
        <div class="drawer-inner">
          <div class="drawer-handle"></div>
          <div class="comments-header">Comments</div>
          <div class="comments-list" aria-live="polite"></div>
          <div class="drawer-footer">
            <div class="comment-input"><input placeholder="Write your comment..." /></div>
            <button class="send-small">Send</button>
          </div>
        </div>
      </div>
    </div>
  `;

  attachPostBehavior(postEl, post);
  return postEl;
}

function attachPostBehavior(postEl, postData) {
  const video = postEl.querySelector('video');
  const likeBtn = postEl.querySelector('.like-btn');
  const deleteBtn = postEl.querySelector('.delete-btn');
  const commentOpen = postEl.querySelector('.comment-open');
  const shareBtn = postEl.querySelector('.share-btn');
  const drawer = postEl.querySelector('.drawer');

  // Load video source if available and ensure it's playable
  if (postData.src && video) {
    const source = video.querySelector('Facts');
    if (source) {
      source.src = postData.src;
      video.load().catch(e => {
        console.error('Video load error:', e);
      });
    }
  }

  // Improved double tap to like with better detection
  let lastTap = 0;
  let tapTimeout;
  
  postEl.addEventListener('touchstart', (e) => {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    
    if (tapLength < 500 && tapLength > 0) {
      // Double tap detected
      e.preventDefault();
      clearTimeout(tapTimeout);
      
      // Check if user is signed in
      supabase.auth.getSession().then(({ data: { session } }) => {
        if (!session) {
          showAuthModal();
          return;
        }
        
        if (!postData.liked) {
          likeManager.handleLike(likeBtn);
          showBlueHeart(postEl);
        }
      });
      
      lastTap = 0;
    } else {
      lastTap = currentTime;
      tapTimeout = setTimeout(() => {
        lastTap = 0;
      }, 500);
    }
  });

  // Also support double click for desktop
  postEl.addEventListener('dblclick', (e) => {
    if (e.target.closest('.icons') || e.target.closest('.drawer')) return;
    
    // Check if user is signed in
    supabase.auth.getSession().then(({ data: { session } }) => {
      if (!session) {
        showAuthModal();
        return;
      }
      
      if (!postData.liked) {
        likeManager.handleLike(likeBtn);
        showBlueHeart(postEl);
      }
    });
  });

  // Single tap to pause/play
  postEl.addEventListener('click', (e) => {
    if (e.target.closest('.icons') || e.target.closest('.drawer')) return;
    
    // Single tap - toggle play/pause
    if (video.paused) {
      video.play().catch(console.error);
      postData.paused = false;
      postEl.classList.remove('paused');
      
      // Increment view count when video starts playing
      if (!viewedPosts.has(postData.id)) {
        viewedPosts.add(postData.id);
        incrementViewCount(postData.id);
      }
    } else {
      video.pause();
      postData.paused = true;
      postEl.classList.add('paused');
    }
  });

  // Like button
  likeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    likeManager.handleLike(likeBtn);
  });

  // Delete post
  if (deleteBtn) {
    deleteBtn.addEventListener('click', async (e) => {
      e.stopPropagation();
      if (confirm('Delete this post permanently?')) {
        try {
          await supabase.from('posts').delete().eq('id', postData.id);
          allPosts = allPosts.filter(p => p.id !== postData.id);
          posts = posts.filter(p => p.id !== postData.id);
          postEl.remove();
        } catch (error) {
          console.error('Error deleting post:', error);
          alert('Error deleting post');
        }
      }
    });
  }

  // Share post - FIXED for all users
  if (shareBtn) {
    shareBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const shareUrl = `${window.location.origin}/post/${postData.id}`;
      if (navigator.share) {
        navigator.share({
          title: `${postData.title} by ${postData.user}`,
          text: postData.caption,
          url: shareUrl,
        }).catch(() => {
          // Fallback to clipboard if share fails
          navigator.clipboard.writeText(shareUrl).then(() => {
            alert('Link copied to clipboard!');
          });
        });
      } else {
        navigator.clipboard.writeText(shareUrl).then(() => {
          alert('Link copied to clipboard!');
        });
      }
    });
  }

  // Comments drawer - ENABLED for all users including owners
  if (commentOpen) {
    commentOpen.addEventListener('click', (e) => {
      e.stopPropagation();
      commentManager.openComments(commentOpen);
    });
  }

  // Close drawer when clicking outside
  document.addEventListener('click', (e) => {
    if (drawer.classList.contains('open') && !e.target.closest('.drawer') && !e.target.closest('.comment-open')) {
      drawer.classList.remove('open');
      commentManager.cancelReply();
    }
  });
}

// View count increment function
async function incrementViewCount(postId) {
  try {
    const { error } = await supabase.rpc('increment_views', { post_id: postId });
    if (error) throw error;
    
    // Update local post data
    const post = allPosts.find(p => p.id === postId);
    if (post) {
      post.views = (post.views || 0) + 1;
      updatePostElement(postId, post);
    }
  } catch (error) {
    console.error('Error incrementing view count:', error);
  }
}

function updatePostElement(postId, postData) {
  const postEl = document.querySelector(`[data-id="${postId}"]`);
  if (!postEl) return;
  
  const likeBtn = postEl.querySelector('.like-btn');
  const likeCountEl = postEl.querySelector('.like-count');
  const commentCountEl = postEl.querySelector('.comment-count');
  const viewCountEl = postEl.querySelector('.view-count');
  const overlay = postEl.querySelector('.overlay h3');
  const titleEl = postEl.querySelector('.post-title');
  const captionEl = postEl.querySelector('.post-caption');
  
  if (likeBtn) likeBtn.classList.toggle('liked', postData.liked);
  if (likeCountEl) likeCountEl.textContent = postData.likes;
  if (commentCountEl) commentCountEl.textContent = postData.comments ? postData.comments.length : 0;
  if (viewCountEl) viewCountEl.textContent = postData.views || 0;
  if (overlay) overlay.textContent = postData.user;
  if (titleEl) titleEl.textContent = postData.title;
  if (captionEl) {
    if (postData.caption) {
      captionEl.textContent = postData.caption;
      captionEl.style.display = 'block';
    } else {
      captionEl.style.display = 'none';
    }
  }
}

function showBlueHeart(postEl) {
  const blueHeart = postEl.querySelector('.blue-heart');
  blueHeart.classList.remove('animate');
  void blueHeart.offsetWidth; // Trigger reflow
  blueHeart.classList.add('animate');
}

// Video playback management - FIXED autoplay issues
function setupVideoPlayback() {
  const videos = document.querySelectorAll('.post video');
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      const video = entry.target;
      const postEl = video.closest('.post');
      
      if (entry.isIntersecting && entry.intersectionRatio > 0.7) {
        // Play video when in view
        if (!postEl.classList.contains('paused')) {
          video.play().catch(e => {
            console.log('Autoplay prevented:', e);
            // If autoplay fails, mute and try again
            video.muted = true;
            video.play().catch(console.error);
          });
        }
      } else {
        // Pause video when not in view
        video.pause();
      }
    });
  }, { threshold: [0.7] });

  videos.forEach(video => observer.observe(video));
}

// Smooth scrolling between videos
function setupSmoothScrolling() {
  let isScrolling = false;
  let scrollTimer;
  
  feed.addEventListener('scroll', () => {
    if (!isScrolling) {
      isScrolling = true;
      
      // Show swipe indicator when near bottom
      const { scrollTop, scrollHeight, clientHeight } = feed;
      if (scrollHeight - scrollTop - clientHeight < 100) {
        showSwipeIndicator();
      }
    }
    
    clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => {
      isScrolling = false;
      
      // Find the post that's most visible and ensure it's playing
      const posts = document.querySelectorAll('.post');
      let mostVisiblePost = null;
      let maxVisibility = 0;
      
      posts.forEach(post => {
        const rect = post.getBoundingClientRect();
        const visibility = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
        
        if (visibility > maxVisibility) {
          maxVisibility = visibility;
          mostVisiblePost = post;
        }
      });
      
      // Play the most visible video and pause others
      if (mostVisiblePost) {
        posts.forEach(post => {
          const video = post.querySelector('video');
          if (post === mostVisiblePost) {
            if (video && video.paused) {
              video.play().catch(e => {
                console.log('Video play failed:', e);
              });
            }
          } else {
            if (video && !video.paused) {
              video.pause();
            }
          }
        });
      }
    }, 100);
  });
  
  // Add keyboard navigation
  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowDown' || e.key === ' ') {
      e.preventDefault();
      scrollToNextVideo();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      scrollToPreviousVideo();
    }
  });
  
  // Add touch swipe detection
  let touchStartY = 0;
  
  feed.addEventListener('touchstart', (e) => {
    touchStartY = e.touches[0].clientY;
  }, { passive: true });
  
  feed.addEventListener('touchend', (e) => {
    const touchEndY = e.changedTouches[0].clientY;
    const deltaY = touchEndY - touchStartY;
    
    if (Math.abs(deltaY) > 50) {
      if (deltaY < 0) {
        // Swipe up - next video
        scrollToNextVideo();
      } else {
        // Swipe down - previous video
        scrollToPreviousVideo();
      }
    }
  }, { passive: true });
}

function scrollToNextVideo() {
  const posts = document.querySelectorAll('.post');
  const currentScroll = feed.scrollTop;
  let targetPost = null;
  
  for (let i = 0; i < posts.length; i++) {
    const postTop = posts[i].offsetTop;
    if (postTop > currentScroll + 50) {
      targetPost = posts[i];
      break;
    }
  }
  
  if (targetPost) {
    targetPost.scrollIntoView({ behavior: 'smooth', block: 'start' });
  } else if (posts.length > 0) {
    // If at the end, loop to first post
    posts[0].scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

function scrollToPreviousVideo() {
  const posts = document.querySelectorAll('.post');
  const currentScroll = feed.scrollTop;
  let targetPost = null;
  
  for (let i = posts.length - 1; i >= 0; i--) {
    const postTop = posts[i].offsetTop;
    if (postTop < currentScroll - 50) {
      targetPost = posts[i];
      break;
    }
  }
  
  if (targetPost) {
    targetPost.scrollIntoView({ behavior: 'smooth', block: 'start' });
  } else if (posts.length > 0) {
    // If at the beginning, loop to last post
    posts[posts.length - 1].scrollIntoView({ behavior: 'smooth', block: 'start' });
  }
}

// Improved Pull to refresh
function setupPullToRefresh() {
  let startY = 0;
  let pulling = false;
  let translateY = 0;
  const refreshThreshold = 100;

  if (!feedContent) return;

  feed.addEventListener('pointerdown', (e) => {
    if (e.pointerType !== 'touch' || feed.scrollTop !== 0 || isRefreshing) return;
    startY = e.clientY;
    pulling = true;
    feedContent.style.transition = 'none';
  });

  feed.addEventListener('pointermove', (e) => {
    if (!pulling || isRefreshing) return;
    const deltaY = e.clientY - startY;
    if (deltaY <= 0) return;
    e.preventDefault();
    translateY = deltaY * 0.5;
    translateY = Math.min(translateY, 200);
    feedContent.style.transform = `translateY(${translateY}px)`;
    updateRefreshIndicator(translateY);
  });

  feed.addEventListener('pointerup', () => {
    if (!pulling || isRefreshing) return;
    pulling = false;
    if (translateY >= refreshThreshold) {
      refreshContent();
    } else {
      resetPull();
    }
  });

  function updateRefreshIndicator(dist) {
    const indicator = document.getElementById('pullIndicator');
    const icon = document.getElementById('pullIcon');
    const text = document.getElementById('pullText');

    if (dist < 10) {
      indicator.style.opacity = '0';
      indicator.style.transform = 'translateX(-50%) translateY(-100%)';
      return;
    }

    indicator.style.opacity = '1';
    indicator.style.transform = 'translateX(-50%) translateY(0px)';

    if (dist > refreshThreshold) {
      icon.textContent = '○';
      text.textContent = 'Release to refresh';
    } else {
      icon.textContent = '⬇';
      text.textContent = 'Pull to refresh';
    }
  }

  function resetPull() {
    feedContent.style.transition = 'transform 0.3s ease';
    feedContent.style.transform = 'translateY(0px)';
    updateRefreshIndicator(0);
  }

  async function refreshContent() {
    isRefreshing = true;
    const indicator = document.getElementById('pullIndicator');
    const icon = document.getElementById('pullIcon');
    const text = document.getElementById('pullText');

    icon.textContent = '🔄';
    icon.classList.add('refreshing');
    text.textContent = 'Refreshing...';

    try {
      await loadInitialPosts();
      renderFeed();
      icon.textContent = '✅';
      text.textContent = 'Updated!';
    } catch (error) {
      console.error('Refresh error:', error);
      icon.textContent = '❌';
      text.textContent = 'Refresh failed';
    } finally {
      setTimeout(() => {
        indicator.style.opacity = '0';
        resetPull();
        isRefreshing = false;
        icon.classList.remove('refreshing');
      }, 1000);
    }
  }
}

// Infinite scroll
function setupInfiniteScroll() {
  let loading = false;

  feed.addEventListener('scroll', debounce(() => {
    if (loading || searchQuery || isRefreshing) return;
    
    const { scrollTop, scrollHeight, clientHeight } = feed;
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      loading = true;
      loadMorePosts().finally(() => {
        loading = false;
      });
    }
  }, 100));
}

async function loadMorePosts() {
  try {
    const { data, error } = await supabase
      .from('posts')
      .select('id, author_id, author_name, video_url, created_at, title, caption, likes_count, views')
      .order('created_at', { ascending: false })
      .range(allPosts.length, allPosts.length + 4);

    if (error) throw error;

    if (data && data.length > 0) {
      const { data: { session } } = await supabase.auth.getSession();
      const currentUserId = session?.user?.id || null;

      const newPosts = await Promise.all(data.map(async (post) => {
        const { data: userLike } = await supabase
          .from('likes')
          .select('id')
          .eq('post_id', post.id)
          .eq('user_id', currentUserId)
          .single();
        
        const userLiked = !!userLike;

        return {
          id: post.id,
          user: post.author_name ? `@${post.author_name}` : `@user_${post.author_id?.slice(0, 8)}`,
          title: post.title || 'Untitled',
          caption: post.caption || '',
          src: post.video_url,
          likes: post.likes_count || 0,
          views: post.views || 0,
          comments: [],
          liked: userLiked,
          uploading: false,
          owner: currentUserId && post.author_id === currentUserId,
          paused: false,
        };
      }));

      allPosts.push(...newPosts);
      posts = [...allPosts];
      renderFeed();
    }
  } catch (error) {
    console.error('Error loading more posts:', error);
  }
}

// Theme swipe functionality
function setupThemeSwipe() {
  const header = document.getElementById('header');
  let pDown = false, pStartX = 0;
  
  header.addEventListener('pointerdown', (e) => {
    pDown = true;
    pStartX = e.clientX;
  });
  
  header.addEventListener('pointermove', (e) => {
    if (!pDown) return;
    const dx = e.clientX - pStartX;
    header.style.transform = `translateX(${dx * 0.08}px)`;
  });
  
  header.addEventListener('pointerup', (e) => {
    header.style.transform = '';
    if (!pDown) return;
    pDown = false;
    const dx = e.clientX - pStartX;
    const threshold = 80;
    if (dx <= -threshold || dx >= threshold) {
      document.documentElement.classList.toggle('light');
    }
  });
}

// Upload functionality - FIXED VERSION
function openUploadModal() {
  uploadModal.classList.add('show');
  
  document.getElementById('closeUpload').addEventListener('click', () => {
    uploadModal.classList.remove('show');
  });

  document.getElementById('recordBtn').addEventListener('click', openRecordModal);
  
  document.getElementById('filePicker').addEventListener('change', handleFileUpload);
}

function openRecordModal() {
  const title = document.getElementById('uploadTitle').value.trim();
  const caption = document.getElementById('uploadCaption').value.trim();
  
  if (!title) {
    alert('Please enter a title for your video');
    return;
  }

  uploadModal.classList.remove('show');
  
  navigator.mediaDevices.getUserMedia({ video: true, audio: true })
    .then(stream => {
      const videoPreview = document.getElementById('videoPreview');
      videoPreview.srcObject = stream;

      const recordModal = document.getElementById('recordModal');
      recordModal.classList.add('show');

      let mediaRecorder;
      let recordedChunks = [];
      let recordingTimer;
      let recordingTime = 0;
      const recordBtnModal = document.getElementById('recordBtnModal');

      recordBtnModal.addEventListener('click', () => {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') {
          // Start recording
          mediaRecorder = new MediaRecorder(stream, { 
            mimeType: 'video/webm;codecs=vp9,opus',
            videoBitsPerSecond: 2500000
          });
          
          recordedChunks = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) recordedChunks.push(e.data);
          };
          
          mediaRecorder.onstop = async () => {
            clearInterval(recordingTimer);
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            
            const id = 'p' + Math.random().toString(36).slice(2, 9);
            const newPost = { 
              id, 
              user: `@you`, 
              title, 
              caption, 
              src: URL.createObjectURL(blob), 
              likes: 0, 
              views: 0,
              comments: [], 
              liked: false, 
              uploading: true, 
              owner: true, 
              uploadProgress: 0, 
              paused: false 
            };
            
            allPosts.unshift(newPost);
            filterPosts();
            renderFeed();
            uploadVideo(newPost, blob, title, caption);
            
            stream.getTracks().forEach(track => track.stop());
            recordedChunks = [];
            recordModal.classList.remove('show');
          };
          
          mediaRecorder.start(1000); // Collect data every second
          recordBtnModal.textContent = '⏹';
          recordBtnModal.classList.add('recording');
          
          // Start timer
          recordingTime = 0;
          recordingTimer = setInterval(() => {
            recordingTime++;
            if (recordingTime >= 60) {
              mediaRecorder.stop();
            }
          }, 1000);
        } else {
          // Stop recording
          mediaRecorder.stop();
          recordBtnModal.textContent = '⏺';
          recordBtnModal.classList.remove('recording');
        }
      });

      document.getElementById('closeRecord').addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }
        stream.getTracks().forEach(track => track.stop());
        recordModal.classList.remove('show');
        clearInterval(recordingTimer);
      });
    })
    .catch(err => {
      console.error('Camera access error:', err);
      alert('Camera access denied or not available.');
    });
}

// FIXED handleFileUpload function
async function handleFileUpload(e) {
  const file = e.target.files[0];
  const title = document.getElementById('uploadTitle').value.trim();
  const caption = document.getElementById('uploadCaption').value.trim();
  
  if (!title) {
    alert('Please enter a title for your video');
    return;
  }
  
  if (!file) return;
  
  if (!file.type.startsWith('video/')) {
    alert('Please select a video file');
    return;
  }

  // Reset file input
  e.target.value = '';
  
  try {
    uploadModal.classList.remove('show');
    
    // Create preview URL
    const previewUrl = URL.createObjectURL(file);
    
    const id = 'p' + Math.random().toString(36).slice(2, 9);
    const newPost = { 
      id, 
      user: `@you`, 
      title, 
      caption, 
      src: previewUrl, 
      likes: 0, 
      views: 0,
      comments: [], 
      liked: false, 
      uploading: true, 
      owner: true, 
      uploadProgress: 0, 
      paused: false 
    };
    
    allPosts.unshift(newPost);
    filterPosts();
    renderFeed();
    
    // Start upload
    await uploadVideo(newPost, file, title, caption);
    
  } catch (error) {
    console.error('Error processing video file:', error);
    alert('Error processing video file. Please try another file.');
    
    // Remove the failed post from the feed
    const index = allPosts.findIndex(p => p.id === newPost.id);
    if (index !== -1) {
      allPosts.splice(index, 1);
      filterPosts();
      renderFeed();
    }
  }
}

// FIXED uploadVideo function - with proper error handling for 406 errors
async function uploadVideo(post, file, title, caption) {
  progressModal.classList.add('show');
  updateProgress(0);
  
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      throw new Error('You must be signed in to upload.');
    }
    
    const userId = session.user.id;
    const authorName = session.user.user_metadata?.username || session.user.email.split('@')[0];
    
    // Generate unique filename
    const ext = file.name.split('.').pop() || 'mp4';
    const filename = `${Date.now()}_${Math.random().toString(36).slice(2, 8)}.${ext}`;
    const path = `posts/${userId}/${filename}`;

    // Progress simulation
    const progressInterval = setInterval(() => {
      if (post.uploadProgress < 80) {
        post.uploadProgress += Math.random() * 15;
        updateProgress(post.uploadProgress);
        updatePostElement(post.id, post);
      }
    }, 300);

    // Try to upload to storage - handle 406 errors
    let uploadData, uploadError;
    let bucketName = 'videos';
    
    console.log('Attempting upload to bucket:', bucketName);
    
    try {
      ({ data: uploadData, error: uploadError } = await supabase.storage
        .from(bucketName)
        .upload(path, file, {
          cacheControl: '3600',
          upsert: false
        }));

      // If 406 error, try with different content type
      if (uploadError && uploadError.statusCode === 406) {
        console.log('406 error received, trying with different approach...');
        
        // Create a new blob with explicit type
        const fileBlob = new Blob([file], { type: 'video/mp4' });
        
        ({ data: uploadData, error: uploadError } = await supabase.storage
          .from(bucketName)
          .upload(path, fileBlob, {
            cacheControl: '3600',
            upsert: false,
            contentType: 'video/mp4'
          }));
      }
    } catch (storageError) {
      console.error('Storage upload error:', storageError);
      uploadError = storageError;
    }

    clearInterval(progressInterval);

    if (uploadError) {
      console.error('Upload error:', uploadError);
      
      // If it's a 406 error, provide specific guidance
      if (uploadError.statusCode === 406) {
        throw new Error('Upload failed: The server cannot accept this file type. Please try a different video format (MP4 recommended).');
      } else {
        throw new Error(`Upload failed: ${uploadError.message}. Please check your storage buckets.`);
      }
    }

    // Get public URL
    const { data: urlData } = supabase.storage
      .from(bucketName)
      .getPublicUrl(uploadData.path);
    
    const publicUrl = urlData.publicUrl;
    console.log('Upload successful. Public URL:', publicUrl);

    // Update progress to 90%
    post.uploadProgress = 90;
    updateProgress(90);
    updatePostElement(post.id, post);

    // Insert into posts table - match your schema exactly
    const insertPayload = { 
      author_id: userId, 
      author_name: authorName, 
      video_url: publicUrl, 
      title: title,
      caption: caption,
      likes_count: 0, // Initialize likes_count to 0
      views: 0 // Initialize views to 0
    };
    
    console.log('Inserting post with payload:', insertPayload);
    
    const { data: inserted, error: insertError } = await supabase
      .from('posts')
      .insert(insertPayload)
      .select()
      .single();

    if (insertError) {
      console.error('Database insert error:', insertError);
      throw new Error(`Error saving post: ${insertError.message}`);
    }

    // Final update
    post.id = inserted.id;
    post.src = publicUrl;
    post.uploading = false;
    post.uploadProgress = 100;
    post.owner = true;
    
    updatePostElement(post.id, post);
    updateProgress(100);
    
    console.log('Post created successfully with ID:', inserted.id);
    
    // Hide progress modal
    setTimeout(() => {
      progressModal.classList.remove('show');
    }, 1000);
    
  } catch (err) {
    console.error('Upload process failed:', err);
    
    // Clean up on failure
    post.uploading = false;
    updatePostElement(post.id, post);
    updateProgress(100);
    
    setTimeout(() => {
      progressModal.classList.remove('show');
    }, 1000);
    
    alert('Upload failed: ' + (err?.message || 'Unknown error'));
    
    // Remove failed post from feed
    const index = allPosts.findIndex(p => p.id === post.id);
    if (index !== -1) {
      allPosts.splice(index, 1);
      filterPosts();
      renderFeed();
    }
  }
}

function updateProgress(percent) {
  progressFill.style.width = `${percent}%`;
  progressText.textContent = `Uploading... ${Math.round(percent)}%`;
}

// Global error handling
window.addEventListener('error', (e) => {
  console.error('Global error:', e.error);
});

window.addEventListener('unhandledrejection', (e) => {
  console.error('Unhandled promise rejection:', e.reason);
});

// Escape key to close modals
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    document.querySelectorAll('.drawer.open').forEach(d => {
      d.classList.remove('open');
    });
    uploadModal.classList.remove('show');
    document.getElementById('recordModal').classList.remove('show');
    authModal.classList.remove('show');
    commentManager.cancelReply();
  }
});
</script>
</body>
</html>
