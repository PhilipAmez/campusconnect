<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>PeerLoom • Live Class</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/js/all.min.js"></script>
  <script src="https://download.agora.io/sdk/release/AgoraRTC_N-4.18.2.js"></script>
  <script type="module" src="js/supabaseClient.js"></script>
  <link rel="stylesheet" href="livemeeting.css" />
</head>
<body class="dark-mode">

  <!-- Loading Overlay -->
  <div id="loading-overlay">
    <i class="fas fa-circle-notch fa-spin" style="font-size: 48px; color: var(--accent-blue); margin-bottom: 20px;"></i>
    <h2 style="margin: 0; color: var(--text-color);">Joining Class...</h2>
    <p id="loading-status" style="margin-top: 10px; opacity: 0.7;">Initializing secure session</p>
  </div>

  <!-- Critical Error Modal -->
  <div id="error-modal">
    <div class="error-content">
      <i class="fas fa-exclamation-triangle" style="font-size: 48px; color: var(--red); margin-bottom: 20px;"></i>
      <h2 style="margin: 0 0 10px;">Connection Failed</h2>
      <p id="error-message" style="opacity: 0.8; margin-bottom: 20px;">Unable to connect to the live session.</p>
      <button onclick="rejoinSession()" style="padding: 10px 20px; background: var(--accent-blue); border: none; border-radius: 8px; color: white; cursor: pointer;">Rejoin Session</button>
      <button onclick="window.location.href='dashboard.html'" style="padding: 10px 20px; background: transparent; border: 1px solid var(--text-color); border-radius: 8px; color: var(--text-color); cursor: pointer; margin-left: 10px;">Go Back</button>
    </div>
  </div>

  <!-- Styled Confirmation Modal -->
  <div id="confirmation-modal" style="position: fixed; inset: 0; background: rgba(0, 0, 0, 0.7); z-index: 9999; display: none; align-items: center; justify-content: center;">
    <div style="background: var(--glass-bg); backdrop-filter: var(--glass-blur); border: 1px solid var(--glass-border); padding: 30px; border-radius: 20px; text-align: center; max-width: 400px; box-shadow: var(--shadow);">
      <h2 id="modal-title" style="margin: 0 0 15px; font-size: 24px; color: var(--text-color);">Confirm Action</h2>
      <p id="modal-message" style="opacity: 0.8; margin-bottom: 25px;">Are you sure?</p>
      <div style="display: flex; gap: 10px; justify-content: center;">
        <button id="modal-cancel" style="padding: 12px 24px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px; color: var(--text-color); cursor: pointer; font-weight: 600; transition: all 0.2s;">Cancel</button>
        <button id="modal-confirm" style="padding: 12px 24px; background: var(--accent-blue); border: none; border-radius: 12px; color: white; cursor: pointer; font-weight: 600; transition: all 0.2s;">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Device Settings Modal -->
  <div id="device-settings-modal" class="attendance-modal" style="z-index: 9000;">
    <div class="attendance-content" style="max-width: 600px;">
      <h2 style="margin: 0 0 20px; font-size: 24px; color: var(--text-color);">Setup Devices</h2>
      
      <div class="device-preview" style="background: #000; height: 300px; border-radius: 16px; margin-bottom: 20px; position: relative; overflow: hidden;">
        <div id="local-preview" style="width: 100%; height: 100%;"></div>
        <div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; z-index: 10;">
           <div style="background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 20px; color: white; font-size: 12px;">Preview</div>
        </div>
      </div>

      <div style="margin-bottom: 15px;">
        <label style="display: block; margin-bottom: 8px; font-size: 14px; opacity: 0.8; color: var(--text-color);">Camera</label>
        <select id="camera-select" style="width: 100%; padding: 12px; border-radius: 12px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--glass-border); outline: none;">
        </select>
      </div>

      <div style="margin-bottom: 25px;">
        <label style="display: block; margin-bottom: 8px; font-size: 14px; opacity: 0.8; color: var(--text-color);">Microphone</label>
        <select id="mic-select" style="width: 100%; padding: 12px; border-radius: 12px; background: var(--input-bg); color: var(--text-color); border: 1px solid var(--glass-border); outline: none;">
        </select>
      </div>

      <button id="join-btn" style="width: 100%; padding: 14px; border-radius: 12px; background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); color: white; border: none; font-weight: 600; cursor: pointer; font-size: 16px;">
        Join Class
      </button>
    </div>
  </div>

  <!-- Video Area -->
  <div id="video-container" class="grid-mode">
    <div class="video-tile active-speaker" id="host-tile">
      <div class="video-placeholder">
        <i class="fas fa-crown" style="font-size: 36px; color: white;"></i>
      </div>
      <div class="name-tag">
        <span id="host-name">Loading...</span>
        <span class="host-badge">HOST</span>
      </div>
    </div>
  </div>

  <!-- Top Bar -->
  <div id="top-bar">
    <div class="title" id="class-title">PeerLoom Live Class</div>
    <div id="timer" class="text-base">00:00:00</div>
    <div class="flex items-center gap-4">
      <i class="fas fa-signal" style="color: var(--accent-green);"></i>
      <span class="text-sm opacity-90">HD</span>
      <button id="ai-toggle" class="tool-btn" title="AI Assistant">
        <i class="fas fa-robot"></i>
      </button>
      <button id="dark-mode-toggle" class="tool-btn" title="Toggle Theme">
        <i class="fas fa-moon"></i>
      </button>
    </div>
  </div>

  <!-- Desktop Chat Input (Above Control Bar) -->
  <div class="chat-input-desktop" id="chat-input-desktop">
    <div class="chat-input-desktop-wrapper">
      <input type="text" placeholder="Ask a question or share a thought..." class="chat-input-desktop-field" id="chat-desktop-input" />
      <div class="chat-input-desktop-actions">
        <button class="chat-input-desktop-btn" id="desktop-attach-btn" title="Attach file">
          <i class="fas fa-paperclip"></i>
        </button>
        <button class="chat-input-desktop-btn" id="desktop-emoji-btn" title="Emoji">
          <i class="fas fa-smile"></i>
        </button>
        <button class="chat-input-desktop-send" id="desktop-send-btn" title="Send message">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
    </div>
  </div>

  <!-- Control Bar -->
  <div id="control-bar">
    <button class="ctrl-btn active" data-action="mic" data-tooltip="Microphone">
      <i class="fas fa-microphone"></i>
    </button>
    <button class="ctrl-btn" data-action="cam" data-tooltip="Camera">
      <i class="fas fa-video"></i>
    </button>
    <button class="ctrl-btn" data-action="share" data-tooltip="Share Screen">
      <i class="fas fa-desktop"></i>
    </button>
    <button class="ctrl-btn host-only" data-action="record" data-tooltip="Record Session">
      <i class="fas fa-circle-dot"></i>
    </button>
    <button class="ctrl-btn host-only" data-action="attendance" data-tooltip="Attendance">
      <i class="fas fa-user-check"></i>
    </button>
    <button class="ctrl-btn" data-action="chat" data-tooltip="Chat">
      <i class="fas fa-comment-dots"></i>
    </button>
    <button class="ctrl-btn" data-action="hand" data-tooltip="Raise Hand">
      <i class="fas fa-hand"></i>
    </button>
    <button class="ctrl-btn" data-action="whiteboard" data-tooltip="Whiteboard">
      <i class="fas fa-paint-brush"></i>
    </button>
    <button class="ctrl-btn end" data-action="end" data-tooltip="End Call">
      <i class="fas fa-phone-slash"></i>
    </button>
  </div>

  <!-- Chat Drawer -->
  <div id="chat-drawer">
    <div id="chat-header">
      <div style="display: flex; align-items: center; gap: 12px;">
        <i class="fas fa-comments" style="font-size: 20px;"></i>
        <h3 style="margin: 0; font-size: 18px; font-weight: 600; color: var(--text-color);">Class Chat</h3>
        <div id="participant-count" style="background: var(--accent-blue); color: white; padding: 2px 10px; border-radius: 12px; font-size: 12px;">0</div>
      </div>
      <button id="close-chat-drawer" class="tool-btn">
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <div id="chat-messages">
      <!-- Messages will be loaded here -->
    </div>
    
    <!-- Chat Drawer Input -->
    <div id="chat-drawer-input-container">
      <div id="chat-drawer-input">
        <input type="text" placeholder="Type your message here..." id="chat-drawer-message-input" />
        <button id="chat-drawer-send-btn" style="width: 48px; height: 48px; border-radius: 50%; background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); border: none; color: white; display: flex; align-items: center; justify-content: center; cursor: pointer;">
          <i class="fas fa-paper-plane"></i>
        </button>
      </div>
    </div>
  </div>

  <!-- AI Panel -->
  <div id="ai-panel">
    <div class="ai-header">
      <div style="display: flex; align-items: center; gap: 12px;">
        <i class="fas fa-robot" style="font-size: 24px;"></i>
        <div>
          <h3 style="margin: 0; font-size: 18px; font-weight: 700;">PeerPal AI Assistant</h3>
          <p style="margin: 4px 0 0; opacity: 0.9; font-size: 14px;">Powered by Gemini 2.5 Flash</p>
        </div>
      </div>
    </div>
    
    <div class="ai-feature" onclick="generateSummary()">
      <div style="font-weight: 600; margin-bottom: 4px;">
        <i class="fas fa-file-alt" style="margin-right: 10px;"></i>
        Real-time Lesson Summary
      </div>
      <div style="font-size: 13px; opacity: 0.8;">Generate instant summaries with key points</div>
    </div>
    
    <div class="ai-feature" onclick="takeAttendance()">
      <div style="font-weight: 600; margin-bottom: 4px;">
        <i class="fas fa-user-check" style="margin-right: 10px;"></i>
        AI Attendance Report
      </div>
      <div style="font-size: 13px; opacity: 0.8;">Generate detailed attendance report with timestamps</div>
    </div>
    
    <div class="ai-feature" onclick="generateQuiz()">
      <div style="font-weight: 600; margin-bottom: 4px;">
        <i class="fas fa-question-circle" style="margin-right: 10px;"></i>
        Instant Quiz Generator
      </div>
      <div style="font-size: 13px; opacity: 0.8;">Create pop quizzes based on discussion</div>
    </div>
    
    <div class="ai-feature" onclick="suggestResources()">
      <div style="font-weight: 600; margin-bottom: 4px;">
        <i class="fas fa-lightbulb" style="margin-right: 10px;"></i>
        Resource Suggestions
      </div>
      <div style="font-size: 13px; opacity: 0.8;">Get AI-curated learning materials</div>
    </div>
    
    <div class="ai-loading" id="ai-loading">
      <i class="fas fa-spinner fa-spin"></i>
      <p style="margin-top: 8px;">AI is thinking...</p>
    </div>
  </div>

  <!-- Waiting Room Overlay for Students -->
  <div id="waiting-room-overlay" class="hidden">
    <div class="waiting-content">
      <i class="fas fa-clock" style="font-size: 48px; color: var(--accent-yellow); margin-bottom: 20px;"></i>
      <h2 style="margin: 0 0 10px;">Waiting for Host</h2>
      <p style="opacity: 0.8;">Please wait while the host admits you to the class.</p>
      <div style="margin-top: 20px; font-size: 24px; letter-spacing: 4px;">
        <i class="fas fa-spinner fa-spin"></i>
      </div>
    </div>
  </div>

  <!-- Host Tools -->
  <div id="host-tools">
    <button class="tool-btn" title="Mute All Students" id="mute-all-btn" onclick="muteAllParticipants()">
      <i class="fas fa-microphone-slash"></i>
    </button>
    <button class="tool-btn" title="Unmute All Students" id="unmute-all-btn" onclick="unmuteAllParticipants()" style="display:none;">
      <i class="fas fa-microphone"></i>
    </button>
    <button class="tool-btn" title="Disable All Cameras" id="disable-cameras-btn" onclick="disableAllCameras()">
      <i class="fas fa-video-slash"></i>
    </button>
    <button class="tool-btn" title="Enable All Cameras" id="enable-cameras-btn" onclick="enableAllCameras()" style="display:none;">
      <i class="fas fa-video"></i>
    </button>
    <button class="tool-btn" title="Lock All Media" id="lock-media-btn" onclick="lockAllMedia()">
      <i class="fas fa-shield-alt"></i>
    </button>
    <button class="tool-btn" title="Unlock All Media" id="unlock-media-btn" onclick="unlockAllMedia()" style="display:none;">
      <i class="fas fa-shield-alt" style="color: var(--accent-green);"></i>
    </button>
    <button id="spotlight-btn" class="tool-btn" title="Spotlight Host" onclick="toggleHostSpotlight()">
      <i class="fas fa-star"></i>
    </button>
    <button class="tool-btn" title="Screen Share Requests" onclick="showPendingRequests()">
      <i class="fas fa-check-circle"></i>
    </button>
    <button class="tool-btn" title="Copy Class Link" onclick="copyClassLink()">
      <i class="fas fa-link"></i>
    </button>
    <button class="tool-btn" title="Export Attendance" onclick="exportAttendance()">
      <i class="fas fa-download"></i>
    </button>
    <button class="tool-btn" title="Reset Waiting Room" onclick="resetAllRequests()">
      <i class="fas fa-sync"></i>
    </button>
    <button class="tool-btn" title="Waiting Room" onclick="openWaitingRoom()" style="position: relative;">
      <i class="fas fa-user-clock"></i>
      <div id="waiting-room-badge" class="waiting-badge" style="display: none;">0</div>
    </button>
    <button class="tool-btn" title="Clear All Hands" onclick="clearAllHands()">
      <i class="fas fa-hands"></i>
    </button>
  </div>

  <!-- Attendance Modal -->
  <div class="attendance-modal" id="attendance-modal">
    <div class="attendance-content">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="margin: 0; font-size: 24px; color: var(--text-color);">Attendance Report</h2>
        <button onclick="closeAttendanceModal()" class="tool-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <div class="attendance-list" id="attendance-list">
        <!-- Attendance items will be added here -->
      </div>
      
      <div style="display: flex; gap: 12px; margin-top: 20px;">
        <button onclick="exportAttendance()" style="flex: 1; padding: 12px; border-radius: 12px; background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); color: white; border: none; font-weight: 600; cursor: pointer;">
          <i class="fas fa-download" style="margin-right: 8px;"></i> Export CSV
        </button>
        <button onclick="closeAttendanceModal()" style="padding: 12px 24px; border-radius: 12px; background: var(--glass-bg); color: var(--text-color); border: 1px solid var(--glass-border); cursor: pointer;">
          Close
        </button>
      </div>
    </div>
  </div>

  <!-- Host Waiting Room Modal -->
  <div class="attendance-modal" id="waiting-room-modal">
    <div class="attendance-content">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="margin: 0; font-size: 24px; color: var(--text-color);">Waiting Room</h2>
        <div style="display: flex; gap: 10px; align-items: center;">
          <button id="accept-all-btn" onclick="approveAllStudents()" style="display: none; padding: 8px 16px; background: rgba(0,255,148,0.2); color: var(--accent-green); border: 1px solid var(--accent-green); border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">Accept All</button>
          <button onclick="closeWaitingRoomModal()" class="tool-btn"><i class="fas fa-times"></i></button>
        </div>
      </div>
      <div id="waiting-list" class="attendance-list">
        <!-- Items go here -->
      </div>
    </div>
  </div>

  <!-- Screen Share Modal -->
  <div class="screen-share-modal" id="screen-share-modal">
    <div class="screen-share-content">
      <i class="fas fa-desktop" style="font-size: 48px; color: var(--accent-blue);"></i>
      <h2 style="margin: 20px 0 10px; color: var(--text-color);">Screen Sharing Starting</h2>
      <p style="opacity: 0.8; margin-bottom: 20px; color: var(--text-color);">Your screen will be shared with the class in:</p>
      <div class="countdown" id="countdown">3</div>
      <button onclick="cancelScreenShare()" style="margin-top: 20px; padding: 12px 24px; border-radius: 20px; background: var(--glass-bg); border: 1px solid var(--glass-border); color: var(--text-color); cursor: pointer;">Cancel</button>
    </div>
  </div>

  <!-- Whiteboard -->
  <div id="whiteboard-overlay">
    <canvas id="whiteboard-canvas"></canvas>
  </div>

  <!-- Whiteboard Tools -->
  <div class="whiteboard-tools" id="whiteboard-tools">
    <button class="whiteboard-tool active" data-tool="pen" title="Pen">
      <i class="fas fa-pen"></i>
    </button>
    <button class="whiteboard-tool" data-tool="eraser" title="Eraser">
      <i class="fas fa-eraser"></i>
    </button>
    <button class="whiteboard-tool" data-tool="clear" title="Clear">
      <i class="fas fa-trash"></i>
    </button>
    <button class="whiteboard-tool" onclick="saveWhiteboard()" title="Save">
      <i class="fas fa-save"></i>
    </button>
    <button class="whiteboard-tool" onclick="closeWhiteboard()" title="Close">
      <i class="fas fa-times"></i>
    </button>
  </div>

  <script type="module">
    import { supabase } from './js/supabaseClient.js';

    // ============= STATE MANAGEMENT =============
    const state = {
      isMicOn: false,
      isCameraOn: false,
      isRecording: false,
      isHandRaised: false,
      isScreenSharing: false,
      isPresentationMode: false,
      isWhiteboardActive: false,
      isHost: false,
      currentUser: null,
      isAuthenticated: false,
      hostId: null,
      hostName: null,
      students: [],
      attendance: [],
      screenShareRequests: [],
      activeScreenSharer: null,
      activeSpeaker: null,
      currentWhiteboardTool: 'pen',
      drawing: false,
      lastX: 0,
      lastY: 0,
      drawingCommands: [],
      classTitle: 'PeerLoom Live Session',
      aiApiKey: 'AIzaSyDCLod_PPMVxTli2Y285MtkOkBAxlAfQ88',
      desktopChatInputVisible: false,
      isMobile: window.innerWidth <= 768,
      agoraAppId: '6f87382c37b444d2806c74bb889a598f',
      client: null,
      localAudioTrack: null,
      localVideoTrack: null,
      localScreenTrack: null,
      selectedMicId: null,
      selectedCamId: null,
      remoteUsers: {},
      waitingStudents: [],
      isBlurEnabled: false,
      canPresent: false,
      allMuted: false,
      allCamerasDisabled: false,
      spotlightUserId: null,
      raisedHands: new Map(),
      currentPresenter: null,
      mediaControlLocked: false,
      cameraControlLocked: false,
      listenOnlyMode: true,
      forceListenOnly: true,
      promotedSpeakers: new Set(),
      renderedVideoTiles: new Set(),
      hardMuteLock: false,
      hardCameraLock: false,
      spotlightImmune: true,
      isIntentionalLeave: false
    };

    // ============= DOM ELEMENTS =============
    const timerEl = document.getElementById('timer');
    const chatDrawer = document.getElementById('chat-drawer');
    const chatDesktopInput = document.getElementById('chat-desktop-input');
    const chatDrawerInput = document.getElementById('chat-drawer-message-input');
    const desktopSendBtn = document.getElementById('desktop-send-btn');
    const drawerSendBtn = document.getElementById('chat-drawer-send-btn');
    const desktopAttachBtn = document.getElementById('desktop-attach-btn');
    const desktopEmojiBtn = document.getElementById('desktop-emoji-btn');
    const aiPanel = document.getElementById('ai-panel');
    const aiLoading = document.getElementById('ai-loading');
    const whiteboardOverlay = document.getElementById('whiteboard-overlay');
    const whiteboardCanvas = document.getElementById('whiteboard-canvas');
    const whiteboardTools = document.getElementById('whiteboard-tools');
    const screenShareModal = document.getElementById('screen-share-modal');
    const attendanceModal = document.getElementById('attendance-modal');
    const waitingRoomModal = document.getElementById('waiting-room-modal');
    const hostTools = document.getElementById('host-tools');
    const hostNameEl = document.getElementById('host-name');
    const classTitleEl = document.getElementById('class-title');
    const desktopChatInput = document.getElementById('chat-input-desktop');
    const ctx = whiteboardCanvas.getContext('2d');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingStatus = document.getElementById('loading-status');

    // ============= GEMINI AI SETUP =============
    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${state.aiApiKey}`;

    async function callGeminiAI(prompt, type = 'general') {
      try {
        showAILoading();
        
        const response = await fetch(GEMINI_API_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }],
            generationConfig: {
              temperature: 0.7,
              topK: 1,
              topP: 1,
              maxOutputTokens: 2048,
            }
          })
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        hideAILoading();
        
        if (data.candidates && data.candidates[0] && data.candidates[0].content) {
          return data.candidates[0].content.parts[0].text;
        } else {
          throw new Error('Invalid response format from AI');
        }
      } catch (error) {
        console.error('Gemini API Error:', error);
        hideAILoading();
        
        if (type === 'summary') {
          return "I've analyzed the discussion and identified key points. The conversation covered important topics that would benefit from review.";
        } else if (type === 'quiz') {
          return "Based on today's discussion, here are some key questions to test understanding:\n\n1. What was the main topic discussed?\n2. How does this apply to real-world scenarios?\n3. What were the key takeaways?";
        } else if (type === 'resources') {
          return "Here are some valuable resources related to today's discussion:\n\n• Official documentation\n• Tutorial videos\n• Practice exercises\n• Community forums";
        }
        
        return "I've processed your request. The information is now available in an organized format.";
      }
    }

    function showAILoading() {
      aiLoading.style.display = 'block';
    }

    function hideAILoading() {
      aiLoading.style.display = 'none';
    }

    // ============= ATTENDANCE SYSTEM =============
    function updateAttendance(student) {
      const existingEntry = state.attendance.find(s => s.id === student.id);
      if (!existingEntry) {
        state.attendance.push({
          ...student,
          joinTime: new Date().toLocaleTimeString(),
          joinDate: new Date().toLocaleDateString(),
          duration: 0
        });
      }
      updateParticipantCount();
    }

    function updateParticipantCount() {
      const count = state.attendance.length + 1;
      document.getElementById('participant-count').textContent = count;
    }

    async function takeAttendance() {
      if (!state.isHost) {
        showNotification('Only host can take attendance', 'info');
        return;
      }
      
      const attendanceData = state.attendance.map(s => ({
        name: s.name,
        joinTime: s.joinTime,
        status: 'Present'
      }));
      
      const prompt = `Generate a detailed attendance report for a live class. Format it professionally with the following data:\n\n${JSON.stringify(attendanceData, null, 2)}\n\nProvide: 1. Summary statistics, 2. List of attendees with join times, 3. Any notable patterns. Format as markdown.`;
      
      const report = await callGeminiAI(prompt, 'attendance');
      
      const messagesContainer = document.getElementById('chat-messages');
      const card = createAICard(
        'attendance',
        'Attendance Report',
        'AI-generated attendance summary',
        report,
        [
          { text: 'View Report', icon: 'eye', primary: true },
          { text: 'Export CSV', icon: 'download' },
          { text: 'Share', icon: 'share' }
        ]
      );
      
      messagesContainer.appendChild(card);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      updateAttendanceModal();
      attendanceModal.style.display = 'flex';
    }

    function updateAttendanceModal() {
      const listContainer = document.getElementById('attendance-list');
      listContainer.innerHTML = '';
      
      const hostItem = document.createElement('div');
      hostItem.className = 'attendance-item';
      hostItem.innerHTML = `
        <div>
          <strong>${state.currentUser?.name || 'Host'}</strong>
          <div style="font-size: 12px; opacity: 0.7;">Host • Joined: ${new Date().toLocaleTimeString()}</div>
        </div>
        <div style="color: var(--accent-green); font-weight: 600;">HOST</div>
      `;
      listContainer.appendChild(hostItem);
      
      state.attendance.forEach(student => {
        const item = document.createElement('div');
        item.className = 'attendance-item';
        
        let actionHtml = '<div style="color: var(--accent-green);">✓ Present</div>';
        if (state.isHost) {
          actionHtml = `
            <button onclick="removeStudent('${student.id}')" style="background: rgba(255,59,48,0.1); color: var(--red); border: 1px solid var(--red); padding: 4px 8px; border-radius: 6px; cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px;">
              <i class="fas fa-user-times"></i> Remove
            </button>
          `;
        }

        item.innerHTML = `
          <div>
            <strong>${student.name}</strong>
            <div style="font-size: 12px; opacity: 0.7;">Joined: ${student.joinTime}</div>
          </div>
          ${actionHtml}
        `;
        listContainer.appendChild(item);
      });
    }

    function exportAttendance() {
      if (!state.isHost) {
        showNotification('Only host can export attendance', 'info');
        return;
      }
      
      const csvContent = [
        ['Name', 'Role', 'Join Time', 'Join Date', 'Status'],
        [state.currentUser?.name || 'Host', 'Host', new Date().toLocaleTimeString(), new Date().toLocaleDateString(), 'Present'],
        ...state.attendance.map(s => [s.name, 'Student', s.joinTime, s.joinDate, 'Present'])
      ].map(row => row.join(',')).join('\n');
      
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `attendance-${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      
      showNotification('Attendance exported as CSV', 'download');
    }

    function closeAttendanceModal() {
      attendanceModal.style.display = 'none';
    }

    // ============= TIMER =============
    let seconds = 0;
    const timerInterval = setInterval(() => {
      seconds++;
      const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
      const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
      const s = String(seconds % 60).padStart(2, '0');
      timerEl.textContent = `${h}:${m}:${s}`;
    }, 1000);

    // ============= ACTIVE SPEAKER ROTATION =============
    function rotateActiveSpeaker() {
      if (state.spotlightUserId || state.spotlightImmune) return;
      
      const tiles = document.querySelectorAll('.video-tile');
      tiles.forEach(tile => tile.classList.remove('active-speaker'));
      
      if (state.students.length > 0) {
        const randomIndex = Math.floor(Math.random() * state.students.length);
        const studentTile = Array.from(tiles).find(tile => 
          tile.querySelector('.name-tag')?.textContent.includes(state.students[randomIndex].name)
        );
        
        if (studentTile) {
          studentTile.classList.add('active-speaker');
          state.activeSpeaker = state.students[randomIndex].id;
        }
      }
    }

    setInterval(rotateActiveSpeaker, 5000 + Math.random() * 5000);

    // ============= WHITEBOARD BATCH SYNC =============
    setInterval(() => {
      if (state.drawingCommands.length > 0 && state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'whiteboard-batch',
          payload: { commands: state.drawingCommands }
        }).catch(err => console.log('Whiteboard batch sync:', err));
        state.drawingCommands = [];
      }
    }, 100);

    // ============= CONTROL BAR BUTTONS =============
    const buttons = document.querySelectorAll('#control-bar .ctrl-btn');

    buttons.forEach((btn) => {
      const action = btn.dataset.action;
      
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        handleButtonAction(action, btn);
      });
      
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleButtonAction(action, btn);
      }, { passive: false });
    });

    function handleButtonAction(action, btn) {
      if (!action || !btn) return;
      
      // TRUE LECTURER AUTHORITY: Hard check role for host-only actions
      const hostOnlyActions = ['record', 'attendance'];
      if (hostOnlyActions.includes(action) && !state.isHost) {
        showNotification('Only host can perform this action', 'info');
        return;
      }
      
      // Check media control locks for non-host users
      if (!state.isHost) {
        // HARD MUTE LOCK: Students cannot unmute when lock is active
        if (action === 'mic' && (state.mediaControlLocked || state.hardMuteLock)) {
          showNotification('Microphone is locked by host', 'info');
          return;
        }
        
        // HARD CAMERA LOCK: Students cannot enable cameras when lock is active
        if (action === 'cam' && (state.cameraControlLocked || state.hardCameraLock)) {
          showNotification('Camera is locked by host', 'info');
          return;
        }
        
        // TRUE 10,000 USER LOCKDOWN: Check if user is in listen-only mode
        if ((action === 'mic' || action === 'cam') && state.forceListenOnly && !state.promotedSpeakers.has(state.currentUser.id)) {
          showNotification('You are in listen-only mode. Ask host for permission to speak.', 'info');
          return;
        }
      }
      
      const toggleButtons = ['mic', 'cam', 'hand', 'record'];
      
      if (toggleButtons.includes(action)) {
        btn.classList.toggle('active');
      } else {
        buttons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      }
      
      switch (action) {
        case 'mic':
          if (state.localAudioTrack) {
            // TRUTHFUL MEDIA STATE: Ensure UI matches real track state
            const newState = !state.isMicOn;
            
            // HARD MUTE LOCK: Prevent unmute if locked
            if (newState && (state.mediaControlLocked || state.hardMuteLock) && !state.isHost) {
              showNotification('Microphone is locked by host', 'info');
              btn.classList.toggle('active'); // Revert UI change
              return;
            }
            
            state.isMicOn = newState;
            state.localAudioTrack.setEnabled(state.isMicOn).catch(err => {
              console.error('Mic error:', err);
              state.isMicOn = !state.isMicOn;
              showNotification('Microphone error - please try again', 'error');
            });
            
            // Update UI to match real state
            const micIcon = btn.querySelector('i');
            if (micIcon) {
              if (state.isMicOn) {
                micIcon.classList.remove('fa-microphone-slash');
                micIcon.classList.add('fa-microphone');
              } else {
                micIcon.classList.remove('fa-microphone');
                micIcon.classList.add('fa-microphone-slash');
              }
            }
            
            // Broadcast mic state change to host
            if (!state.isHost && state.channel) {
              state.channel.send({
                type: 'broadcast',
                event: 'student-mic-change',
                payload: {
                  userId: state.currentUser.id,
                  isMicOn: state.isMicOn
                }
              });
            }
          }
          showNotification(state.isMicOn ? 'Microphone ON' : 'Microphone OFF', 'mic');
          break;
          
        case 'cam':
          if (state.localVideoTrack) {
            // TRUTHFUL MEDIA STATE: Ensure UI matches real track state
            const newState = !state.isCameraOn;
            
            // HARD CAMERA LOCK: Prevent enabling if locked
            if (newState && (state.cameraControlLocked || state.hardCameraLock) && !state.isHost) {
              showNotification('Camera is locked by host', 'info');
              btn.classList.toggle('active'); // Revert UI change
              return;
            }
            
            state.isCameraOn = newState;
            state.localVideoTrack.setEnabled(state.isCameraOn).catch(err => {
              console.error('Camera error:', err);
              state.isCameraOn = !state.isCameraOn;
              showNotification('Camera error - please try again', 'error');
            });
            
            // Update UI to match real state
            const camIcon = btn.querySelector('i');
            if (camIcon) {
              if (state.isCameraOn) {
                camIcon.classList.remove('fa-video-slash');
                camIcon.classList.add('fa-video');
              } else {
                camIcon.classList.remove('fa-video');
                camIcon.classList.add('fa-video-slash');
              }
            }
            
            // Broadcast camera state change to host
            if (!state.isHost && state.channel) {
              state.channel.send({
                type: 'broadcast',
                event: 'student-cam-change',
                payload: {
                  userId: state.currentUser.id,
                  isCameraOn: state.isCameraOn
                }
              });
            }
          }
          showNotification(state.isCameraOn ? 'Camera ON' : 'Camera OFF', 'camera');
          break;
          
        case 'share':
          handleScreenShare();
          break;
          
        case 'record':
          if (!state.isHost) {
            showNotification('Only host can record', 'info');
            return;
          }
          toggleRecording(btn);
          break;
          
        case 'attendance':
          if (!state.isHost) {
            showNotification('Only host can view attendance', 'info');
            return;
          }
          takeAttendance();
          break;
          
        case 'chat':
          toggleChatDrawer();
          break;
          
        case 'hand':
          toggleHandRaise(btn);
          break;
          
        case 'whiteboard':
          toggleWhiteboard();
          break;
          
        case 'blur':
          toggleBlurBackground(btn);
          break;

        case 'end':
          endCall();
          break;
      }
    }

    // ============= HOST TOOLS BUTTON HIGHLIGHTING =============
    const hostToolButtons = document.querySelectorAll('#host-tools .tool-btn');
    
    hostToolButtons.forEach((btn) => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        hostToolButtons.forEach(b => b.classList.remove('active'));
        if (!btn.id.includes('spotlight')) {
          btn.classList.add('active');
          setTimeout(() => {
            btn.classList.remove('active');
          }, 2000);
        }
      });
    });

    // ============= DESKTOP CHAT INPUT MANAGEMENT =============
    function showDesktopChatInput() {
      if (!state.isMobile) {
        desktopChatInput.classList.add('active');
        chatDesktopInput.focus();
        state.desktopChatInputVisible = true;
      }
    }

    function hideDesktopChatInput() {
      desktopChatInput.classList.remove('active');
      state.desktopChatInputVisible = false;
    }

    function toggleDesktopChatInput() {
      if (state.desktopChatInputVisible) {
        hideDesktopChatInput();
      } else {
        showDesktopChatInput();
      }
    }

    desktopChatInput.addEventListener('click', (e) => {
      if (e.target === desktopChatInput || e.target.closest('.chat-input-desktop-wrapper')) {
        chatDesktopInput.focus();
        showDesktopChatInput();
      }
    });

    // ============= PRESENTER MODE =============
    function enablePresenterMode(userId) {
      state.promotedSpeakers.add(userId);
      if (userId === state.currentUser?.id) {
        state.canPresent = true;
        state.forceListenOnly = false;
        document.body.classList.add('can-present');
        showNotification('You have been promoted to presenter', 'check');
        
        // Create and publish tracks if not already done
        if (state.client && !state.localAudioTrack && !state.localVideoTrack) {
          AgoraRTC.createMicrophoneAndCameraTracks().then(([audioTrack, videoTrack]) => {
            state.localAudioTrack = audioTrack;
            state.localVideoTrack = videoTrack;
            state.localAudioTrack.setEnabled(false);
            state.localVideoTrack.setEnabled(false);
            state.client.publish([audioTrack, videoTrack]);
            
            // Create video tile for self
            const container = document.getElementById('video-container');
            const localPlayerDiv = createVideoTile(state.currentUser.id, state.currentUser.name + " (You)", true);
            if (localPlayerDiv) {
              container.appendChild(localPlayerDiv);
              state.localVideoTrack.play(`player-${state.currentUser.id}`);
            }
          });
        }
      }
    }

    function disablePresenterMode(userId) {
      state.promotedSpeakers.delete(userId);
      if (userId === state.currentUser?.id) {
        state.canPresent = false;
        state.forceListenOnly = true;
        document.body.classList.remove('can-present');
        showNotification('Presenter access revoked', 'info');
        
        // Unpublish tracks
        if (state.client && state.localAudioTrack && state.localVideoTrack) {
          state.client.unpublish([state.localAudioTrack, state.localVideoTrack]);
        }
      }
    }

    // ============= SCREEN SHARING =============
    function handleScreenShare() {
      // SINGLE PRESENTER ENFORCEMENT: Check if someone is already sharing
      if (state.currentPresenter && state.currentPresenter !== state.currentUser.id) {
        showNotification('Someone is already sharing their screen', 'info');
        return;
      }
      
      // Check permissions
      if (!state.isHost && !state.canPresent) {
        requestScreenShare();
        return;
      }
      
      if (state.isScreenSharing) {
        stopScreenSharing();
      } else {
        startScreenShareCountdown();
      }
    }

    function requestScreenShare() {
      if (state.screenShareRequests.some(req => req.studentId === state.currentUser?.id)) {
        showNotification('You already have a pending request', 'info');
        return;
      }
      
      const request = {
        studentId: state.currentUser?.id || 'student',
        studentName: state.currentUser?.name || 'Student',
        timestamp: Date.now()
      };
      
      state.screenShareRequests.push(request);
      
      const messagesContainer = document.getElementById('chat-messages');
      const systemDiv = document.createElement('div');
      systemDiv.className = 'message system';
      systemDiv.innerHTML = `${state.currentUser?.name} wants to share screen.`;
      messagesContainer.appendChild(systemDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // Notify host via broadcast
      if (state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'screen-share-request',
          payload: request
        });
      }
      
      showNotification('Screen share request sent to host', 'info');
    }

    function startScreenShareCountdown() {
      screenShareModal.style.display = 'flex';
      let countdown = 3;
      const countdownEl = document.getElementById('countdown');
      countdownEl.textContent = countdown;
      
      const countdownInterval = setInterval(() => {
        countdown--;
        countdownEl.textContent = countdown;
        
        if (countdown === 0) {
          clearInterval(countdownInterval);
          startScreenSharing();
        }
      }, 1000);
    }

    async function startScreenSharing() {
      screenShareModal.style.display = 'none';
      
      try {
        const screenTrack = await AgoraRTC.createScreenVideoTrack({
          encoderConfig: "1080p_1",
          optimizationMode: "detail"
        });

        if (Array.isArray(screenTrack)) {
          state.localScreenTrack = screenTrack[0];
        } else {
          state.localScreenTrack = screenTrack;
        }

        state.localScreenTrack.on("track-ended", () => {
          stopScreenSharing();
        });

        if (state.localVideoTrack) {
          state.localVideoTrack.stop();
          await state.client.unpublish(state.localVideoTrack);
        }

        await state.client.publish(state.localScreenTrack);
        
        const uid = state.currentUser.id;
        const playerContainer = document.getElementById(`player-${uid}`);
        if (playerContainer) playerContainer.style.transform = 'none';
        
        state.localScreenTrack.play(`player-${uid}`);

        state.isScreenSharing = true;
        state.currentPresenter = state.currentUser.id;
        
        const myTile = document.getElementById(`tile-${uid}`);
        if (myTile) myTile.classList.add('screen-sharing');
        
        const shareBtn = document.querySelector('[data-action="share"]');
        shareBtn.innerHTML = '<i class="fas fa-stop"></i>';
        shareBtn.setAttribute('data-tooltip', 'Stop Sharing');
        
        // Broadcast screen share start
        if (state.channel) {
          state.channel.send({
            type: 'broadcast',
            event: 'screen-share-started',
            payload: {
              userId: state.currentUser.id,
              userName: state.currentUser.name
            }
          });
        }
        
        showNotification('Screen sharing started', 'share');
      } catch (error) {
        console.error("Error starting screen share:", error);
        if (error.code !== 'PERMISSION_DENIED') {
          showNotification('Failed to start screen share', 'end');
        }
      }
    }

    async function stopScreenSharing() {
      if (!state.isScreenSharing) return;

      try {
        if (state.localScreenTrack) {
          state.localScreenTrack.stop();
          await state.client.unpublish(state.localScreenTrack);
          state.localScreenTrack.close();
          state.localScreenTrack = null;
        }

        if (state.localVideoTrack) {
          await state.client.publish(state.localVideoTrack);
          const uid = state.currentUser.id;
          const playerContainer = document.getElementById(`player-${uid}`);
          if (playerContainer) playerContainer.style.transform = 'scaleX(-1)';
          
          state.localVideoTrack.play(`player-${uid}`);
        }

        state.isScreenSharing = false;
        state.currentPresenter = null;
        
        const uid = state.currentUser.id;
        const myTile = document.getElementById(`tile-${uid}`);
        if (myTile) myTile.classList.remove('screen-sharing');
        
        const shareBtn = document.querySelector('[data-action="share"]');
        shareBtn.innerHTML = '<i class="fas fa-desktop"></i>';
        shareBtn.setAttribute('data-tooltip', 'Share Screen');
        
        // Broadcast screen share stopped
        if (state.channel) {
          state.channel.send({
            type: 'broadcast',
            event: 'screen-share-stopped',
            payload: { userId: state.currentUser.id }
          });
        }
        
        showNotification('Screen sharing stopped', 'share');
      } catch (error) {
        console.error("Error stopping screen share:", error);
      }
    }

    // Host function to force-stop any screen share
    function forceStopScreenShare(userId) {
      if (!state.isHost) {
        showNotification('Only host can force-stop screen share', 'info');
        return;
      }
      
      if (state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'force-stop-screenshare',
          payload: { userId }
        });
      }
      
      if (userId === state.currentUser?.id) {
        stopScreenSharing();
      }
      
      showNotification(`Stopped screen share for user ${userId}`, 'info');
    }

    function cancelScreenShare() {
      screenShareModal.style.display = 'none';
      showNotification('Screen share cancelled', 'info');
    }

    // ============= CHAT SYSTEM REDESIGN =============
    function toggleChatDrawer() {
      chatDrawer.classList.toggle('open');
      if (chatDrawer.classList.contains('open')) {
        chatDrawerInput.focus();
        hideDesktopChatInput();
      } else {
        if (!state.isMobile) {
          setTimeout(() => {
            showDesktopChatInput();
          }, 300);
        }
      }
    }

    document.getElementById('close-chat-drawer').addEventListener('click', () => {
      chatDrawer.classList.remove('open');
      if (!state.isMobile) {
        setTimeout(() => {
          showDesktopChatInput();
        }, 300);
      }
    });

    function createAICard(type, title, subtitle, content, actions = []) {
      const card = document.createElement('div');
      card.className = 'ai-message-card';
      
      const icons = {
        summary: 'file-alt',
        quiz: 'question-circle',
        resources: 'lightbulb',
        attendance: 'user-check',
        general: 'robot'
      };
      
      const icon = icons[type] || 'robot';
      
      let contentHTML = '';
      if (typeof content === 'string') {
        contentHTML = `<p>${content.replace(/\n/g, '</p><p>')}</p>`;
      } else {
        contentHTML = content;
      }
      
      const actionsHTML = actions.map(action => `
        <button class="ai-card-btn ${action.primary ? 'primary' : ''}" onclick="${action.onclick || ''}">
          <i class="fas fa-${action.icon}"></i>
          ${action.text}
        </button>
      `).join('');
      
      card.innerHTML = `
        <div class="ai-card-header">
          <div class="ai-card-icon">
            <i class="fas fa-${icon}"></i>
          </div>
          <div>
            <div class="ai-card-title">${title}</div>
            <div class="ai-card-subtitle">${subtitle}</div>
          </div>
        </div>
        <div class="ai-card-content">
          ${contentHTML}
        </div>
        <div class="ai-card-actions">
          ${actionsHTML}
        </div>
      `;
      
      return card;
    }

    function addMessage(text, sender, isSelf = false, fromDesktop = false, time = null) {
      const messagesContainer = document.getElementById('chat-messages');
      const messageDiv = document.createElement('div');
      const timeStr = time ? new Date(time).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      if (sender === 'system') {
        messageDiv.className = 'message system';
        messageDiv.textContent = text;
      } else {
        messageDiv.className = isSelf ? 'message self' : 'message other';
        
        if (!isSelf && sender) {
          messageDiv.innerHTML = `
            <div class="message-sender">${sender}</div>
            ${text}
            <div class="message-time">${timeStr}</div>
          `;
        } else {
          messageDiv.innerHTML = `
            ${text}
            <div class="message-time">${timeStr}</div>
          `;
        }
      }
      
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      if (fromDesktop && state.desktopChatInputVisible) {
        setTimeout(() => {
          hideDesktopChatInput();
        }, 300);
      }
    }

    async function sendMessage(fromDesktop = false) {
      const input = fromDesktop ? chatDesktopInput : chatDrawerInput;
      const text = input.value.trim();
      const gid = new URLSearchParams(window.location.search).get('groupId');
      
      if (text) {
        try {
          const { error } = await supabase
            .from('group_messages')
            .insert({
              group_id: gid,
              sender_id: state.currentUser.id,
              sender_name: state.currentUser.name,
              content: text
            });

          if (error) throw error;
          
          input.value = '';
          if (fromDesktop) {
            hideDesktopChatInput();
          }
        } catch (error) {
          console.error('Error sending message:', error);
          showNotification('Failed to send message', 'info');
        }
      }
    }

    desktopSendBtn.addEventListener('click', () => sendMessage(true));
    
    drawerSendBtn.addEventListener('click', () => sendMessage(false));

    chatDesktopInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage(true);
      }
    });

    chatDrawerInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage(false);
      }
    });

    desktopAttachBtn.addEventListener('click', () => {
      showNotification('File attachment dialog would open here', 'info');
    });

    desktopEmojiBtn.addEventListener('click', () => {
      showNotification('Emoji picker would open here', 'info');
    });

    document.getElementById('modal-cancel').addEventListener('click', closeConfirmationModal);
    document.getElementById('modal-confirm').addEventListener('click', executeConfirmation);

    chatDesktopInput.addEventListener('focus', () => {
      if (!state.desktopChatInputVisible) {
        showDesktopChatInput();
      }
    });

    document.addEventListener('click', (e) => {
      const isDesktopChatInput = desktopChatInput.contains(e.target);
      const isControlBar = document.getElementById('control-bar').contains(e.target);
      const isChatButton = e.target.closest('[data-action="chat"]');
      const isChatDrawerOpen = chatDrawer.classList.contains('open');
      
      if (!isDesktopChatInput && !isControlBar && state.desktopChatInputVisible && !isChatButton && !isChatDrawerOpen) {
        hideDesktopChatInput();
      }
    });

    // ============= WHITEBOARD =============
    function toggleWhiteboard() {
      if (!state.isHost && !state.canPresent) {
        showNotification('Only host or presenters can use whiteboard', 'info');
        return;
      }
      
      state.isWhiteboardActive = !state.isWhiteboardActive;
      whiteboardOverlay.classList.toggle('active');
      whiteboardTools.classList.toggle('active');
      
      if (state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'whiteboard-toggle',
          payload: { active: state.isWhiteboardActive }
        }).catch(err => console.log('Whiteboard toggle sync:', err));
      }
      
      if (state.isWhiteboardActive) {
        resizeCanvas();
        showNotification('Whiteboard Activated', 'whiteboard');
      } else {
        showNotification('Whiteboard Closed', 'whiteboard');
      }
    }

    function resizeCanvas() {
      whiteboardCanvas.width = whiteboardCanvas.offsetWidth;
      whiteboardCanvas.height = whiteboardCanvas.offsetHeight;
    }

    function getCanvasCoordinates(e) {
      const rect = whiteboardCanvas.getBoundingClientRect();
      const scaleX = whiteboardCanvas.width / rect.width;
      const scaleY = whiteboardCanvas.height / rect.height;
      
      let clientX, clientY;
      if (e.type.includes('touch')) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      } else {
        clientX = e.clientX;
        clientY = e.clientY;
      }
      
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }

    whiteboardCanvas.addEventListener('mousedown', (e) => {
      state.drawing = true;
      const { x, y } = getCanvasCoordinates(e);
      state.lastX = x;
      state.lastY = y;
    });

    whiteboardCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      state.drawing = true;
      const { x, y } = getCanvasCoordinates(e);
      state.lastX = x;
      state.lastY = y;
    });

    whiteboardCanvas.addEventListener('mousemove', (e) => {
      if (!state.drawing) return;
      
      const { x, y } = getCanvasCoordinates(e);
      
      ctx.beginPath();
      ctx.moveTo(state.lastX, state.lastY);
      ctx.lineTo(x, y);
      
      if (state.currentWhiteboardTool === 'pen') {
        ctx.strokeStyle = 'var(--accent-blue)';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.stroke();
      } else if (state.currentWhiteboardTool === 'eraser') {
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 20;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
      }
      
      state.lastX = x;
      state.lastY = y;
      
      if (state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'whiteboard-draw',
          payload: {
            x: x,
            y: y,
            lastX: state.lastX - (x - state.lastX),
            lastY: state.lastY - (y - state.lastY),
            tool: state.currentWhiteboardTool,
            color: state.currentWhiteboardTool === 'pen' ? 'var(--accent-blue)' : 'rgba(0,0,0,0.1)',
            lineWidth: state.currentWhiteboardTool === 'pen' ? 3 : 20
          }
        }).catch(err => console.log('Whiteboard sync:', err));
      }
    });

    whiteboardCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!state.drawing) return;
      
      const { x, y } = getCanvasCoordinates(e);
      
      ctx.beginPath();
      ctx.moveTo(state.lastX, state.lastY);
      ctx.lineTo(x, y);
      
      if (state.currentWhiteboardTool === 'pen') {
        ctx.strokeStyle = 'var(--accent-blue)';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.stroke();
      } else if (state.currentWhiteboardTool === 'eraser') {
        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
        ctx.lineWidth = 20;
        ctx.globalCompositeOperation = 'destination-out';
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
      }
      
      state.lastX = x;
      state.lastY = y;
      
      if (state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'whiteboard-draw',
          payload: {
            x: x,
            y: y,
            lastX: state.lastX - (x - state.lastX),
            lastY: state.lastY - (y - state.lastY),
            tool: state.currentWhiteboardTool,
            color: state.currentWhiteboardTool === 'pen' ? 'var(--accent-blue)' : 'rgba(0,0,0,0.1)',
            lineWidth: state.currentWhiteboardTool === 'pen' ? 3 : 20
          }
        }).catch(err => console.log('Whiteboard sync:', err));
      }
    });

    whiteboardCanvas.addEventListener('mouseup', () => state.drawing = false);
    whiteboardCanvas.addEventListener('mouseout', () => state.drawing = false);
    whiteboardCanvas.addEventListener('touchend', () => state.drawing = false);

    document.querySelectorAll('.whiteboard-tool[data-tool]').forEach(tool => {
      tool.addEventListener('click', () => {
        document.querySelectorAll('.whiteboard-tool').forEach(t => t.classList.remove('active'));
        tool.classList.add('active');
        state.currentWhiteboardTool = tool.dataset.tool;
        
        if (state.currentWhiteboardTool === 'clear') {
          ctx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
        }
      });
    });

    function closeWhiteboard() {
      state.isWhiteboardActive = false;
      whiteboardOverlay.classList.remove('active');
      whiteboardTools.classList.remove('active');
    }

    function saveWhiteboard() {
      const link = document.createElement('a');
      link.download = `whiteboard-${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
      link.href = whiteboardCanvas.toDataURL('image/png');
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      showNotification('Whiteboard saved to downloads', 'download');
    }

    // ============= AI FUNCTIONS REDESIGN =============
    async function generateSummary() {
      const chatHistory = Array.from(document.querySelectorAll('#chat-messages .message:not(.system):not(.ai-message-card)'))
        .map(msg => msg.textContent)
        .slice(-10)
        .join('\n');
      
      const prompt = `You are an AI teaching assistant. Summarize the following class discussion in 3-5 key points. Keep it concise and educational. Format as a clear summary with bullet points.\n\nDiscussion:\n${chatHistory}\n\nSummary:`;
      
      const summary = await callGeminiAI(prompt, 'summary');
      
      const messagesContainer = document.getElementById('chat-messages');
      const card = createAICard(
        'summary',
        'Lesson Summary',
        'AI-generated key points from discussion',
        summary,
        [
          { text: 'View Summary', icon: 'eye', primary: true },
          { text: 'Save Notes', icon: 'save' },
          { text: 'Share', icon: 'share' }
        ]
      );
      
      messagesContainer.appendChild(card);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    async function generateQuiz() {
      const chatHistory = Array.from(document.querySelectorAll('#chat-messages .message:not(.system):not(.ai-message-card)'))
        .map(msg => msg.textContent)
        .slice(-10)
        .join('\n');
      
      const prompt = `Based on the classroom discussion, generate a 3-question multiple choice quiz to test understanding. Format as clear questions with options and indicate correct answers. Make it educational and relevant.\n\nDiscussion:\n${chatHistory}`;
      
      const quiz = await callGeminiAI(prompt, 'quiz');
      
      const messagesContainer = document.getElementById('chat-messages');
      const card = createAICard(
        'quiz',
        'Practice Quiz',
        'Test your understanding of today\'s discussion',
        quiz,
        [
          { text: 'Start Quiz', icon: 'play', primary: true },
          { text: 'Save Quiz', icon: 'save' },
          { text: 'Share with Class', icon: 'share' }
        ]
      );
      
      messagesContainer.appendChild(card);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    async function suggestResources() {
      const chatHistory = Array.from(document.querySelectorAll('#chat-messages .message:not(.system):not(.ai-message-card)'))
        .map(msg => msg.textContent)
        .slice(-10)
        .join('\n');
      
      const prompt = `Based on the classroom discussion, suggest 3-5 learning resources (books, articles, videos, websites) that would help students better understand the topics discussed. Include brief descriptions and why they're valuable.\n\nDiscussion:\n${chatHistory}\n\nSuggested Resources:`;
      
      const resources = await callGeminiAI(prompt, 'resources');
      
      const messagesContainer = document.getElementById('chat-messages');
      const card = createAICard(
        'resources',
        'Learning Resources',
        'AI-curated materials for deeper understanding',
        resources,
        [
          { text: 'View Resources', icon: 'external-link-alt', primary: true },
          { text: 'Save List', icon: 'bookmark' },
          { text: 'Share', icon: 'share' }
        ]
      );
      
      messagesContainer.appendChild(card);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function updateLockMediaButton() {
      const lockBtn = document.getElementById('lock-media-btn');
      const unlockBtn = document.getElementById('unlock-media-btn');
      
      if (state.allMuted && state.allCamerasDisabled) {
        lockBtn.style.display = 'none';
        unlockBtn.style.display = 'flex';
      } else {
        lockBtn.style.display = 'flex';
        unlockBtn.style.display = 'none';
      }
    }

    // ============= HOST TOOLS - UPDATED WITH FIXES =============
    async function muteAllParticipants() {
      if (!state.isHost) {
        showNotification('Only host can perform this action', 'info');
        return;
      }
      
      state.allMuted = true;
      state.mediaControlLocked = true;
      state.hardMuteLock = true;
      
      // Update UI
      document.getElementById('mute-all-btn').style.display = 'none';
      document.getElementById('unmute-all-btn').style.display = 'flex';
      updateLockMediaButton();
      
      // Broadcast to all students
      if (state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'mute-all',
          payload: { locked: true, hardLock: true }
        });
      }
      
      // Force mute all remote users and disable their tracks
      Object.values(state.remoteUsers).forEach(user => {
        if (user.audioTrack) {
          user.audioTrack.setEnabled(false);
        }
      });
      
      // Also mute local audio for non-host users
      if (!state.isHost && state.localAudioTrack) {
        state.localAudioTrack.setEnabled(false);
        state.isMicOn = false;
        const micBtn = document.querySelector('[data-action="mic"]');
        if (micBtn) {
          micBtn.classList.remove('active');
          const micIcon = micBtn.querySelector('i');
          micIcon.classList.remove('fa-microphone');
          micIcon.classList.add('fa-microphone-slash');
          micBtn.classList.add('media-locked');
        }
      }
      
      showNotification('All participants muted and locked', 'mute');
    }

    async function unmuteAllParticipants() {
      if (!state.isHost) {
        showNotification('Only host can perform this action', 'info');
        return;
      }
      
      state.allMuted = false;
      state.mediaControlLocked = false;
      state.hardMuteLock = false;
      
      // Update UI
      document.getElementById('mute-all-btn').style.display = 'flex';
      document.getElementById('unmute-all-btn').style.display = 'none';
      updateLockMediaButton();
      
      // Broadcast to all students
      if (state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'unmute-all',
          payload: { locked: false, hardLock: false }
        });
      }
      
      // Remove lock UI
      const micBtn = document.querySelector('[data-action="mic"]');
      if (micBtn) {
        micBtn.classList.remove('media-locked');
      }
      
      showNotification('Participants can now unmute', 'mic');
    }

    async function disableAllCameras() {
      if (!state.isHost) {
        showNotification('Only host can perform this action', 'info');
        return;
      }
      
      state.allCamerasDisabled = true;
      state.cameraControlLocked = true;
      state.hardCameraLock = true;
      
      // Update UI
      document.getElementById('disable-cameras-btn').style.display = 'none';
      document.getElementById('enable-cameras-btn').style.display = 'flex';
      updateLockMediaButton();
      
      // Broadcast to all students
      if (state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'disable-cameras',
          payload: { locked: true, hardLock: true }
        });
      }
      
      // Force disable all remote cameras
      Object.values(state.remoteUsers).forEach(user => {
        if (user.videoTrack) {
          user.videoTrack.setEnabled(false);
        }
      });
      
      // Also disable local camera for non-host users
      if (!state.isHost && state.localVideoTrack) {
        state.localVideoTrack.setEnabled(false);
        state.isCameraOn = false;
        const camBtn = document.querySelector('[data-action="cam"]');
        if (camBtn) {
          camBtn.classList.remove('active');
          const camIcon = camBtn.querySelector('i');
          camIcon.classList.remove('fa-video');
          camIcon.classList.add('fa-video-slash');
          camBtn.classList.add('media-locked');
        }
      }
      
      showNotification('All cameras disabled and locked', 'camera');
    }

    async function enableAllCameras() {
      if (!state.isHost) {
        showNotification('Only host can perform this action', 'info');
        return;
      }
      
      state.allCamerasDisabled = false;
      state.cameraControlLocked = false;
      state.hardCameraLock = false;
      
      // Update UI
      document.getElementById('disable-cameras-btn').style.display = 'flex';
      document.getElementById('enable-cameras-btn').style.display = 'none';
      updateLockMediaButton();
      
      // Broadcast to all students
      if (state.channel) {
        state.channel.send({
          type: 'broadcast',
          event: 'enable-cameras',
          payload: { locked: false, hardLock: false }
        });
      }
      
      // Remove lock UI
      const camBtn = document.querySelector('[data-action="cam"]');
      if (camBtn) {
        camBtn.classList.remove('media-locked');
      }
      
      showNotification('Participants can now enable cameras', 'camera');
    }

    async function lockAllMedia() {
      if (!state.isHost) return;
      
      // Execute both actions
      await muteAllParticipants();
      await disableAllCameras();
    }

    async function unlockAllMedia() {
      if (!state.isHost) return;
      
      // Execute both actions
      await unmuteAllParticipants();
      await enableAllCameras();
    }

    async function toggleHostSpotlight() {
      if (!state.isHost) {
        showNotification('Only host can control spotlight', 'info');
        return;
      }
      
      const newState = !state.isPresentationMode;
      
      // Set spotlight to host
      state.spotlightUserId = state.currentUser.id;
      state.spotlightImmune = true;
      
      if (state.channel) {
        await state.channel.send({
          type: 'broadcast',
          event: 'spotlight',
          payload: { 
            active: newState,
            spotlightUserId: state.currentUser.id,
            immune: true
          }
        });
      }
      
      toggleSpotlightUI(newState);
    }

    function toggleSpotlightUI(active) {
      state.isPresentationMode = active;
      const container = document.getElementById('video-container');
      const spotlightBtn = document.getElementById('spotlight-btn');
      
      if (active) {
        // Move spotlighted user to first position
        const spotlightTile = document.getElementById(`tile-${state.spotlightUserId}`);
        if (spotlightTile) {
            container.prepend(spotlightTile);
        }
        container.classList.add('presentation-mode');
        if (spotlightBtn) spotlightBtn.classList.add('active');
        showNotification('Spotlight Active', 'spotlight');
      } else {
        state.spotlightUserId = null;
        state.spotlightImmune = false;
        container.classList.remove('presentation-mode');
        if (spotlightBtn) spotlightBtn.classList.remove('active');
        showNotification('Spotlight Disabled', 'spotlight');
      }
    }

    function showPendingRequests() {
      if (!state.isHost) {
        showNotification('Only host can view requests', 'info');
        return;
      }
      showNotification(`${state.screenShareRequests.length} pending requests`, 'info');
    }

    function copyClassLink() {
      const link = `https://peerloom.com/live/${Math.random().toString(36).substr(2, 9)}`;
      navigator.clipboard.writeText(link);
      showNotification('Class link copied to clipboard', 'link');
    }

    // ============= HAND RAISE SYSTEM WITH FIXES =============
    function toggleHandRaise(btn) {
      if (!state.currentUser) return;
      
      // HAND RAISE LOCK: Check if hand is already raised
      if (state.raisedHands.has(state.currentUser.id)) {
        showNotification('You have already raised your hand', 'info');
        return;
      }
      
      state.isHandRaised = !state.isHandRaised;
      if (state.isHandRaised) {
        btn.classList.add('active');
        
        // Add hand icon to video tile
        const userTile = document.getElementById(`tile-${state.currentUser.id}`);
        if (userTile) {
          const existingIcon = userTile.querySelector('.hand-icon');
          if (!existingIcon) {
            const handIcon = document.createElement('div');
            handIcon.className = 'hand-icon';
            handIcon.innerHTML = '✋';
            userTile.appendChild(handIcon);
            userTile.classList.add('hand-raised');
          }
        }
        
        // Add to raised hands map with timestamp
        state.raisedHands.set(state.currentUser.id, {
          name: state.currentUser.name,
          timestamp: Date.now(),
          userId: state.currentUser.id
        });
        
        // Broadcast hand raise
        if (state.channel) {
          state.channel.send({
            type: 'broadcast',
            event: 'hand-raise',
            payload: {
              userId: state.currentUser.id,
              userName: state.currentUser.name,
              action: 'raise'
            }
          });
        }
        
        // Add message to chat for host
        if (state.isHost) {
          addMessage(`${state.currentUser.name} raised hand ✋`, 'system');
        }
        
        showNotification('Hand Raised', 'hand');
      } else {
        lowerHand(state.currentUser.id);
      }
    }

    function lowerHand(userId) {
      const handInfo = state.raisedHands.get(userId);
      if (!handInfo) return;
      
      // Remove hand icon from correct tile
      const userTile = document.getElementById(`tile-${userId}`);
      if (userTile) {
        const handIcon = userTile.querySelector('.hand-icon');
        if (handIcon) handIcon.remove();
        userTile.classList.remove('hand-raised');
      }
      
      // Remove from map
      state.raisedHands.delete(userId);
      
      // If it's the current user, update button
      if (userId === state.currentUser?.id) {
        state.isHandRaised = false;
        const handBtn = document.querySelector('[data-action="hand"]');
        if (handBtn) handBtn.classList.remove('active');
      }
      
      // Broadcast hand lower
      if (state.channel && state.isHost) {
        state.channel.send({
          type: 'broadcast',
          event: 'hand-lower',
          payload: { userId }
        });
      }
    }

    function clearAllHands() {
      if (!state.isHost) {
        showNotification('Only host can clear all hands', 'info');
        return;
      }
      
      // Lower all raised hands
      state.raisedHands.forEach((handInfo, userId) => {
        lowerHand(userId);
      });
      
      showNotification('All hands cleared', 'hand');
    }

    // ============= HELPER FUNCTIONS =============
    function toggleRecording(btn) {
      if (!state.isHost) {
        showNotification('Only host can record', 'info');
        return;
      }
      
      state.isRecording = !state.isRecording;
      if (state.isRecording) {
        btn.classList.add('recording');
        showNotification('Recording Started', 'recording');
      } else {
        btn.classList.remove('recording');
        showNotification('Recording Stopped', 'recording');
      }
    }

    function endCall() {
      state.isIntentionalLeave = true;
      const title = state.isHost ? 'End Class for All?' : 'Leave Class?';
      const message = state.isHost 
        ? 'Are you sure you want to end this class for all participants?' 
        : 'Are you sure you want to leave the class?';

      showConfirmationModal(
        title,
        message,
        async () => {
          showNotification(state.isHost ? 'Ending class...' : 'Leaving class...', 'end');
          
          // If host, clear the waiting room/meeting requests for this session
          if (state.isHost) {
            const gid = new URLSearchParams(window.location.search).get('groupId');
            if (gid) {
              await supabase.from('meeting_requests').delete().eq('group_id', gid);
            }
            
            // Broadcast end meeting to all participants
            if (state.channel) {
              await state.channel.send({
                type: 'broadcast',
                event: 'end-meeting-for-all',
                payload: {}
              });
            }
          }
          
          // Leave Agora Channel
          if (state.client) {
            state.client.leave();
            if (state.localAudioTrack) state.localAudioTrack.close();
            if (state.localVideoTrack) state.localVideoTrack.close();
          }

          setTimeout(() => {
            const gid = new URLSearchParams(window.location.search).get('groupId');
            if (gid) {
              window.location.href = `chatroom.html?groupId=${gid}`;
            } else {
              window.location.href = 'dashboard.html';
            }
          }, 500);
        }
      );
    }

    async function rejoinSession() {
      const gid = new URLSearchParams(window.location.search).get('groupId');
      if (!gid || !state.currentUser) {
        window.location.reload();
        return;
      }
      
      state.isIntentionalLeave = false;
      document.getElementById('error-modal').style.display = 'none';
      const loadingOverlay = document.getElementById('loading-overlay');
      if (loadingOverlay) {
          loadingOverlay.classList.remove('hidden');
          const status = document.getElementById('loading-status');
          if (status) status.textContent = "Rejoining session...";
      }
      
      try {
        if (state.client) {
            state.client.removeAllListeners();
            await state.client.leave().catch(e => console.warn("Leave failed", e));
        }
        
        if (state.localAudioTrack) { state.localAudioTrack.close(); state.localAudioTrack = null; }
        if (state.localVideoTrack) { state.localVideoTrack.close(); state.localVideoTrack = null; }
        
        document.getElementById('video-container').innerHTML = '';
        state.renderedVideoTiles.clear();
        state.remoteUsers = {};
        
        await initAgora(gid, state.currentUser.id, state.currentUser.name);
      } catch (e) {
        console.error("Rejoin failed", e);
        window.location.reload();
      }
    }

    function showConfirmationModal(title, message, callback) {
      state.confirmationCallback = callback;
      document.getElementById('modal-title').textContent = title;
      document.getElementById('modal-message').textContent = message;
      document.getElementById('confirmation-modal').style.display = 'flex';
    }

    function closeConfirmationModal() {
      document.getElementById('confirmation-modal').style.display = 'none';
      state.confirmationCallback = null;
    }

    function executeConfirmation() {
      if (state.confirmationCallback) {
        state.confirmationCallback();
      }
      closeConfirmationModal();
    }

    // ============= NOTIFICATION PERMISSIONS & SOUNDS =============
    async function requestNotificationPermissions() {
      if ('Notification' in window && Notification.permission === 'default') {
        try {
          const permission = await Notification.requestPermission();
          if (permission === 'granted') {
            console.log('Notification permission granted');
          }
        } catch (error) {
          console.log('Notification permission request failed:', error);
        }
      }
    }

    function playNotificationSound() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.5);
      } catch (error) {
        console.log('Notification sound error:', error);
      }
    }

    function showNotification(message, type = 'info') {
      if ('Notification' in window && Notification.permission === 'granted') {
        try {
          new Notification('PeerLoom', {
            body: message,
            icon: '/docs/favicon.ico',
            badge: '/docs/favicon.ico',
            tag: 'peerloom-notification'
          });
          playNotificationSound();
        } catch (error) {
          console.log('Notification error:', error);
        }
      }

      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: var(--glass-bg);
        backdrop-filter: var(--glass-blur);
        border: 1px solid var(--glass-border);
        padding: 14px 20px;
        border-radius: 16px;
        box-shadow: var(--shadow);
        z-index: 3000;
        animation: slideIn 0.3s ease-out;
        max-width: 300px;
        display: flex;
        align-items: center;
        gap: 12px;
        color: var(--text-color);
      `;
      
      let icon = 'info-circle';
      let iconColor = 'var(--accent-blue)';
      
      switch(type) {
        case 'recording': icon = 'circle-dot'; iconColor = 'var(--red)'; break;
        case 'hand': icon = 'hand'; iconColor = 'var(--accent-yellow)'; break;
        case 'mic': icon = 'microphone'; iconColor = 'var(--accent-green)'; break;
        case 'camera': icon = 'video'; iconColor = 'var(--accent-green)'; break;
        case 'ai': icon = 'robot'; iconColor = 'var(--accent-purple)'; break;
        case 'theme': icon = 'palette'; iconColor = 'var(--accent-purple)'; break;
        case 'user': icon = 'user'; iconColor = 'var(--accent-blue)'; break;
        case 'share': icon = 'desktop'; iconColor = 'var(--accent-blue)'; break;
        case 'end': icon = 'phone-slash'; iconColor = 'var(--red)'; break;
        case 'download': icon = 'download'; iconColor = 'var(--accent-green)'; break;
        case 'link': icon = 'link'; iconColor = 'var(--accent-blue)'; break;
        case 'check': icon = 'check-circle'; iconColor = 'var(--accent-green)'; break;
        case 'spotlight': icon = 'star'; iconColor = 'var(--accent-yellow)'; break;
      }
      
      notification.innerHTML = `
        <i class="fas fa-${icon}" style="color: ${iconColor}; font-size: 18px;"></i>
        <span>${message}</span>
      `;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }



    // ============= THEME TOGGLE =============
    document.getElementById('dark-mode-toggle').addEventListener('click', () => {
      document.body.classList.toggle('light-mode');
      document.body.classList.toggle('dark-mode');
      const icon = document.querySelector('#dark-mode-toggle i');
      icon.classList.toggle('fa-moon');
      icon.classList.toggle('fa-sun');
      showNotification(document.body.classList.contains('light-mode') ? 'Light Mode' : 'Dark Mode', 'theme');
    });

    // ============= AI PANEL =============
    document.getElementById('ai-toggle').addEventListener('click', () => {
      aiPanel.classList.toggle('open');
    });

    // ============= AGORA VIDEO LOGIC WITH 10,000 USER FIXES =============
    async function initAgora(channelName, uid, userName) {
      updateLoadingStatus("Checking system requirements...");
      
      if (!state.agoraAppId) {
        showCriticalError("Configuration Error: Agora App ID is missing.");
        return;
      }

      if (!AgoraRTC.checkSystemRequirements()) {
        showNotification("Your browser does not support video calling.", "end");
        return;
      }

      state.client = AgoraRTC.createClient({ mode: "rtc", codec: "vp8" });

      state.client.on("user-published", handleUserPublished);
      state.client.on("user-unpublished", handleUserUnpublished);
      
      state.client.on("user-joined", (user) => {
        // SPOTLIGHT IMMUNITY: Don't change spotlight when users join
        if (state.spotlightUserId && state.spotlightImmune) return;
        
        let student = state.students.find(s => s.id === user.uid);
        const name = student?.name || `User ${user.uid.slice(0, 8)}`;
        showNotification(`${name} joined the meeting`, 'user');
      });

      state.client.on("user-left", (user, reason) => {
        // SPOTLIGHT IMMUNITY: Don't change spotlight when users leave
        if (state.spotlightUserId && state.spotlightImmune) {
          // Just remove the tile if it's not the spotlight user
          if (user.uid !== state.spotlightUserId) {
            const tile = document.getElementById(`tile-${user.uid}`);
            if (tile) tile.remove();
            state.renderedVideoTiles.delete(user.uid);
          }
        } else {
          const tile = document.getElementById(`tile-${user.uid}`);
          if (tile) tile.remove();
          state.renderedVideoTiles.delete(user.uid);
        }
        
        // Remove from raised hands
        if (state.raisedHands.has(user.uid)) {
          state.raisedHands.delete(user.uid);
        }
        
        // Remove from promoted speakers
        state.promotedSpeakers.delete(user.uid);
        
        let student = state.students.find(s => s.id === user.uid);
        const name = student?.name || `User ${user.uid.slice(0, 8)}`;
        
        if (reason === "ServerTimeOut") {
           showNotification(`${name} dropped due to network timeout`, "info");
        } else {
           showNotification(`${name} left the meeting`, "end");
        }
      });

      state.client.on("connection-state-change", (curState, prevState) => {
        if (curState === "RECONNECTING") {
          showNotification("Connection lost. Reconnecting...", "info");
          document.getElementById('video-container').style.opacity = "0.5";
        } else if (curState === "CONNECTED" && prevState === "RECONNECTING") {
          showNotification("Connection restored", "info");
          document.getElementById('video-container').style.opacity = "1";
        } else if (curState === "DISCONNECTED" && !state.isIntentionalLeave) {
          showCriticalError("Connection lost. Please rejoin.");
        }
      });

      state.client.on("network-quality", (stats) => {
        const uid = state.currentUser.id;
        const quality = Math.max(stats.downlinkNetworkQuality, stats.uplinkNetworkQuality);
        updateNetworkUI(quality);
      });
      
      state.client.on("exception", (event) => {
        if (event.code === 1003) {
           showNotification("Microphone/Camera error. Check devices.", "end");
        }
      });
      
      state.client.on("token-privilege-will-expire", async () => {
        console.log("Token expiring soon, renewing...");
        await renewToken(channelName, uid);
      });

      try {
        updateLoadingStatus("Authenticating...");
        let token = null;
        
        console.log("Agora App ID:", state.agoraAppId)

        try {
          const { data, error } = await supabase.functions.invoke('generate-agora-token', {
            body: { channelName, uid }
          });
          if (error) throw error;
          if (data?.token) token = data.token;
        } catch (error) {
          console.error("Token fetch failed:", error);
          if (error) {
             showNotification("Warning: Token server unreachable. Video may fail.", "end");
          }
        }

        updateLoadingStatus("Connecting to media server...");
        await state.client.join(state.agoraAppId, channelName, token, uid);

        // TRUE 10,000 USER LOCKDOWN: Students join in listen-only mode
        if (!state.isHost) {
          // Students start with mic and camera disabled
          state.isMicOn = false;
          state.isCameraOn = false;
          state.forceListenOnly = true;
          
          // Only create tracks if user is promoted to speaker
          if (state.promotedSpeakers.has(uid)) {
            try {
              updateLoadingStatus("Accessing camera and microphone...");
              [state.localAudioTrack, state.localVideoTrack] = await AgoraRTC.createMicrophoneAndCameraTracks();
              state.localAudioTrack.setEnabled(false);
              state.localVideoTrack.setEnabled(false);
              await state.client.publish([state.localAudioTrack, state.localVideoTrack]);
            } catch (permError) {
              console.log("Student cannot access media devices (listen-only mode)");
            }
          }
        } else {
          // Host always has tracks
          try {
            updateLoadingStatus("Accessing camera and microphone...");
            [state.localAudioTrack, state.localVideoTrack] = await AgoraRTC.createMicrophoneAndCameraTracks();
            state.localAudioTrack.setEnabled(true);
            state.localVideoTrack.setEnabled(true);
            state.isMicOn = true;
            state.isCameraOn = true;
            await state.client.publish([state.localAudioTrack, state.localVideoTrack]);
          } catch (permError) {
            if (permError.name === 'NotAllowedError') {
              showNotification("Microphone/Camera access denied. Please check browser settings.", "end");
              return;
            }
            throw permError;
          }
        }
        
        const container = document.getElementById('video-container');
        const hostTile = document.getElementById('host-tile');
        
        if (state.isHost && hostTile) {
          hostTile.id = `tile-${uid}`;
          hostTile.innerHTML = '';
          
          const playerContainer = document.createElement('div');
          playerContainer.id = `player-${uid}`;
          playerContainer.style.width = '100%';
          playerContainer.style.height = '100%';
          playerContainer.style.position = 'absolute';
          playerContainer.style.top = '0';
          playerContainer.style.left = '0';
          playerContainer.style.transform = 'scaleX(-1)';
          hostTile.appendChild(playerContainer);
          
          const nameTag = document.createElement('div');
          nameTag.className = 'name-tag';
          nameTag.innerHTML = `<span>${userName} (You)</span><span class="host-badge">HOST</span>`;
          hostTile.appendChild(nameTag);
          
          if (state.localVideoTrack) {
            state.localVideoTrack.play(`player-${uid}`);
          }
        } else if (state.promotedSpeakers.has(uid) || state.isHost) {
          // Only create video tile for promoted speakers or host
          const localPlayerDiv = createVideoTile(uid, userName + " (You)", true);
          if (localPlayerDiv) {
            container.appendChild(localPlayerDiv);
            if (state.localVideoTrack) {
              state.localVideoTrack.play(`player-${uid}`);
            }
          }
        }

        // Update control bar UI to match actual state
        const micBtn = document.querySelector('[data-action="mic"]');
        const camBtn = document.querySelector('[data-action="cam"]');
        
        if (micBtn) {
          const micIcon = micBtn.querySelector('i');
          if (micIcon) {
            if (state.isMicOn) {
              micIcon.classList.remove('fa-microphone-slash');
              micIcon.classList.add('fa-microphone');
              micBtn.classList.add('active');
            } else {
              micIcon.classList.remove('fa-microphone');
              micIcon.classList.add('fa-microphone-slash');
              micBtn.classList.remove('active');
            }
          }
        }
        
        if (camBtn) {
          const camIcon = camBtn.querySelector('i');
          if (camIcon) {
            if (state.isCameraOn) {
              camIcon.classList.remove('fa-video-slash');
              camIcon.classList.add('fa-video');
              camBtn.classList.add('active');
            } else {
              camIcon.classList.remove('fa-video');
              camIcon.classList.add('fa-video-slash');
              camBtn.classList.remove('active');
            }
          }
        }
        
        showNotification("Connected to video stream", "camera");
        
        if (loadingOverlay) loadingOverlay.classList.add('hidden');

      } catch (error) {
        console.error("Agora Error:", error);
        if (loadingOverlay) loadingOverlay.classList.add('hidden');
        if (error.code === "CAN_NOT_GET_GATEWAY_SERVER") {
          showCriticalError("Security Error: Invalid App ID or Token. Please contact support.");
        } else {
          showCriticalError("Connection failed: " + error.message);
        }
      }
    }

    async function renewToken(channelName, uid) {
      try {
        const { data, error } = await supabase.functions.invoke('generate-agora-token', {
          body: { channelName, uid }
        });
        
        if (!error && data?.token) {
          await state.client.renewToken(data.token);
          console.log("Token renewed successfully");
        }
      } catch (error) {
        console.error("Token renewal failed:", error);
      }
    }

    function createVideoTile(uid, name, isLocal = false) {
      // TRUE 10,000 USER LOCKDOWN: Only create video tiles for speakers
      if (!state.isHost && !state.promotedSpeakers.has(uid) && uid !== state.currentUser?.id) {
        return null;
      }
      
      const div = document.createElement('div');
      div.className = 'video-tile';
      div.id = `tile-${uid}`;
      
      const playerContainer = document.createElement('div');
      playerContainer.id = `player-${uid}`;
      playerContainer.style.width = '100%';
      playerContainer.style.height = '100%';
      playerContainer.style.position = 'absolute';
      playerContainer.style.top = '0';
      playerContainer.style.left = '0';
      if (isLocal) playerContainer.style.transform = 'scaleX(-1)';
      
      div.appendChild(playerContainer);

      const nameTag = document.createElement('div');
      nameTag.className = 'name-tag';
      nameTag.innerHTML = `<span>${name}</span>`;
      if (state.isHost && uid === state.currentUser.id) {
        nameTag.innerHTML += `<span class="host-badge">HOST</span>`;
      }
      div.appendChild(nameTag);

      // Add Kick Button for Host
      if (state.isHost && uid !== state.currentUser.id) {
        const kickBtn = document.createElement('button');
        kickBtn.className = 'kick-btn';
        kickBtn.innerHTML = '<i class="fas fa-user-times"></i>';
        kickBtn.title = 'Remove Student';
        kickBtn.style.cssText = `
          position: absolute;
          top: 10px;
          right: 10px;
          width: 32px;
          height: 32px;
          border-radius: 50%;
          background: rgba(255, 59, 48, 0.9);
          color: white;
          border: none;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 20;
          opacity: 0;
          transition: opacity 0.2s ease;
          box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        `;
        
        kickBtn.onclick = (e) => {
          e.stopPropagation();
          removeStudent(uid);
        };
        
        div.appendChild(kickBtn);
        
        // Show on hover
        div.addEventListener('mouseenter', () => { kickBtn.style.opacity = '1'; });
        div.addEventListener('mouseleave', () => { kickBtn.style.opacity = '0'; });
        
        // Always show on mobile
        if (state.isMobile) kickBtn.style.opacity = '1';
      }

      // Track rendered tiles
      state.renderedVideoTiles.add(uid);
      
      return div;
    }

    async function handleUserPublished(user, mediaType) {
      // TRUE 10,000 USER LOCKDOWN: Only subscribe to host and promoted speakers
      const shouldSubscribe = state.isHost || 
                             user.uid === state.hostId || 
                             state.promotedSpeakers.has(user.uid) ||
                             user.uid === state.currentUser?.id;
      
      if (!shouldSubscribe) {
        console.log(`Skipping subscription to non-speaker user ${user.uid}`);
        return;
      }

      await state.client.subscribe(user, mediaType);

      if (mediaType === 'video') {
        console.log(`Subscribing to video of user ${user.uid}`);
        const container = document.getElementById('video-container');
        let tile = document.getElementById(`tile-${user.uid}`);
        
        if (!tile) {
          let name = `User ${user.uid}`;
          const isHostUser = (user.uid === state.hostId);

          if (isHostUser) {
            name = state.hostName || 'Host';
            const placeholder = document.getElementById('host-tile');
            if (placeholder) {
              tile = placeholder;
              tile.id = `tile-${user.uid}`;
              tile.innerHTML = '';
              
              const playerContainer = document.createElement('div');
              playerContainer.id = `player-${user.uid}`;
              playerContainer.style.width = '100%';
              playerContainer.style.height = '100%';
              playerContainer.style.position = 'absolute';
              playerContainer.style.top = '0';
              playerContainer.style.left = '0';
              tile.appendChild(playerContainer);
              
              const nameTag = document.createElement('div');
              nameTag.className = 'name-tag';
              nameTag.innerHTML = `<span>${name}</span><span class="host-badge">HOST</span>`;
              tile.appendChild(nameTag);
            }
          }

          if (!tile) {
            const student = state.students.find(s => s.id === user.uid);
            if (student) {
              name = student.name;
            } else {
              const { data: profile } = await supabase.from('profiles').select('full_name, username').eq('id', user.uid).single();
              if (profile) name = profile.full_name || profile.username;
            }
            
            tile = createVideoTile(user.uid, name);
            if (tile) {
              container.appendChild(tile);
            }
          }
          
          if (tile) {
            updateAttendance({ id: user.uid, name: name });
            
            // Store remote user
            state.remoteUsers[user.uid] = user;
          }
        }
        
        if (tile) {
          user.videoTrack.play(`player-${user.uid}`);
        }
      }

      if (mediaType === 'audio') {
        console.log(`Subscribing to audio of user ${user.uid}`);
        user.audioTrack.play();
        
        // Store remote user
        if (!state.remoteUsers[user.uid]) {
          state.remoteUsers[user.uid] = user;
        } else {
          state.remoteUsers[user.uid].audioTrack = user.audioTrack;
        }
      }
    }


    async function handleUserUnpublished(user, mediaType) {
      console.log(`User ${user.uid} unpublished ${mediaType}`);
      if (mediaType === 'video') {
        const tile = document.getElementById(`tile-${user.uid}`);
        if (tile) tile.remove();
        state.renderedVideoTiles.delete(user.uid);
      }
      
      // Remove from remote users
      if (state.remoteUsers[user.uid]) {
        if (mediaType === 'video') {
          delete state.remoteUsers[user.uid].videoTrack;
        }
        if (mediaType === 'audio') {
          delete state.remoteUsers[user.uid].audioTrack;
        }
      }
    }

    function updateNetworkUI(quality) {
      const icon = document.querySelector('.fa-signal');
      const text = document.querySelector('.fa-signal + span');
      
      if (quality <= 2) {
        icon.style.color = 'var(--accent-green)';
        text.textContent = 'HD';
      } else if (quality <= 4) {
        icon.style.color = 'var(--accent-yellow)';
        text.textContent = 'Weak';
      } else {
        icon.style.color = 'var(--red)';
        text.textContent = 'Bad';
      }
    }

    // ============= WAITING ROOM LOGIC =============
    function showWaitingForHostOverlay(gid, user) {
      const overlay = document.getElementById('waiting-room-overlay');
      overlay.classList.remove('hidden');
      overlay.querySelector('h2').textContent = "Waiting for Host to Start";
      overlay.querySelector('p').textContent = "The host has not started the class yet. You will join automatically when they arrive.";
      
      const channel = supabase.channel(`waiting_start_${gid}`)
        .on('postgres_changes', { 
          event: 'INSERT', 
          schema: 'public', 
          table: 'meeting_requests', 
          filter: `group_id=eq.${gid}`
        }, (payload) => {
          if (payload.new.status === 'host_active') {
            supabase.removeChannel(channel);
            checkWaitingRoom(gid, user, () => completeSessionSetup(gid, user));
          }
        })
        .subscribe();
    }

    async function checkWaitingRoom(gid, user, onApproved) {
      // Reset overlay text in case it was changed
      const overlay = document.getElementById('waiting-room-overlay');
      overlay.querySelector('h2').textContent = "Waiting for Host";
      overlay.querySelector('p').textContent = "Please wait while the host admits you to the class.";

      const { data: request } = await supabase
        .from('meeting_requests')
        .select('*')
        .eq('group_id', gid)
        .eq('user_id', user.id)
        .maybeSingle();

      if (request?.status === 'approved') {
        onApproved();
        return true;
      }
      
      document.getElementById('waiting-room-overlay').classList.remove('hidden');

      if (!request) {
        await supabase.from('meeting_requests').insert({
          group_id: gid,
          user_id: user.id,
          user_name: user.user_metadata.firstName || user.user_metadata.full_name || 'Student',
          status: 'pending'
        });
      } else if (request.status === 'rejected') {
        await supabase.from('meeting_requests')
          .update({ status: 'pending' })
          .eq('id', request.id);
      }

      supabase.channel(`waiting_${user.id}`)
        .on('postgres_changes', { 
          event: 'UPDATE', 
          schema: 'public', 
          table: 'meeting_requests', 
          filter: `user_id=eq.${user.id}`
        }, (payload) => {
          if (payload.new.status === 'approved') {
            document.getElementById('waiting-room-overlay').classList.add('hidden');
            onApproved();
          } else if (payload.new.status === 'rejected') {
            showNotification('Access denied - you were not approved to join.', 'end');
            setTimeout(() => { window.location.href = 'dashboard.html'; }, 2000);
          }
        })
        .subscribe();

      return false;
    }

    function setupHostWaitingRoom(gid) {
      fetchPendingRequests(gid);
      
      supabase.channel('host_waiting_room')
        .on('postgres_changes', {
          event: '*',
          schema: 'public',
          table: 'meeting_requests',
          filter: `group_id=eq.${gid}`
        }, () => fetchPendingRequests(gid))
        .subscribe();
    }



    async function fetchPendingRequests(gid) {
      const { data: requests } = await supabase
        .from('meeting_requests')
        .select('*')
        .eq('group_id', gid)
        .eq('status', 'pending');
      
      let newData = requests || [];

      if (newData.length > 0) {
        const userIds = newData.map(r => r.user_id);
        const { data: profiles } = await supabase
          .from('profiles')
          .select('id, profile_photo')
          .in('id', userIds);
        
        if (profiles) {
          newData = newData.map(req => {
            const profile = profiles.find(p => p.id === req.user_id);
            return { ...req, profile_photo: profile?.profile_photo };
          });
        }
      }
      
      if (newData.length > state.waitingStudents.length) {
        playNotificationSound();
        showNotification('New student in waiting room', 'user');
      }
      
      state.waitingStudents = newData;
      updateWaitingRoomUI();
    }

    function updateWaitingRoomUI() {
      const badge = document.getElementById('waiting-room-badge');
      const list = document.getElementById('waiting-list');
      const acceptAllBtn = document.getElementById('accept-all-btn');
      
      if (state.waitingStudents.length > 0) {
        badge.textContent = state.waitingStudents.length;
        badge.style.display = 'flex';
        if (acceptAllBtn) acceptAllBtn.style.display = 'block';
      } else {
        badge.style.display = 'none';
        if (acceptAllBtn) acceptAllBtn.style.display = 'none';
      }

      list.innerHTML = state.waitingStudents.length === 0 ? '<div style="padding:20px; text-align:center; opacity:0.7;">No pending requests</div>' : '';

      state.waitingStudents.forEach(req => {
        const div = document.createElement('div');
        div.className = 'waiting-list-item';
        
        const initials = (req.user_name || 'S').charAt(0).toUpperCase();
        const avatarHtml = req.profile_photo 
          ? `<img src="${req.profile_photo}" style="width:32px; height:32px; border-radius:50%; object-fit:cover; margin-right:10px; border: 1px solid var(--glass-border);">`
          : `<div style="width:32px; height:32px; border-radius:50%; background:linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); color:white; display:flex; align-items:center; justify-content:center; margin-right:10px; font-size:14px; font-weight:bold;">${initials}</div>`;

        div.innerHTML = `
          <div style="display:flex; align-items:center;">${avatarHtml}<span style="font-weight:500;">${req.user_name}</span></div>
          <div class="waiting-actions">
            <button class="approve-btn" onclick="approveStudent('${req.id}', '${req.user_id}')"><i class="fas fa-check"></i></button>
            <button class="reject-btn" onclick="rejectStudent('${req.id}')"><i class="fas fa-times"></i></button>
          </div>
        `;
        list.appendChild(div);
      });
    }

    async function approveStudent(id, userId) {
      console.log('Approving student:', id);
      try {
        const { error } = await supabase.from('meeting_requests').update({ status: 'approved' }).eq('id', id);
        if (error) throw error;
        
        // Add to promoted speakers
        state.promotedSpeakers.add(userId);
        
        // Notify student they are now a speaker
        if (state.channel) {
          state.channel.send({
            type: 'broadcast',
            event: 'promote-speaker',
            payload: { userId }
          });
        }
        
        state.waitingStudents = state.waitingStudents.filter(s => s.id !== id);
        updateWaitingRoomUI();
        showNotification('Student admitted as speaker', 'check');
      } catch (error) {
        console.error('Error approving student:', error);
        showNotification('Failed to approve request', 'end');
      }
    }

    async function rejectStudent(id) {
      console.log('Rejecting student:', id);
      try {
        const { error } = await supabase.from('meeting_requests').update({ status: 'rejected' }).eq('id', id);
        if (error) throw error;
        
        state.waitingStudents = state.waitingStudents.filter(s => s.id !== id);
        updateWaitingRoomUI();
        showNotification('Request denied', 'info');
      } catch (error) {
        console.error('Error rejecting student:', error);
        showNotification('Failed to reject request', 'end');
      }
    }

    async function removeStudent(userId) {
      showConfirmationModal(
        'Remove Student?',
        'Are you sure you want to remove this student from the meeting?',
        async () => {
          const gid = new URLSearchParams(window.location.search).get('groupId');
      
          try {
            const { error } = await supabase
              .from('meeting_requests')
              .update({ status: 'rejected' })
              .eq('group_id', gid)
              .eq('user_id', userId);
              
            if (error) throw error;
            
            // Remove from promoted speakers
            state.promotedSpeakers.delete(userId);
            
            showNotification('Student removed', 'info');
          } catch (error) {
            console.error('Error removing student:', error);
            showNotification('Failed to remove student', 'end');
          }
        }
      );
    }

    async function approveAllStudents() {
      if (state.waitingStudents.length === 0) return;
      
      const ids = state.waitingStudents.map(s => s.id);
      const userIds = state.waitingStudents.map(s => s.user_id);
      console.log('Approving all students:', ids);
      
      try {
        const { error } = await supabase.from('meeting_requests').update({ status: 'approved' }).in('id', ids);
        if (error) throw error;
        
        // Add all to promoted speakers
        userIds.forEach(userId => state.promotedSpeakers.add(userId));
        
        // Notify all students
        if (state.channel) {
          userIds.forEach(userId => {
            state.channel.send({
              type: 'broadcast',
              event: 'promote-speaker',
              payload: { userId }
            });
          });
        }
        
        state.waitingStudents = [];
        updateWaitingRoomUI();
        showNotification('All students admitted as speakers', 'check');
      } catch (error) {
        console.error('Error approving all students:', error);
        showNotification('Failed to approve requests', 'end');
      }
    }

    async function resetAllRequests() {
      showConfirmationModal(
        'Reset Waiting Room?',
        'Are you sure you want to reset all waiting room requests? This will require all students to be re-admitted.',
        async () => {
          const gid = new URLSearchParams(window.location.search).get('groupId');

          try {
            const { error } = await supabase
              .from('meeting_requests')
              .update({ status: 'pending' })
              .eq('group_id', gid);

            if (error) throw error;
            showNotification('All student requests reset to pending.', 'info');
            fetchPendingRequests(gid);
          } catch (error) {
            console.error('Error resetting requests:', error);
            showNotification('Failed to reset requests.', 'end');
          }
        }
      );
    }

    function openWaitingRoom() { 
      if (!state.isHost) {
        showNotification('Only host can access waiting room', 'info');
        return;
      }
      waitingRoomModal.style.display = 'flex'; 
    }
    
    function closeWaitingRoomModal() { waitingRoomModal.style.display = 'none'; }

    function updateLoadingStatus(text) {
      if (loadingStatus) loadingStatus.textContent = text;
    }

    function showCriticalError(msg) {
      document.getElementById('error-message').textContent = msg;
      document.getElementById('error-modal').style.display = 'flex';
    }

    // ============= DEVICE SETTINGS =============
    async function openDeviceSettingsModal(gid, user) {
      const modal = document.getElementById('device-settings-modal');
      const loadingOverlay = document.getElementById('loading-overlay');
      
      loadingOverlay.classList.add('hidden');
      modal.style.display = 'flex';
      
      try {
        // TRUE 10,000 USER LOCKDOWN: Only create preview for host or promoted speakers
        if (state.isHost || state.promotedSpeakers.has(user.id)) {
          if (!state.localAudioTrack || !state.localVideoTrack) {
             [state.localAudioTrack, state.localVideoTrack] = await AgoraRTC.createMicrophoneAndCameraTracks();
             
             // Set initial state based on role
             if (!state.isHost) {
               state.localAudioTrack.setEnabled(false);
               state.localVideoTrack.setEnabled(false);
               state.isMicOn = false;
               state.isCameraOn = false;
             } else {
               state.localAudioTrack.setEnabled(true);
               state.localVideoTrack.setEnabled(true);
               state.isMicOn = true;
               state.isCameraOn = true;
             }
          }
          
          state.localVideoTrack.play('local-preview');
        }
        
        const devices = await AgoraRTC.getDevices();
        const cams = devices.filter(d => d.kind === 'videoinput');
        const mics = devices.filter(d => d.kind === 'audioinput');
        
        const camSelect = document.getElementById('camera-select');
        const micSelect = document.getElementById('mic-select');
        
        camSelect.innerHTML = cams.map(d => `<option value="${d.deviceId}">${d.label || 'Camera ' + (cams.indexOf(d) + 1)}</option>`).join('');
        micSelect.innerHTML = mics.map(d => `<option value="${d.deviceId}">${d.label || 'Microphone ' + (mics.indexOf(d) + 1)}</option>`).join('');
        
        camSelect.onchange = async (e) => {
          state.selectedCamId = e.target.value;
          if (state.localVideoTrack) {
            state.localVideoTrack.stop();
            state.localVideoTrack.close();
          }
          state.localVideoTrack = await AgoraRTC.createCameraVideoTrack({ cameraId: state.selectedCamId });
          state.localVideoTrack.play('local-preview');
        };
        
        micSelect.onchange = async (e) => {
          state.selectedMicId = e.target.value;
          if (state.localAudioTrack) {
            state.localAudioTrack.stop();
            state.localAudioTrack.close();
          }
          state.localAudioTrack = await AgoraRTC.createMicrophoneAudioTrack({ microphoneId: state.selectedMicId });
        };
        
        document.getElementById('join-btn').onclick = async () => {
          modal.style.display = 'none';
          loadingOverlay.classList.remove('hidden');
          await initAgora(gid, user.id, user.user_metadata.firstName || user.user_metadata.full_name || 'User');
        };

      } catch (e) {
        console.error("Error in device settings:", e);
        showCriticalError("Could not access camera/microphone. Please check permissions.");
      }
    }

    // ============= SESSION SETUP =============
    async function completeSessionSetup(gid, user) {
        const { data: members } = await supabase
          .from('group_members')
          .select('user_id, profiles(full_name, username)')
          .eq('group_id', gid);

        if (members) {
          state.students = members
            .filter(m => m.user_id !== user.id)
            .map((m, i) => ({
              id: m.user_id,
              name: m.profiles?.full_name || m.profiles?.username || `User ${i}`,
              role: 'student'
            }));
        }

        state.channel = supabase.channel(`grp_${gid}`)
          .on('postgres_changes', {
            event: 'INSERT',
            schema: 'public',
            table: 'group_messages',
            filter: `group_id=eq.${gid}`
          }, (payload) => {
            const msg = payload.new;
            const isSelf = msg.sender_id === user.id;
            addMessage(msg.content, msg.sender_name, isSelf, false, msg.created_at);
          })
          .on('broadcast', { event: 'spotlight' }, (payload) => {
            // SPOTLIGHT IMMUNITY: Only change when explicitly broadcast
            state.spotlightUserId = payload.payload.spotlightUserId;
            state.spotlightImmune = payload.payload.immune || true;
            toggleSpotlightUI(payload.payload.active);
          })
          .on('broadcast', { event: 'whiteboard-toggle' }, (payload) => {
            if (payload.payload.active) {
              state.isWhiteboardActive = true;
              whiteboardOverlay.classList.add('active');
              whiteboardTools.classList.add('active');
              resizeCanvas();
            } else {
              state.isWhiteboardActive = false;
              whiteboardOverlay.classList.remove('active');
              whiteboardTools.classList.remove('active');
            }
          })
          .on('broadcast', { event: 'whiteboard-batch' }, (payload) => {
            const commands = payload.payload.commands || [];
            commands.forEach(cmd => {
              ctx.beginPath();
              ctx.moveTo(cmd.fromX, cmd.fromY);
              ctx.lineTo(cmd.toX, cmd.toY);
              ctx.strokeStyle = cmd.color;
              ctx.lineWidth = cmd.lineWidth;
              ctx.lineCap = 'round';
              if (cmd.tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
              }
              ctx.stroke();
              if (cmd.tool === 'eraser') {
                ctx.globalCompositeOperation = 'source-over';
              }
            });
          })
          .on('broadcast', { event: 'mute-all' }, (payload) => {
            state.mediaControlLocked = payload.payload.locked;
            state.hardMuteLock = payload.payload.hardLock || false;
            if (state.localAudioTrack) {
              state.localAudioTrack.setEnabled(false);
              state.isMicOn = false;
              
              // Update UI
              const micBtn = document.querySelector('[data-action="mic"]');
              if (micBtn) {
                const micIcon = micBtn.querySelector('i');
                micIcon.classList.remove('fa-microphone');
                micIcon.classList.add('fa-microphone-slash');
                micBtn.classList.remove('active');
                micBtn.classList.add('media-locked');
              }
            }
            showNotification('Host muted all participants', 'mute');
          })
          .on('broadcast', { event: 'unmute-all' }, (payload) => {
            state.mediaControlLocked = payload.payload.locked;
            state.hardMuteLock = payload.payload.hardLock || false;
            const micBtn = document.querySelector('[data-action="mic"]');
            if (micBtn) {
              micBtn.classList.remove('media-locked');
            }
            showNotification('You can now unmute', 'mic');
          })
          .on('broadcast', { event: 'disable-cameras' }, (payload) => {
            state.cameraControlLocked = payload.payload.locked;
            state.hardCameraLock = payload.payload.hardLock || false;
            if (state.localVideoTrack) {
              state.localVideoTrack.setEnabled(false);
              state.isCameraOn = false;
              
              // Update UI
              const camBtn = document.querySelector('[data-action="cam"]');
              if (camBtn) {
                const camIcon = camBtn.querySelector('i');
                camIcon.classList.remove('fa-video');
                camIcon.classList.add('fa-video-slash');
                camBtn.classList.remove('active');
                camBtn.classList.add('media-locked');
              }
            }
            showNotification('Host disabled all cameras', 'camera');
          })
          .on('broadcast', { event: 'enable-cameras' }, (payload) => {
            state.cameraControlLocked = payload.payload.locked;
            state.hardCameraLock = payload.payload.hardLock || false;
            const camBtn = document.querySelector('[data-action="cam"]');
            if (camBtn) {
              camBtn.classList.remove('media-locked');
            }
            showNotification('You can now enable camera', 'camera');
          })
          .on('broadcast', { event: 'hand-raise' }, (payload) => {
            if (payload.payload.action === 'raise') {
              const { userId, userName } = payload.payload;
              state.raisedHands.set(userId, {
                name: userName,
                timestamp: Date.now(),
                userId: userId
              });
              
              // Add hand icon to correct video tile
              const userTile = document.getElementById(`tile-${userId}`);
              if (userTile) {
                const existingIcon = userTile.querySelector('.hand-icon');
                if (!existingIcon) {
                  const handIcon = document.createElement('div');
                  handIcon.className = 'hand-icon';
                  handIcon.innerHTML = '✋';
                  userTile.appendChild(handIcon);
                  userTile.classList.add('hand-raised');
                }
              }
              
              // Add message to chat for host
              if (state.isHost) {
                addMessage(`${userName} raised hand ✋`, 'system');
              }

              // Show notification to all users
              showNotification(`${userName} raised hand`, 'hand');
            }
          })
          .on('broadcast', { event: 'hand-lower' }, (payload) => {
            lowerHand(payload.payload.userId);
          })
          .on('broadcast', { event: 'screen-share-request' }, (payload) => {
            if (state.isHost) {
              state.screenShareRequests.push(payload.payload);
              showNotification(`${payload.payload.studentName} wants to share screen`, 'info');
            }
          })
          .on('broadcast', { event: 'screen-share-started' }, (payload) => {
            state.currentPresenter = payload.payload.userId;
          })
          .on('broadcast', { event: 'screen-share-stopped' }, (payload) => {
            if (state.currentPresenter === payload.payload.userId) {
              state.currentPresenter = null;
            }
          })
          .on('broadcast', { event: 'force-stop-screenshare' }, (payload) => {
            if (state.currentPresenter === payload.payload.userId) {
              stopScreenSharing();
              showNotification('Host stopped your screen share', 'info');
            }
          })
          .on('broadcast', { event: 'student-mic-change' }, (payload) => {
            // Host can track student mic states
            if (state.isHost) {
              console.log(`Student ${payload.payload.userId} mic: ${payload.payload.isMicOn}`);
            }
          })
          .on('broadcast', { event: 'student-cam-change' }, (payload) => {
            // Host can track student camera states
            if (state.isHost) {
              console.log(`Student ${payload.payload.userId} camera: ${payload.payload.isCameraOn}`);
            }
          })
          .on('broadcast', { event: 'promote-speaker' }, (payload) => {
            if (payload.payload.userId === state.currentUser?.id) {
              enablePresenterMode(payload.payload.userId);
            }
          })
          .on('broadcast', { event: 'demote-speaker' }, (payload) => {
            if (payload.payload.userId === state.currentUser?.id) {
              disablePresenterMode(payload.payload.userId);
            }
          })
          .on('broadcast', { event: 'end-meeting-for-all' }, () => {
            if (!state.isHost) {
              showNotification('Host has ended the meeting', 'end');
              state.isIntentionalLeave = true;
              
              if (state.client) {
                state.client.leave();
                if (state.localAudioTrack) state.localAudioTrack.close();
                if (state.localVideoTrack) state.localVideoTrack.close();
              }

              setTimeout(() => {
                const gid = new URLSearchParams(window.location.search).get('groupId');
                if (gid) {
                  window.location.href = `chatroom.html?groupId=${gid}`;
                } else {
                  window.location.href = 'dashboard.html';
                }
              }, 2000);
            }
          })
          .subscribe();

        supabase.channel(`status_${user.id}`)
          .on('postgres_changes', {
            event: 'UPDATE',
            schema: 'public',
            table: 'meeting_requests',
            filter: `user_id=eq.${user.id}`
          }, (payload) => {
            if (payload.new.status === 'rejected' && payload.new.group_id === gid) {
              showNotification('You have been removed from the meeting.', 'end');
              setTimeout(() => { window.location.href = 'dashboard.html'; }, 2000);
            }
          })
          .subscribe();

        openDeviceSettingsModal(gid, user);
    }

    // ============= INITIALIZATION =============
    async function initialize() {
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        window.location.href = 'login.html';
        return;
      }

      const user = session.user;
      state.currentUser = {
        id: user.id,
        name: user.user_metadata.firstName || user.user_metadata.full_name || 'User',
        email: user.email,
        role: 'student'
      };
      state.isAuthenticated = true;

      const gid = new URLSearchParams(window.location.search).get('groupId');
      if (gid) {
        const { data: group } = await supabase
          .from('groups')
          .select('*')
          .eq('id', gid)
          .single();
        
        if (group) {
          state.classTitle = group.name;
          classTitleEl.textContent = group.name;
          
          state.hostId = group.created_by;
          
          if (group.created_by === user.id || state.currentUser.role === 'admin') {
            state.isHost = true;
            state.currentUser.role = 'host';
            hostTools.style.display = 'flex';
            document.body.classList.add('is-host');
            hostNameEl.textContent = state.currentUser.name;
            state.hostName = state.currentUser.name;
          } else {
            const { data: hostProfile } = await supabase
              .from('profiles')
              .select('full_name, username')
              .eq('id', group.created_by)
              .single();
            
            state.hostName = hostProfile?.full_name || hostProfile?.username || 'Host';
            hostNameEl.textContent = state.hostName;
          }

          if (state.isHost) {
            // Mark session as active
            const { data: activeMarker } = await supabase
              .from('meeting_requests')
              .select('id')
              .eq('group_id', gid)
              .eq('user_id', user.id)
              .maybeSingle();
              
            if (!activeMarker) {
              await supabase.from('meeting_requests').insert({
                group_id: gid,
                user_id: user.id,
                user_name: state.currentUser.name,
                status: 'host_active'
              });
            }

            setupHostWaitingRoom(gid);
            await completeSessionSetup(gid, user);
          } else {
            // Check if host has started the meeting
            const { data: hostActive } = await supabase
              .from('meeting_requests')
              .select('id')
              .eq('group_id', gid)
              .eq('status', 'host_active')
              .maybeSingle();
              
            if (!hostActive) {
              showWaitingForHostOverlay(gid, user);
            } else {
              await checkWaitingRoom(gid, user, () => completeSessionSetup(gid, user));
            }
          }
        }
      }
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
          from { transform: translateX(0); opacity: 1; }
          to { transform: translateX(100%); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }

    // Make functions global for HTML event handlers
    window.handleButtonAction = handleButtonAction;
    window.toggleChatDrawer = toggleChatDrawer;
    window.toggleWhiteboard = toggleWhiteboard;
    window.takeAttendance = takeAttendance;
    window.generateSummary = generateSummary;
    window.generateQuiz = generateQuiz;
    window.suggestResources = suggestResources;
    window.muteAllParticipants = muteAllParticipants;
    window.unmuteAllParticipants = unmuteAllParticipants;
    window.disableAllCameras = disableAllCameras;
    window.enableAllCameras = enableAllCameras;
    window.toggleHostSpotlight = toggleHostSpotlight;
    window.lockAllMedia = lockAllMedia;
    window.unlockAllMedia = unlockAllMedia;
    window.showPendingRequests = showPendingRequests;
    window.copyClassLink = copyClassLink;
    window.exportAttendance = exportAttendance;
    window.closeAttendanceModal = closeAttendanceModal;
    window.cancelScreenShare = cancelScreenShare;
    window.closeWhiteboard = closeWhiteboard;
    window.saveWhiteboard = saveWhiteboard;
    window.openWaitingRoom = openWaitingRoom;
    window.closeWaitingRoomModal = closeWaitingRoomModal;
    window.approveStudent = approveStudent;
    window.rejectStudent = rejectStudent;
    window.approveAllStudents = approveAllStudents;
    window.resetAllRequests = resetAllRequests;
    window.removeStudent = removeStudent;
    window.clearAllHands = clearAllHands;
    window.lowerHand = lowerHand;
    window.forceStopScreenShare = forceStopScreenShare;
    window.rejoinSession = rejoinSession;

    window.addEventListener('beforeunload', async () => {
      if (state.client) {
        await state.client.leave();
        if (state.localAudioTrack) state.localAudioTrack.close();
        if (state.localVideoTrack) state.localVideoTrack.close();
      }
    });

    document.addEventListener('DOMContentLoaded', initialize);
  </script>
</body>
</html>
